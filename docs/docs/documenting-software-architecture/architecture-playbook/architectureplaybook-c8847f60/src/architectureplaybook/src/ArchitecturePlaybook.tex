\documentclass[11pt,oneside]{book}

%==============================================================================
% PACKAGES
%==============================================================================
\usepackage[margin=1in]{geometry}
\usepackage{enumitem}
\usepackage[hidelinks]{hyperref}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{parskip}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{tocloft}
\usepackage{etoolbox}
\usepackage{multicol}
\usepackage{tabularx}
\usepackage{colortbl}

\usetikzlibrary{shapes.geometric, arrows.meta, positioning, calc, fit, backgrounds}

%==============================================================================
% COLORS
%==============================================================================
\definecolor{primaryblue}{RGB}{0, 73, 135}
\definecolor{secondaryblue}{RGB}{0, 112, 192}
\definecolor{accentgold}{RGB}{196, 154, 29}
\definecolor{lightgray}{RGB}{245, 245, 245}
\definecolor{darkgray}{RGB}{64, 64, 64}
\definecolor{modulegreen}{RGB}{34, 139, 34}
\definecolor{cncpurple}{RGB}{128, 0, 128}
\definecolor{allocationorange}{RGB}{210, 105, 30}

%==============================================================================
% FORMATTING
%==============================================================================
\setlist[itemize]{leftmargin=1.5em, topsep=0.5em, itemsep=0.3em}
\setlist[enumerate]{leftmargin=1.5em, topsep=0.5em, itemsep=0.3em}
\setlist[description]{leftmargin=2.5em, labelsep=0.8em, topsep=0.5em, itemsep=0.3em}

% Chapter formatting
\titleformat{\chapter}[display]
  {\normalfont\huge\bfseries\color{primaryblue}}
  {\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titlespacing*{\chapter}{0pt}{-20pt}{40pt}

% Section formatting
\titleformat{\section}{\Large\bfseries\color{primaryblue}}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries\color{secondaryblue}}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries\color{darkgray}}{\thesubsubsection}{1em}{}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small\leftmark}
\fancyhead[R]{\small Software Architecture Playbook}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

% Chapter page style
\fancypagestyle{plain}{
  \fancyhf{}
  \fancyfoot[C]{\thepage}
  \renewcommand{\headrulewidth}{0pt}
}

% Table of contents formatting
\renewcommand{\cftchapfont}{\bfseries\color{primaryblue}}
\renewcommand{\cftsecfont}{\color{darkgray}}
\renewcommand{\cftsubsecfont}{\color{darkgray}}
\setlength{\cftbeforechapskip}{1em}

%==============================================================================
% CUSTOM COMMANDS
%==============================================================================
\newcommand{\documentref}[2]{%
  \noindent\fcolorbox{#1}{lightgray}{%
    \begin{minipage}{0.95\textwidth}
      \textbf{\color{#1}#2}
    \end{minipage}%
  }%
}

\newcommand{\keypoint}[1]{%
  \vspace{0.5em}
  \noindent\textcolor{accentgold}{\rule{3pt}{12pt}}\hspace{0.5em}\textbf{#1}
  \vspace{0.3em}
}

\newcommand{\playbookpart}[3]{%
  \begin{center}
  \begin{tikzpicture}
    \node[draw=#1, fill=#1!10, rounded corners=5pt, minimum width=0.9\textwidth, minimum height=1.5cm, align=center] {
      \textbf{\Large\color{#1}#2}\\[0.3em]
      \textcolor{darkgray}{#3}
    };
  \end{tikzpicture}
  \end{center}
}

%==============================================================================
% DOCUMENT
%==============================================================================
\begin{document}

%------------------------------------------------------------------------------
% TITLE PAGE
%------------------------------------------------------------------------------
\begin{titlepage}
\begin{center}

\vspace*{1cm}

\begin{tikzpicture}
  % Background rectangle
  \fill[primaryblue] (-7,-2) rectangle (7,2);
  
  % Title text
  \node[white, align=center] at (0,0.5) {\Huge\bfseries Software Architecture};
  \node[white, align=center] at (0,-0.7) {\Huge\bfseries Documentation Playbook};
\end{tikzpicture}

\vspace{1.5cm}

{\Large\color{secondaryblue} A Comprehensive Guide to Documenting\\[0.3em]
Software Architecture Using Views and Beyond}

\vspace{2cm}

\begin{tikzpicture}[
  box/.style={draw, rounded corners, minimum width=3cm, minimum height=1cm, align=center, font=\small},
  arrow/.style={-Stealth, thick}
]
  % Foundation
  \node[box, fill=accentgold!20, draw=accentgold] (found) at (0,0) {Foundation\\Stakeholders};
  
  % Three viewtypes
  \node[box, fill=modulegreen!20, draw=modulegreen] (mod) at (-4,-2.5) {Module\\Views};
  \node[box, fill=cncpurple!20, draw=cncpurple] (cnc) at (0,-2.5) {C\&C\\Views};
  \node[box, fill=allocationorange!20, draw=allocationorange] (alloc) at (4,-2.5) {Allocation\\Views};
  
  % Arrows
  \draw[arrow, accentgold] (found) -- (mod);
  \draw[arrow, accentgold] (found) -- (cnc);
  \draw[arrow, accentgold] (found) -- (alloc);
  
  % Styles under each viewtype
  \node[font=\scriptsize, align=center, text=darkgray] at (-4,-4) {Decomposition\\Uses\\Generalization\\Layered\\Aspects\\Data Model};
  \node[font=\scriptsize, align=center, text=darkgray] at (0,-4.2) {Pipe-and-Filter\\Client-Server\\Peer-to-Peer\\Publish-Subscribe\\Shared-Data\\SOA};
  \node[font=\scriptsize, align=center, text=darkgray] at (4,-3.8) {Deployment\\Install\\Work Assignment};
  
\end{tikzpicture}

\vspace{2cm}

{\large\color{darkgray} Based on the ``Views and Beyond'' Approach}

\vspace{0.5cm}

{\normalsize\color{darkgray} Clements, Bachmann, Bass, Garlan, Ivers, Little, Merson, Nord, \& Stafford}

\vfill

{\color{darkgray}\today}

\end{center}
\end{titlepage}

%------------------------------------------------------------------------------
% COPYRIGHT / INFORMATION PAGE
%------------------------------------------------------------------------------
\thispagestyle{empty}
\vspace*{\fill}

\begin{center}
\textcolor{primaryblue}{\rule{0.6\textwidth}{1pt}}

\vspace{1em}

{\large\textbf{About This Playbook}}

\vspace{1em}

\textcolor{primaryblue}{\rule{0.6\textwidth}{1pt}}
\end{center}

\vspace{2em}

This playbook provides a comprehensive reference for documenting software architecture using the ``Views and Beyond'' approach developed at the Software Engineering Institute. It consolidates guidance on stakeholder-driven documentation, the three primary viewtypes (Module, Component-and-Connector, and Allocation), and the specific architectural styles within each viewtype.

\vspace{1em}

The playbook is organized to support both learning and reference use. Readers new to architecture documentation can read sequentially to build understanding. Experienced practitioners can use individual sections as reference material for specific documentation tasks.

\vspace{1em}

Each section is designed to be self-contained while maintaining consistency with the overall framework. Cross-references connect related concepts across sections.

\vspace*{\fill}
\newpage

%------------------------------------------------------------------------------
% TABLE OF CONTENTS
%------------------------------------------------------------------------------
\tableofcontents
\newpage

%##############################################################################
% PART I: INTRODUCTION AND FOUNDATION
%##############################################################################
\part{Introduction and Foundation}
\label{part:foundation}

\chapter{Playbook Overview}
\label{ch:overview}

\section{Purpose and Scope}

This Software Architecture Documentation Playbook provides a comprehensive, integrated reference for creating effective architecture documentation. It consolidates the ``Views and Beyond'' approach into a practical guide that architects, developers, and technical leads can apply to real projects.

The playbook addresses a fundamental challenge in software development: how to document architecture in a way that serves stakeholders effectively without consuming excessive resources. The answer lies in understanding that different stakeholders need different information, presented in different ways, at different times. This stakeholder-driven approach ensures that documentation effort produces documentation value.

\subsection{What This Playbook Contains}

The playbook is organized into four major parts, each addressing a distinct aspect of architecture documentation.

Part I establishes the foundation. It explains why architecture documentation matters, introduces the three-viewtype framework, and provides comprehensive guidance on identifying stakeholders and their documentation needs. This foundation ensures that all subsequent documentation decisions are grounded in stakeholder value.

Part II covers Module Views---documentation of static code structure. Module views show how code is organized into units, how those units relate to each other, and how they form hierarchies and layers. Six architectural styles provide specific patterns for module organization: Decomposition, Uses, Generalization, Layered, Aspects, and Data Model.

Part III covers Component-and-Connector (C\&C) Views---documentation of runtime structure. C\&C views show what executes when the system runs, how runtime elements interact, and how data flows through the system. Six architectural styles provide specific patterns for runtime organization: Pipe-and-Filter, Client-Server, Peer-to-Peer, Publish-Subscribe, Shared-Data, and Service-Oriented Architecture.

Part IV covers Allocation Views---documentation of how software maps to non-software structures. Allocation views show where software runs, who develops it, and how it is organized in file systems. Three architectural styles address these mappings: Deployment, Install, and Work Assignment.

\subsection{How to Use This Playbook}

The playbook supports multiple usage patterns.

For learning, read Part I thoroughly to understand the conceptual foundation. Then read the overview chapters for each viewtype (Chapters \ref{ch:module-overview}, \ref{ch:cnc-overview}, and \ref{ch:allocation-overview}) to understand the three categories of views. Finally, study individual styles as needed for your projects.

For reference, use the table of contents and index to locate specific topics. Each style chapter is self-contained, providing complete guidance for that style without requiring reference to other chapters.

For project planning, start with Chapter \ref{ch:stakeholders} to identify stakeholders and their needs. Use the stakeholder-view matrices to select appropriate views. Then consult the relevant style chapters for documentation guidance.

For documentation review, use the checklists and quality criteria in each chapter to evaluate existing documentation and identify improvements.

\section{The Views and Beyond Approach}

The ``Views and Beyond'' approach to architecture documentation, developed at the Software Engineering Institute, provides a systematic framework for creating architecture documentation that serves stakeholder needs. The approach rests on several key principles.

\subsection{Views as the Unit of Documentation}

Architecture documentation is organized around views. A view is a representation of a set of system elements and the relationships among them. Different views show different aspects of the system---its code structure, its runtime behavior, its deployment configuration, and so forth.

Views are not arbitrary. Each view conforms to a viewtype that defines what elements and relationships can appear. Within a viewtype, specific styles provide patterns that constrain and guide how elements are organized. This hierarchy---viewtype to style to view---provides structure while allowing flexibility.

The key insight is that no single view can capture all aspects of an architecture. Different stakeholders need different views. A developer needs to see code dependencies; an operator needs to see deployment topology; a project manager needs to see work assignments. By selecting appropriate views for identified stakeholders, documentation provides value without waste.

\subsection{The Three Viewtypes}

The approach defines three fundamental viewtypes that partition how we think about software systems.

\textbf{Module Viewtype:} Shows the system as a set of code units and their relationships. Module views answer questions like: What are the major code units? How do they depend on each other? How are they organized into layers? What data structures exist? Module views support development planning, impact analysis, and code organization.

\textbf{Component-and-Connector Viewtype:} Shows the system as a set of runtime elements and their interactions. C\&C views answer questions like: What processes execute? How do they communicate? What data flows between them? How does the system respond to events? C\&C views support runtime analysis, performance engineering, and behavioral understanding.

\textbf{Allocation Viewtype:} Shows how software elements map to environmental elements. Allocation views answer questions like: Where does each component run? Who develops each module? How is code organized in file systems? Allocation views support deployment planning, team organization, and build management.

These three viewtypes are comprehensive---they cover all aspects of software architecture that require documentation. They are also orthogonal---each addresses a distinct concern without overlap. Together, they provide complete coverage of architecture documentation needs.

\subsection{Beyond Views: Supporting Documentation}

Views are necessary but not sufficient for complete architecture documentation. The ``Beyond'' in ``Views and Beyond'' refers to additional documentation that complements views.

Documentation beyond views includes: a documentation roadmap that explains what documentation exists and how it is organized; a system overview that provides context and introduces the architecture; element catalogs that provide detailed information about elements shown in views; context diagrams that show the system's environment; variability guides that explain how the architecture accommodates variation; rationale that explains why architectural decisions were made; and mappings between views that show how elements in different views relate.

This supporting documentation transforms a collection of views into a coherent documentation package. Without it, stakeholders may have difficulty navigating and understanding the architecture.

\section{Document Organization and Sequence}

This playbook presents eighteen interconnected documents in a logical sequence designed for both learning and reference. Understanding this organization helps readers navigate the material effectively.

\subsection{The Logical Progression}

The document sequence follows a deliberate progression from foundation to application, from general to specific, and from static to dynamic to environmental.

The sequence begins with stakeholder analysis because all documentation decisions flow from stakeholder needs. Before selecting views or styles, architects must understand who will use the documentation and what they need from it.

Module views come next because they represent the most fundamental architectural perspective---how code is organized. Every software system has code structure, and understanding that structure is prerequisite to understanding runtime behavior or environmental mapping. Within module views, styles progress from the most basic (decomposition) to more specialized (aspects, data model).

Component-and-connector views follow because they build on module understanding. Runtime elements are instantiated from code modules; understanding the code helps understand what runs. Within C\&C views, styles progress from simple data transformation (pipe-and-filter) through interaction patterns (client-server, peer-to-peer, publish-subscribe) to complex integration (shared-data, SOA).

Allocation views come last because they map the software (described in module and C\&C views) to non-software structures. You must understand the software before you can describe where it runs, who builds it, or how it installs.

\subsection{Complete Document Sequence}

The following table presents the complete sequence of documents in this playbook, organized by part. Each document serves a specific purpose in the overall framework.

\vspace{1em}

\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabularx}{\textwidth}{|c|l|X|}
\hline
\rowcolor{lightgray}
\textbf{\#} & \textbf{Document} & \textbf{Purpose} \\
\hline
\multicolumn{3}{|l|}{\cellcolor{accentgold!20}\textbf{Part I: Foundation}} \\
\hline
1 & Stakeholder Documentation Needs & Establishes who uses documentation and what they need \\
\hline
\multicolumn{3}{|l|}{\cellcolor{modulegreen!20}\textbf{Part II: Module Views}} \\
\hline
2 & Module Views Overview & Introduces static code structure documentation \\
3 & Decomposition Style & Hierarchical breakdown of modules \\
4 & Uses Style & Functional dependencies between modules \\
5 & Generalization Style & Inheritance and specialization relationships \\
6 & Layered Style & Organization by abstraction level \\
7 & Aspects Style & Cross-cutting concerns \\
8 & Data Model Style & Information structure and relationships \\
\hline
\multicolumn{3}{|l|}{\cellcolor{cncpurple!20}\textbf{Part III: C\&C Views}} \\
\hline
9 & C\&C Views Overview & Introduces runtime structure documentation \\
10 & Pipe-and-Filter Style & Sequential data transformation \\
11 & Client-Server Style & Request-response interaction \\
12 & Peer-to-Peer Style & Symmetric component interaction \\
13 & Publish-Subscribe Style & Event-driven decoupling \\
14 & Shared-Data Style & Data-centric integration \\
15 & Service-Oriented Architecture Style & Service-based systems \\
\hline
\multicolumn{3}{|l|}{\cellcolor{allocationorange!20}\textbf{Part IV: Allocation Views}} \\
\hline
16 & Deployment Style & Mapping to hardware/infrastructure \\
17 & Install Style & File system organization \\
18 & Work Assignment Style & Team and development organization \\
\hline
\end{tabularx}
\end{center}

\subsection{Reading Paths}

Different readers may take different paths through the playbook depending on their needs and experience.

\textbf{Comprehensive Learning Path:} Read all documents in sequence. This path builds complete understanding of architecture documentation from first principles. Allow approximately 20--30 hours for thorough study.

\textbf{Quick Start Path:} Read Chapter \ref{ch:overview} (this chapter), Chapter \ref{ch:stakeholders} (stakeholder needs), and the three viewtype overview chapters. This path provides essential understanding in 3--4 hours, sufficient to begin documentation work with reference to style chapters as needed.

\textbf{Style-Specific Path:} For documenting a specific architectural style, read the relevant viewtype overview chapter and the specific style chapter. Each style chapter is self-contained with complete guidance.

\textbf{Project Planning Path:} Read Chapter \ref{ch:stakeholders} thoroughly, then use the stakeholder-view matrices to identify needed views. Read overview chapters for selected viewtypes and relevant style chapters.

\section{Relationships Among Documents}

The documents in this playbook form an interconnected whole. Understanding these relationships helps readers navigate effectively and ensures consistent documentation.

\subsection{Hierarchical Relationships}

The playbook has a clear hierarchical structure. At the top level, stakeholder analysis guides all documentation decisions. At the second level, the three viewtype overviews define the major categories. At the third level, specific styles provide detailed patterns within each viewtype.

\begin{center}
\begin{tikzpicture}[
  level 1/.style={sibling distance=5cm, level distance=2cm},
  level 2/.style={sibling distance=2cm, level distance=2cm},
  every node/.style={draw, rounded corners, align=center, font=\small}
]
  \node[fill=accentgold!20] {Stakeholder\\Needs}
    child {node[fill=modulegreen!20] {Module\\Views}
      child {node[fill=modulegreen!10, font=\scriptsize] {6 Styles}}
    }
    child {node[fill=cncpurple!20] {C\&C\\Views}
      child {node[fill=cncpurple!10, font=\scriptsize] {6 Styles}}
    }
    child {node[fill=allocationorange!20] {Allocation\\Views}
      child {node[fill=allocationorange!10, font=\scriptsize] {3 Styles}}
    };
\end{tikzpicture}
\end{center}

\subsection{Cross-Cutting Relationships}

Several themes cut across the hierarchical structure.

\textbf{Element Mapping:} Elements in one viewtype often correspond to elements in another. A module in the decomposition view may instantiate a component in a C\&C view, which deploys to a node in the deployment view. Understanding these mappings ensures documentation consistency.

\textbf{Quality Attributes:} Different views support analysis of different quality attributes. Module views support modifiability analysis; C\&C views support performance and availability analysis; allocation views support deployment and scalability analysis. Quality attribute concerns often require multiple views.

\textbf{Stakeholder Overlap:} Stakeholders often need multiple views. A developer may need decomposition, uses, and deployment views. Documentation should support stakeholders who navigate across views.

\textbf{Common Notation:} While each viewtype has characteristic notation, common principles apply: elements are represented graphically, relationships connect elements, properties annotate elements and relationships. Consistent notation conventions aid comprehension.

\subsection{Dependency Relationships}

Some documents depend on concepts introduced in others.

All style chapters depend on their viewtype overview chapter. Read the overview before studying specific styles.

Several styles share concepts. The layered style extends decomposition concepts. Aspects style relates to multiple other styles. SOA style incorporates client-server and publish-subscribe concepts. These relationships are noted in relevant chapters.

Allocation styles depend on understanding the software being allocated. Familiarity with module and C\&C concepts strengthens understanding of allocation views.

\section{Key Concepts and Terminology}

This section establishes terminology used throughout the playbook. Consistent terminology supports clear communication.

\subsection{Architectural Elements}

\textbf{Module:} A code unit that implements a coherent set of responsibilities. Modules exist at development time as packages, classes, namespaces, files, or libraries.

\textbf{Component:} A runtime unit of computation or data storage. Components exist at execution time as processes, threads, objects, services, or other executing entities.

\textbf{Connector:} A runtime pathway of interaction between components. Connectors enable components to communicate through mechanisms like procedure calls, messages, events, or shared data access.

\textbf{Environmental Element:} A non-software structure to which software maps. Environmental elements include hardware nodes, file system locations, development teams, and organizational units.

\subsection{Architectural Relationships}

\textbf{Is-Part-Of:} Hierarchical containment, where one element contains others. Used in decomposition and other hierarchical views.

\textbf{Depends-On:} General dependency, where one element requires another. Refined into specific dependency types in different styles.

\textbf{Uses:} Functional dependency, where one element requires another to function correctly. More specific than general dependency.

\textbf{Is-A:} Generalization/specialization, where one element is a specialized version of another. Used in generalization and object-oriented contexts.

\textbf{Communicates-With:} Runtime interaction between components through connectors.

\textbf{Allocated-To:} Mapping from software element to environmental element.

\subsection{Documentation Concepts}

\textbf{View:} A representation of a set of architectural elements and their relationships. Views conform to viewtypes and styles.

\textbf{Viewtype:} A category of views defined by the types of elements and relationships that can appear. The three viewtypes are Module, Component-and-Connector, and Allocation.

\textbf{Style:} A specialization of a viewtype that constrains elements and relationships to a specific pattern. Styles provide reusable architectural patterns.

\textbf{Stakeholder:} Anyone with an interest in the system or its documentation. Stakeholders have concerns that documentation should address.

\textbf{Concern:} A stakeholder interest or need that documentation should address. Concerns motivate view selection.


\chapter{Stakeholders and Their Documentation Needs}
\label{ch:stakeholders}

\playbookpart{accentgold}{Foundation Document}{Understanding who uses documentation and what they need}

\section{Document Purpose and Role}

The Stakeholder Documentation Needs document establishes the foundation for all architecture documentation decisions. It answers the fundamental question: who will use the documentation and what do they need from it?

This document is the essential starting point for documentation planning. Before selecting views, choosing notation, or determining detail levels, architects must understand their audience. Documentation that ignores stakeholder needs wastes resources and fails to provide value.

\subsection{Position in the Playbook}

This document comes first in the playbook sequence because all other documents depend on stakeholder understanding. View selection, style choice, detail level, and documentation format all flow from stakeholder analysis.

The stakeholder analysis informs:

\begin{itemize}
\item Which viewtypes to document (Module, C\&C, Allocation)
\item Which styles within each viewtype to use
\item What level of detail to provide in each view
\item What supporting documentation to create
\item When to produce each documentation element
\item What format and notation to use
\end{itemize}

\subsection{Key Concepts Introduced}

The document introduces several concepts that recur throughout the playbook.

\textbf{Stakeholder Categories:} The document identifies twelve stakeholder categories that commonly appear in software projects: project managers, development team members, testers and integrators, designers of other systems, maintainers, product-line application builders, customers, end users, analysts, infrastructure support personnel, new stakeholders, and current/future architects.

\textbf{Documentation Needs Matrix:} The document provides a matrix mapping stakeholder categories to documentation elements. This matrix guides view selection by showing which stakeholders need which views and at what level of detail.

\textbf{Concern-Driven Documentation:} The document establishes that stakeholders have concerns---interests, needs, or questions---that documentation should address. Views are selected and designed to address identified concerns.

\section{Document Contents Summary}

The Stakeholder Documentation Needs document covers the following topics.

\subsection{Understanding Stakeholders}

The document explains what stakeholders are and how to identify them. It distinguishes direct stakeholders (who use documentation themselves) from indirect stakeholders (who are affected by decisions made using documentation). It distinguishes internal stakeholders (within the development organization) from external stakeholders (customers, partners, regulators). It addresses current stakeholders and future stakeholders whose needs should be anticipated.

\subsection{Stakeholder Concerns}

The document characterizes the types of concerns stakeholders have. Functional concerns relate to what the system does. Quality concerns relate to how well it performs. Development concerns relate to building it. Operational concerns relate to running it. Business concerns relate to organizational impact. Understanding these concern categories helps architects ensure documentation addresses all relevant interests.

\subsection{Stakeholder Categories}

The document provides detailed profiles of common stakeholder categories. For each category, it describes typical concerns, documentation needs, appropriate detail levels, and preferred formats. These profiles provide a starting point for project-specific stakeholder analysis.

\subsection{Stakeholder-View Mapping}

The document provides matrices showing which views typically serve which stakeholders. These matrices indicate whether stakeholders need detailed information, some information, overview information, or no information from each view. The matrices cover all views in this playbook.

\subsection{Documentation Planning Process}

The document describes a systematic process for documentation planning: identify stakeholders, characterize their needs, map needs to views, determine appropriate detail, plan documentation production, and validate with stakeholders.

\section{Connections to Other Documents}

The Stakeholder Documentation Needs document connects to all other documents in the playbook.

\subsection{Connections to Viewtype Overviews}

The stakeholder analysis determines which viewtypes to document. If stakeholders need to understand code organization, Module views are indicated. If they need to understand runtime behavior, C\&C views are indicated. If they need to understand deployment or team organization, Allocation views are indicated.

The viewtype overview documents (Chapters \ref{ch:module-overview}, \ref{ch:cnc-overview}, \ref{ch:allocation-overview}) reference stakeholder needs when discussing when to use each viewtype.

\subsection{Connections to Style Documents}

Within each viewtype, stakeholder needs guide style selection. The stakeholder analysis may indicate that a layered view is needed (to show abstraction levels for maintainers) or that a deployment view is needed (to show runtime topology for operators).

Each style document references stakeholder needs when discussing when to use that style.

\subsection{Connections to Documentation Beyond Views}

Stakeholder analysis also determines what supporting documentation is needed. Some stakeholders need context diagrams; others need rationale documentation; others need variability guides. The stakeholder analysis guides these decisions.


%##############################################################################
% PART II: MODULE VIEWS
%##############################################################################
\part{Module Views: Static Code Structure}
\label{part:modules}

\chapter{Module Views Overview}
\label{ch:module-overview}

\playbookpart{modulegreen}{Module Viewtype}{Documenting the static structure of code}

\section{Document Purpose and Role}

The Module Views document provides comprehensive guidance on documenting the static structure of software systems. It introduces the module viewtype, explains when and why to create module views, and establishes foundations for the six module styles that follow.

\subsection{Position in the Playbook}

Module views come first among the three viewtypes because they represent the most fundamental architectural perspective. Every software system has code, and that code has structure. Understanding code structure is prerequisite to understanding what executes at runtime (C\&C views) or where software maps to environmental structures (allocation views).

The Module Views overview document comes before the individual style documents because it establishes concepts that all styles share. Readers should understand the module viewtype before studying specific styles.

\subsection{What Module Views Show}

Module views show the static structure of software in terms of implementation units. They answer questions such as:

\begin{itemize}
\item What are the major code units in the system?
\item How is the code organized hierarchically?
\item What dependencies exist between code units?
\item How do code units specialize or extend each other?
\item What layers of abstraction exist?
\item What cross-cutting concerns affect multiple units?
\item What data structures and their relationships exist?
\end{itemize}

Module views support development activities including work planning, impact analysis, build management, code review, and technical debt management.

\section{The Six Module Styles}

The module viewtype includes six architectural styles, each providing a specific pattern for organizing and documenting code structure.

\subsection{Decomposition Style (Chapter \ref{ch:decomposition})}

The Decomposition style shows hierarchical breakdown of the system into modules using the ``is-part-of'' relation. It answers the question: what are the parts and subparts of the system?

Decomposition views are fundamental---nearly every system needs at least a high-level decomposition view. They support work allocation, configuration management, and system understanding.

\subsection{Uses Style (Chapter \ref{ch:uses})}

The Uses style shows functional dependencies between modules using the ``uses'' relation. Module A uses Module B if A requires B to function correctly.

Uses views support incremental development planning, impact analysis, and understanding the minimum subset needed for specific functionality.

\subsection{Generalization Style (Chapter \ref{ch:generalization})}

The Generalization style shows inheritance and specialization relationships using the ``is-a'' relation. It documents how modules extend or specialize other modules.

Generalization views are particularly important for object-oriented systems. They support understanding polymorphic behavior, extension points, and framework design.

\subsection{Layered Style (Chapter \ref{ch:layered})}

The Layered style organizes modules into layers based on abstraction level. Higher layers use services of lower layers; lower layers are unaware of higher layers.

Layered views support understanding system organization, managing dependencies, and ensuring appropriate abstraction. They are among the most common architectural patterns.

\subsection{Aspects Style (Chapter \ref{ch:aspects})}

The Aspects style documents cross-cutting concerns that affect multiple modules. Aspects like logging, security, or transaction management cut across module boundaries.

Aspects views support understanding concerns that don't fit cleanly into hierarchical decomposition. They are particularly relevant for systems using aspect-oriented programming.

\subsection{Data Model Style (Chapter \ref{ch:datamodel})}

The Data Model style documents information structure---the data entities, their attributes, and their relationships. It bridges between architectural concerns and database design.

Data model views support understanding persistent data, data flow, and system integration through shared data structures.

\section{Connections Among Module Styles}

The six module styles are not independent---they provide complementary perspectives on code structure.

\textbf{Decomposition and Uses:} Decomposition shows containment; uses shows dependency. The same modules may appear in both views, but the relationships differ. Decomposition shows what contains what; uses shows what depends on what.

\textbf{Decomposition and Layered:} Layered views are often a constrained form of decomposition where layers are the top-level modules and layer membership determines valid dependencies.

\textbf{Generalization and Decomposition:} Inheritance hierarchies (generalization) exist within the decomposition structure. A module's classes may participate in inheritance relationships.

\textbf{Aspects and All Styles:} Aspects cut across the structures shown in other styles. Aspect views show concerns that affect multiple modules regardless of their decomposition, layer, or inheritance relationships.

\textbf{Data Model and Decomposition:} Data entities often correspond to modules that manage them. The data model may mirror or inform the module decomposition.


\chapter{Decomposition Style}
\label{ch:decomposition}

\documentref{modulegreen}{Module Style: Hierarchical system breakdown using ``is-part-of'' relation}

\section{Purpose}

The Decomposition style shows how a system is hierarchically broken down into modules. It uses the ``is-part-of'' relation to show containment: modules contain submodules, which contain sub-submodules, forming a tree structure.

Decomposition views are among the most fundamental architectural views. They establish the vocabulary of the system---the named modules that stakeholders discuss. They support work allocation by identifying units that can be assigned to teams. They support configuration management by identifying units that can be versioned and released.

\section{When to Use}

Use the Decomposition style when stakeholders need to understand the overall organization of the system, when planning work assignments and team structure, when establishing configuration management units, when introducing the system to new team members, or when managing technical debt and system evolution.

\section{Key Concepts}

The primary element is the module. The primary relation is ``is-part-of.'' Modules at any level may have interfaces, responsibilities, and visibility constraints. The decomposition forms a strict tree---each module has exactly one parent (except the root).


\chapter{Uses Style}
\label{ch:uses}

\documentref{modulegreen}{Module Style: Functional dependencies using ``uses'' relation}

\section{Purpose}

The Uses style shows which modules depend on which other modules to function correctly. Module A uses Module B if A requires the correct functioning of B to satisfy A's requirements.

Uses views support planning incremental development---identifying what must be built before what. They support impact analysis---understanding what might be affected by changes. They support subset identification---determining what modules are needed for specific functionality.

\section{When to Use}

Use the Uses style when planning incremental development or releases, when analyzing impact of proposed changes, when identifying minimum viable subsets, when debugging or troubleshooting to trace dependencies, or when optimizing build processes.

\section{Key Concepts}

The primary element is the module. The primary relation is ``uses.'' Unlike general ``depends-on,'' the uses relation specifically means functional dependency for correct operation. Uses relations may form a graph with cycles, though cycles indicate tight coupling that may warrant attention.


\chapter{Generalization Style}
\label{ch:generalization}

\documentref{modulegreen}{Module Style: Inheritance and specialization using ``is-a'' relation}

\section{Purpose}

The Generalization style shows inheritance and specialization relationships between modules. Module A is a generalization of Module B if B inherits from or specializes A.

Generalization views are essential for understanding object-oriented designs. They show class hierarchies, interface implementations, and extension points. They support understanding polymorphic behavior and framework customization.

\section{When to Use}

Use the Generalization style when documenting object-oriented systems with significant inheritance, when designing or documenting frameworks with extension points, when analyzing polymorphic behavior, when planning for variation and customization, or when refactoring to improve inheritance hierarchies.

\section{Key Concepts}

The primary element is the module (often class or interface). The primary relation is ``is-a'' or ``inherits-from.'' Generalization views may show abstract versus concrete modules, interface versus implementation, and multiple inheritance where supported.


\chapter{Layered Style}
\label{ch:layered}

\documentref{modulegreen}{Module Style: Organization by abstraction level}

\section{Purpose}

The Layered style organizes modules into layers based on abstraction level. Each layer provides services to layers above and uses services of layers below. Layers create a managed dependency structure where lower layers are independent of higher layers.

Layered views show system organization at a high level. They communicate the overall structure quickly and establish rules about what can depend on what. They support maintainability by isolating changes to appropriate layers.

\section{When to Use}

Use the Layered style when the system has clear abstraction levels, when managing dependencies is a priority, when communicating high-level structure to diverse stakeholders, when designing for portability (platform layers), or when separating concerns (presentation, business logic, data access).

\section{Key Concepts}

The primary element is the layer. Layers are special modules that span the system horizontally. The primary relation is ``allowed-to-use'' which constrains dependencies to flow downward. Variants include strict layering (only adjacent layers) and relaxed layering (any lower layer).


\chapter{Aspects Style}
\label{ch:aspects}

\documentref{modulegreen}{Module Style: Cross-cutting concerns}

\section{Purpose}

The Aspects style documents concerns that cut across module boundaries. Concerns like logging, security, error handling, persistence, or transaction management affect many modules rather than being localized.

Aspects views make visible what is otherwise scattered throughout the code. They support understanding how cross-cutting concerns are implemented, whether through aspect-oriented programming or through design patterns and conventions.

\section{When to Use}

Use the Aspects style when cross-cutting concerns are architecturally significant, when using aspect-oriented programming techniques, when documenting concerns that resist modular decomposition, when analyzing the impact of changing cross-cutting concerns, or when designing reusable concern implementations.

\section{Key Concepts}

The primary element is the aspect (the cross-cutting concern). The primary relation is ``cross-cuts'' showing which modules are affected by which aspects. Aspects may be implemented through AOP mechanisms, decorators, mixins, or simply conventions.


\chapter{Data Model Style}
\label{ch:datamodel}

\documentref{modulegreen}{Module Style: Information structure and relationships}

\section{Purpose}

The Data Model style documents the structure of data entities, their attributes, and their relationships. It bridges between architectural concerns and database or schema design.

Data model views support understanding what information the system manages, how entities relate to each other, and how data flows through the system. They are essential for data-intensive systems and for system integration through shared data.

\section{When to Use}

Use the Data Model style when data structure is architecturally significant, when designing or documenting databases, when analyzing data-related quality attributes, when planning data migration or integration, or when designing APIs that expose data.

\section{Key Concepts}

The primary elements are data entities with attributes. The primary relations are associations between entities (one-to-one, one-to-many, many-to-many). Data models may show constraints, keys, and integrity rules.


%##############################################################################
% PART III: COMPONENT-AND-CONNECTOR VIEWS
%##############################################################################
\part{Component-and-Connector Views: Runtime Behavior}
\label{part:cnc}

\chapter{Component-and-Connector Views Overview}
\label{ch:cnc-overview}

\playbookpart{cncpurple}{C\&C Viewtype}{Documenting runtime structure and behavior}

\section{Document Purpose and Role}

The Component-and-Connector Views document provides comprehensive guidance on documenting the runtime structure of software systems. It introduces the C\&C viewtype, explains when and why to create C\&C views, and establishes foundations for the six C\&C styles that follow.

\subsection{Position in the Playbook}

C\&C views come after module views because they describe what exists at runtime---the executing manifestation of the code described in module views. Understanding code structure helps understand what that code becomes when it runs.

The C\&C Views overview document comes before the individual style documents because it establishes concepts that all styles share.

\subsection{What C\&C Views Show}

C\&C views show the runtime structure of software in terms of components and connectors. They answer questions such as:

\begin{itemize}
\item What are the principal executing elements?
\item How do they interact at runtime?
\item What data flows between them?
\item How does the system respond to events?
\item What happens when components fail?
\item How does runtime structure change dynamically?
\end{itemize}

C\&C views support runtime analysis including performance engineering, availability analysis, security assessment, and behavioral understanding.

\section{The Six C\&C Styles}

The C\&C viewtype includes six architectural styles, each providing a specific pattern for organizing runtime structure.

\subsection{Pipe-and-Filter Style (Chapter \ref{ch:pipefilter})}

The Pipe-and-Filter style shows data transformation through sequences of filters connected by pipes. Data flows from input through successive transformations to output.

Pipe-and-filter views support understanding data processing pipelines, batch processing systems, and stream processing.

\subsection{Client-Server Style (Chapter \ref{ch:clientserver})}

The Client-Server style shows asymmetric request-response interactions. Clients request services; servers provide them. This fundamental pattern underlies much of networked computing.

Client-server views support understanding distributed systems, network protocols, and service-based architectures.

\subsection{Peer-to-Peer Style (Chapter \ref{ch:p2p})}

The Peer-to-Peer style shows symmetric interactions where components act as both clients and servers. Peers are equivalent participants that can both request and provide services.

Peer-to-peer views support understanding decentralized systems, collaborative applications, and distributed algorithms.

\subsection{Publish-Subscribe Style (Chapter \ref{ch:pubsub})}

The Publish-Subscribe style shows event-driven interaction where publishers emit events and subscribers receive them through an intermediary. Publishers and subscribers are decoupled.

Publish-subscribe views support understanding event-driven systems, message-oriented middleware, and reactive architectures.

\subsection{Shared-Data Style (Chapter \ref{ch:shareddata})}

The Shared-Data style shows components that interact through shared data stores. Data accessors read and write shared data; the data store mediates interaction.

Shared-data views support understanding data-centric systems, blackboard architectures, and database-centered integration.

\subsection{Service-Oriented Architecture Style (Chapter \ref{ch:soa})}

The Service-Oriented Architecture style shows systems composed of services that interact through well-defined interfaces. Services are discoverable, composable, and often distributed.

SOA views support understanding enterprise integration, microservices, and web services architectures.

\section{Connections Among C\&C Styles}

The six C\&C styles often appear in combination within a single system.

\textbf{Client-Server and SOA:} SOA typically uses client-server interactions. Services are servers; service consumers are clients.

\textbf{Publish-Subscribe and SOA:} Event-driven SOA combines publish-subscribe for asynchronous communication with service-based structure.

\textbf{Shared-Data and Client-Server:} Database-backed services combine shared-data (the database) with client-server (service access).

\textbf{Pipe-and-Filter and Publish-Subscribe:} Stream processing may combine pipes for data flow with events for control.


\chapter{Pipe-and-Filter Style}
\label{ch:pipefilter}

\documentref{cncpurple}{C\&C Style: Sequential data transformation}

\section{Purpose}

The Pipe-and-Filter style shows data flowing through a sequence of transformations. Filters transform data; pipes carry data between filters. The style emphasizes data transformation and enables concurrent processing.

Pipe-and-filter views support understanding batch processing, compilers, signal processing, ETL pipelines, and Unix-style command composition.

\section{When to Use}

Use the Pipe-and-Filter style when the system performs sequential data transformation, when processing can be decomposed into independent steps, when filters can be reused or recombined, when concurrent processing of pipeline stages is valuable, or when data processing is the dominant architectural concern.

\section{Key Concepts}

Components are filters that transform input to output. Connectors are pipes that carry data streams. Filters should be independent---unaware of adjacent filters. Pipes carry typed data streams.


\chapter{Client-Server Style}
\label{ch:clientserver}

\documentref{cncpurple}{C\&C Style: Request-response interaction}

\section{Purpose}

The Client-Server style shows asymmetric interaction where clients request services and servers provide them. This fundamental pattern structures much of networked computing.

Client-server views support understanding web applications, database access, remote procedure calls, and tiered architectures.

\section{When to Use}

Use the Client-Server style when the system has asymmetric roles (requesters and providers), when services are centralized, when multiple clients share servers, when understanding request-response patterns is important, or when analyzing server load and scaling.

\section{Key Concepts}

Client components initiate requests. Server components receive requests and return responses. The connector is request-response, which may be synchronous or asynchronous. Servers may be clients of other servers, creating tiers.


\chapter{Peer-to-Peer Style}
\label{ch:p2p}

\documentref{cncpurple}{C\&C Style: Symmetric component interaction}

\section{Purpose}

The Peer-to-Peer style shows symmetric interaction where components are equivalent participants. Each peer can initiate and respond to interaction. There is no distinguished client or server role.

Peer-to-peer views support understanding file sharing networks, collaborative applications, distributed algorithms, and blockchain systems.

\section{When to Use}

Use the Peer-to-Peer style when components have symmetric roles, when the system is decentralized, when resilience through redundancy is important, when direct communication between participants is desired, or when avoiding central points of failure matters.

\section{Key Concepts}

Peer components have equivalent capabilities. Connectors enable bidirectional communication. Peers may discover each other dynamically. The topology may be structured (e.g., DHT) or unstructured.


\chapter{Publish-Subscribe Style}
\label{ch:pubsub}

\documentref{cncpurple}{C\&C Style: Event-driven decoupling}

\section{Purpose}

The Publish-Subscribe style shows event-driven interaction where publishers emit events without knowing who receives them, and subscribers receive events without knowing who sends them. An event bus or broker mediates.

Publish-subscribe views support understanding event-driven systems, message-oriented middleware, GUIs, and reactive systems.

\section{When to Use}

Use the Publish-Subscribe style when components should be decoupled, when event-driven interaction is primary, when many-to-many communication patterns exist, when components should be unaware of each other, or when the system must support dynamic subscription.

\section{Key Concepts}

Publishers emit events. Subscribers declare interest in event types. An event bus or broker routes events from publishers to subscribers. Coupling is minimized---publishers and subscribers don't reference each other directly.


\chapter{Shared-Data Style}
\label{ch:shareddata}

\documentref{cncpurple}{C\&C Style: Data-centric integration}

\section{Purpose}

The Shared-Data style shows components interacting through shared data stores. Data accessors read and write shared data; the data store provides persistence, consistency, and mediated access.

Shared-data views support understanding database-centric systems, blackboard architectures, data lakes, and integration through shared databases.

\section{When to Use}

Use the Shared-Data style when data is the primary integration mechanism, when multiple components need access to common data, when data persistence is architecturally significant, when analyzing data consistency and integrity, or when the system is ``database-centric.''

\section{Key Concepts}

Data accessor components read and write shared data. Data store components provide persistent, shared data with access control. Connectors are data access protocols. The data store decouples accessors---they interact through data rather than directly.


\chapter{Service-Oriented Architecture Style}
\label{ch:soa}

\documentref{cncpurple}{C\&C Style: Service-based systems}

\section{Purpose}

The Service-Oriented Architecture style shows systems composed of discrete services with well-defined interfaces. Services are discoverable, potentially distributed, and can be composed to provide higher-level functionality.

SOA views support understanding enterprise systems, web services, microservices, and API-based integration.

\section{When to Use}

Use the SOA style when the system is composed of discrete services, when services may be distributed across network boundaries, when service composition is important, when service discovery and registration are used, or when understanding service contracts matters.

\section{Key Concepts}

Service components provide well-defined functionality through interfaces. Service consumers invoke services. Connectors include service invocation and service bus. Supporting infrastructure includes registries and orchestration.


%##############################################################################
% PART IV: ALLOCATION VIEWS
%##############################################################################
\part{Allocation Views: Mapping to Environment}
\label{part:allocation}

\chapter{Allocation Views Overview}
\label{ch:allocation-overview}

\playbookpart{allocationorange}{Allocation Viewtype}{Documenting how software maps to non-software structures}

\section{Document Purpose and Role}

Allocation views document how software elements map to non-software structures in the environment. They bridge between the software architecture (documented in module and C\&C views) and the world in which that software exists---hardware, file systems, teams, and organizations.

\subsection{Position in the Playbook}

Allocation views come last because they describe mappings \textit{from} software \textit{to} environment. Understanding the software (through module and C\&C views) is prerequisite to understanding how it maps to environmental structures.

\subsection{What Allocation Views Show}

Allocation views show relationships between software and environment:

\begin{itemize}
\item Where runtime components execute (Deployment)
\item Where code artifacts are located in file systems (Install)
\item Who is responsible for developing which modules (Work Assignment)
\end{itemize}

Allocation views support operations, build/release, and project management activities.

\section{The Three Allocation Styles}

\subsection{Deployment Style (Chapter \ref{ch:deployment})}

Shows how runtime components map to hardware and infrastructure.

\subsection{Install Style (Chapter \ref{ch:install})}

Shows how code artifacts map to file system locations.

\subsection{Work Assignment Style (Chapter \ref{ch:workassignment})}

Shows how modules map to development teams and organizations.


\chapter{Deployment Style}
\label{ch:deployment}

\documentref{allocationorange}{Allocation Style: Mapping to hardware and infrastructure}

\section{Purpose}

The Deployment style shows how runtime components (from C\&C views) map to hardware nodes and infrastructure. It documents where software runs.

Deployment views support operations, capacity planning, availability analysis, network design, and security analysis.

\section{When to Use}

Use the Deployment style when stakeholders need to understand where software runs, when planning hardware and infrastructure, when analyzing performance, availability, or security, when designing network topology, or when planning disaster recovery.

\section{Key Concepts}

Software elements are components from C\&C views. Environmental elements are nodes (servers, containers, VMs, devices). The allocation relation is ``deployed-on.'' Properties include resource requirements and communication paths.


\chapter{Install Style}
\label{ch:install}

\documentref{allocationorange}{Allocation Style: File system organization}

\section{Purpose}

The Install style shows how code artifacts map to file system locations. It documents where build outputs, configuration files, and runtime resources are located.

Install views support build processes, installation procedures, configuration management, and troubleshooting.

\section{When to Use}

Use the Install style when stakeholders need to understand file organization, when designing build and deployment processes, when documenting installation procedures, when managing configuration across environments, or when troubleshooting file-related issues.

\section{Key Concepts}

Software elements are build artifacts, configuration files, and resources. Environmental elements are directories and file system paths. The allocation relation is ``located-in.'' Properties include permissions, ownership, and environment-specific variations.


\chapter{Work Assignment Style}
\label{ch:workassignment}

\documentref{allocationorange}{Allocation Style: Team and development organization}

\section{Purpose}

The Work Assignment style shows how modules (from module views) map to development teams and organizational units. It documents who is responsible for what.

Work assignment views support project planning, team organization, coordination, and accountability.

\section{When to Use}

Use the Work Assignment style when multiple teams work on the system, when planning work distribution, when analyzing communication needs between teams, when aligning architecture with organization, or when managing dependencies across team boundaries.

\section{Key Concepts}

Software elements are modules from module views. Environmental elements are teams, individuals, or organizational units. The allocation relation is ``assigned-to.'' Properties include expertise, location, and capacity.


%##############################################################################
% APPENDICES
%##############################################################################
\appendix

\chapter{Quick Reference: Style Selection Guide}
\label{app:styleselection}

This appendix provides quick guidance for selecting appropriate architectural styles based on stakeholder needs and system characteristics.

\section{Style Selection by Question}

\begin{longtable}{|p{6cm}|p{4cm}|p{4cm}|}
\hline
\rowcolor{lightgray}
\textbf{Question to Answer} & \textbf{Style} & \textbf{Viewtype} \\
\hline
\endfirsthead
\hline
\rowcolor{lightgray}
\textbf{Question to Answer} & \textbf{Style} & \textbf{Viewtype} \\
\hline
\endhead

What are the major parts of the system? & Decomposition & Module \\
\hline
What depends on what in the code? & Uses & Module \\
\hline
What inherits from what? & Generalization & Module \\
\hline
What are the abstraction layers? & Layered & Module \\
\hline
What concerns cut across modules? & Aspects & Module \\
\hline
What data entities exist? & Data Model & Module \\
\hline
How does data flow through the system? & Pipe-and-Filter & C\&C \\
\hline
Who requests what from whom? & Client-Server & C\&C \\
\hline
How do equivalent components interact? & Peer-to-Peer & C\&C \\
\hline
What events trigger what responses? & Publish-Subscribe & C\&C \\
\hline
How do components share data? & Shared-Data & C\&C \\
\hline
What services exist and how do they interact? & SOA & C\&C \\
\hline
Where does software run? & Deployment & Allocation \\
\hline
Where are files located? & Install & Allocation \\
\hline
Who develops what? & Work Assignment & Allocation \\
\hline
\end{longtable}


\chapter{Quick Reference: Stakeholder-View Matrix}
\label{app:stakeholdermatrix}

This appendix summarizes which stakeholders typically need which views. Use this as a starting point for documentation planning; customize based on project-specific stakeholders.

\section{Legend}

\begin{description}
\item[d] Detailed information needed
\item[s] Some information needed
\item[o] Overview only
\item[(blank)] Typically not needed
\end{description}

\section{Matrix Summary}

\textbf{Project Managers} typically need overview decomposition, detailed work assignment, and some C\&C views for understanding system behavior.

\textbf{Developers} typically need detailed module views (decomposition, uses, layered) and detailed C\&C views for the styles relevant to their work.

\textbf{Testers} typically need detailed uses views (for integration testing), detailed C\&C views (for behavior testing), and deployment views.

\textbf{Maintainers} typically need detailed views of all types to understand the system comprehensively.

\textbf{Operators} typically need detailed deployment views, install views, and C\&C views showing runtime behavior.

\textbf{Architects} typically need detailed views of all types, plus rationale and constraints documentation.

\textbf{New Team Members} typically need overview-level views of all types for orientation, progressing to detail as they specialize.


\chapter{Glossary}
\label{app:glossary}

\begin{description}[style=nextline]

\item[Allocation View]
A view that shows how software elements map to non-software environmental elements such as hardware, file systems, or teams.

\item[Aspect]
A cross-cutting concern that affects multiple modules and does not fit cleanly into hierarchical decomposition.

\item[Component]
A runtime unit of computation or data storage in a C\&C view.

\item[Concern]
A stakeholder interest, need, or question that documentation should address.

\item[Connector]
A runtime pathway of interaction between components in a C\&C view.

\item[Decomposition]
The hierarchical breakdown of a system into modules using the is-part-of relation.

\item[Generalization]
The inheritance or specialization relationship between modules, shown with the is-a relation.

\item[Layer]
A horizontal slice of a system that provides services to layers above and uses services of layers below.

\item[Module]
A code unit that implements a coherent set of responsibilities; the primary element type in module views.

\item[Module View]
A view that shows the static structure of code in terms of modules and their relationships.

\item[Pipe]
A connector in pipe-and-filter architecture that carries data between filters.

\item[Filter]
A component in pipe-and-filter architecture that transforms input data to output data.

\item[Stakeholder]
Anyone with an interest in or concern about the system and its documentation.

\item[Style]
A specialization of a viewtype that constrains elements and relationships to a specific pattern.

\item[Uses Relation]
A functional dependency where one module requires another to function correctly.

\item[View]
A representation of a set of architectural elements and their relationships.

\item[Viewtype]
A category of views defined by the types of elements and relationships that can appear.

\end{description}


%##############################################################################
% BACK MATTER
%##############################################################################

\chapter*{References}
\addcontentsline{toc}{chapter}{References}

\begin{description}[style=nextline, leftmargin=0pt]

\item[Clements, P., Bachmann, F., Bass, L., Garlan, D., Ivers, J., Little, R., Merson, P., Nord, R., \& Stafford, J. (2010).]
\textit{Documenting Software Architectures: Views and Beyond} (2nd ed.). Addison-Wesley Professional.

\item[Bass, L., Clements, P., \& Kazman, R. (2021).]
\textit{Software Architecture in Practice} (4th ed.). Addison-Wesley Professional.

\item[ISO/IEC/IEEE. (2011).]
\textit{ISO/IEC/IEEE 42010:2011 Systems and software engineering---Architecture description}.

\item[Rozanski, N., \& Woods, E. (2011).]
\textit{Software Systems Architecture: Working With Stakeholders Using Viewpoints and Perspectives} (2nd ed.). Addison-Wesley Professional.

\item[Clements, P., \& Northrop, L. (2001).]
\textit{Software Product Lines: Practices and Patterns}. Addison-Wesley Professional.

\item[Kruchten, P. (1995).]
The 4+1 View Model of architecture. \textit{IEEE Software}, 12(6), 42--50.

\item[Garlan, D., \& Shaw, M. (1994).]
An introduction to software architecture. In V. Ambriola \& G. Tortora (Eds.), \textit{Advances in Software Engineering and Knowledge Engineering} (Vol. 1). World Scientific.

\item[Parnas, D. L. (1972).]
On the criteria to be used in decomposing systems into modules. \textit{Communications of the ACM}, 15(12), 1053--1058.

\end{description}

\end{document}
