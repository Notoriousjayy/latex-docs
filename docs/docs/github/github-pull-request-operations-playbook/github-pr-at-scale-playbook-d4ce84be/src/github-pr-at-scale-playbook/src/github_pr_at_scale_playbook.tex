\documentclass[11pt,letterpaper]{article}

% ============================================================================
% PACKAGES
% ============================================================================
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{tocloft}
\usepackage{parskip}

% ============================================================================
% HYPERREF CONFIGURATION
% ============================================================================
\hypersetup{
    colorlinks=true,
    linkcolor=blue!60!black,
    urlcolor=blue!60!black,
    citecolor=blue!60!black,
    pdftitle={GitHub Pull Request Operations Playbook},
    pdfauthor={Engineering Operations},
    pdfsubject={Software Engineering Process},
    pdfkeywords={GitHub, Pull Requests, Code Review, DevOps, CI/CD}
}

% ============================================================================
% CODE LISTINGS CONFIGURATION
% ============================================================================
\definecolor{codebg}{rgb}{0.95,0.95,0.95}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

\lstdefinestyle{yaml}{
    backgroundcolor=\color{codebg},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single,
    language=bash
}

\lstdefinestyle{markdown}{
    backgroundcolor=\color{codebg},
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    tabsize=2
}

% ============================================================================
% PAGE HEADERS AND FOOTERS
% ============================================================================
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{GitHub PR Operations Playbook}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% ============================================================================
% SECTION FORMATTING
% ============================================================================
\titleformat{\section}
  {\normalfont\Large\bfseries\color{blue!70!black}}
  {\thesection}{1em}{}

\titleformat{\subsection}
  {\normalfont\large\bfseries\color{blue!60!black}}
  {\thesubsection}{1em}{}

% ============================================================================
% CUSTOM COMMANDS
% ============================================================================
\newcommand{\keypoint}[1]{\textbf{\color{blue!70!black}#1}}
\newcommand{\warning}[1]{\textbf{\color{red!70!black}⚠ #1}}
\newcommand{\best}[1]{\textbf{\color{green!60!black}✓ #1}}

% ============================================================================
% DOCUMENT METADATA
% ============================================================================
\title{
    \Huge\textbf{GitHub Pull Request Operations Playbook}\\
    \Large Scaling Code Review for High-Velocity Engineering Teams
}
\author{Engineering Operations Guide}
\date{Version 1.0 --- \today}

% ============================================================================
% BEGIN DOCUMENT
% ============================================================================
\begin{document}

\maketitle

\begin{abstract}
This operational playbook provides a comprehensive framework for managing pull requests (PRs) at scale in GitHub-based development workflows. As engineering teams grow and codebases expand, the pull request review process often becomes a critical bottleneck that impedes velocity and developer satisfaction. This guide synthesizes industry best practices, automation strategies, and organizational patterns to establish a sustainable, high-throughput code review operation.

The playbook addresses three fundamental pillars: \textbf{(1)} process standardization to ensure consistency and efficiency, \textbf{(2)} intelligent automation to shift cognitive load from humans to machines, and \textbf{(3)} cultural practices that foster psychological safety and continuous improvement. Organizations implementing these strategies typically observe 40--60\% reduction in time-to-merge, improved code quality metrics, and enhanced developer experience.

This document is designed for engineering leaders, platform teams, and development managers responsible for establishing or optimizing code review operations at scale.
\end{abstract}

\tableofcontents
\clearpage

% ============================================================================
% SECTION 1: EXECUTIVE SUMMARY
% ============================================================================
\section{Executive Summary}

\subsection{The Challenge: Pull Requests at Scale}

Modern software engineering organizations face a fundamental scaling challenge: as teams grow and release velocity increases, the traditional pull request workflow becomes a bottleneck. Left unmanaged, this manifests as:

\begin{itemize}[leftmargin=*]
    \item \textbf{Extended review latency}: PRs sitting for days waiting for review, blocking dependent work
    \item \textbf{Context-switching overhead}: Reviewers juggling dozens of large, complex PRs
    \item \textbf{Merge conflicts}: Large, long-lived PRs colliding with concurrent work
    \item \textbf{Quality degradation}: Rushed reviews or reviewer fatigue leading to bugs escaping to production
    \item \textbf{Developer frustration}: Motivation erosion when contributions languish unreviewed
\end{itemize}

\subsection{The Solution Framework}

This playbook prescribes a three-pillar operating model:

\begin{enumerate}[leftmargin=*]
    \item \keypoint{Process Standardization} --- Establish clear, repeatable patterns for PR structure, workflow, and communication
    \item \keypoint{Intelligent Automation} --- Leverage CI/CD, bots, and tooling to handle mechanical validation and routing
    \item \keypoint{Cultural Foundation} --- Build organizational norms that prioritize rapid iteration and psychological safety
\end{enumerate}

\subsection{Expected Outcomes}

Organizations implementing this playbook typically achieve:

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Metric} & \textbf{Typical Baseline} & \textbf{Post-Implementation} \\
\midrule
Median time-to-merge & 3--5 days & 4--12 hours \\
PR size (LOC) & 500--1000+ & 100--300 \\
Review iterations & 3--5 rounds & 1--2 rounds \\
Merge conflicts/week & 10--20 & 2--5 \\
Developer satisfaction & 6/10 & 8--9/10 \\
\bottomrule
\end{tabular}
\caption{Typical performance improvements after implementing PR operations playbook}
\end{table}

\subsection{Implementation Sequencing}

For fastest return on investment, implement in this order:

\begin{enumerate}[leftmargin=*]
    \item \textbf{Quick wins (Week 1--2)}: Branch protection rules + required CI + PR templates
    \item \textbf{Review routing (Week 3--4)}: CODEOWNERS implementation + automated review requests
    \item \textbf{Automation layer (Month 2)}: Auto-merge policies + dependency update bots
    \item \textbf{Advanced workflows (Month 3+)}: Stacked PR tooling + review operations dashboards
\end{enumerate}

% ============================================================================
% SECTION 2: FOUNDATIONAL PRINCIPLES
% ============================================================================
\section{Foundational Principles}

\subsection{Principle 1: Small Pull Requests Are Non-Negotiable}

The single most impactful intervention for PR scalability is enforcing small, incremental changes. Research and industry practice consistently demonstrate:

\begin{itemize}[leftmargin=*]
    \item \textbf{Review speed}: PRs under 200 lines are reviewed 5x faster than PRs over 500 lines
    \item \textbf{Defect detection}: Reviewers find 2--3x more issues in smaller PRs due to reduced cognitive load
    \item \textbf{Merge conflicts}: Small PRs reduce conflict probability by 60--80\%
    \item \textbf{Rollback safety}: Small changes are easier to revert when issues arise
\end{itemize}

\keypoint{Guideline}: Target 100--300 lines of changed code per PR. Break larger features into sequential, independently reviewable units.

\subsection{Principle 2: Automation Handles Mechanics, Humans Handle Design}

Effective code review is about \emph{design validation}, not mechanical correctness. Automate all verifiable checks:

\begin{itemize}[leftmargin=*]
    \item Syntax and compilation
    \item Code style and formatting
    \item Test coverage and passage
    \item Security vulnerabilities
    \item License compliance
    \item Documentation completeness
\end{itemize}

\keypoint{Guideline}: If a review comment can be generated by a linter, static analyzer, or test, it should be automated. Human reviewers focus on architecture, maintainability, and edge case reasoning.

\subsection{Principle 3: Process Standardization Reduces Cognitive Overhead}

Consistency eliminates decision fatigue. Standard processes for PR structure, review workflow, and merge criteria create a shared mental model across the team.

\keypoint{Guideline}: Document explicit standards for PR creation, review expectations, approval criteria, and merge procedures. Encode these standards in templates and automation.

\subsection{Principle 4: Psychological Safety Enables High Velocity}

Teams that ship small PRs frequently require trust and a no-blame culture. Developers must feel safe:

\begin{itemize}[leftmargin=*]
    \item Submitting work-in-progress for early feedback
    \item Making mistakes that are caught in review
    \item Asking clarifying questions without judgment
    \item Proposing experimental or unconventional approaches
\end{itemize}

\keypoint{Guideline}: Frame code review as collaborative learning, not gatekeeping. Celebrate improvement over perfection.

% ============================================================================
% SECTION 3: PROCESS STRATEGIES
% ============================================================================
\section{Process Strategies}

\subsection{PR Structure Standards}

\subsubsection{Optimal PR Size}

\begin{table}[h]
\centering
\begin{tabular}{p{2.5cm}p{3cm}p{7cm}}
\toprule
\textbf{Size Range} & \textbf{Typical Review Time} & \textbf{Recommendation} \\
\midrule
1--50 LOC & 5--15 minutes & Ideal for bug fixes, config changes \\
50--200 LOC & 15--30 minutes & Good for feature additions \\
200--400 LOC & 30--60 minutes & Upper limit for maintainability \\
400--1000 LOC & 1--3 hours & Requires decomposition \\
1000+ LOC & 3+ hours & \warning{Must be split} \\
\bottomrule
\end{tabular}
\caption{PR size guidelines and expected review investment}
\end{table}

\subsubsection{Decomposition Strategies}

For large changes, use these patterns:

\begin{enumerate}[leftmargin=*]
    \item \textbf{Vertical slicing}: Break features into end-to-end thin slices
        \begin{itemize}
            \item PR 1: Database schema + migrations
            \item PR 2: API endpoint (minimal implementation)
            \item PR 3: Business logic
            \item PR 4: Frontend integration
        \end{itemize}
    
    \item \textbf{Horizontal layering}: Separate infrastructure from implementation
        \begin{itemize}
            \item PR 1: New module structure + interfaces
            \item PR 2: Core implementation
            \item PR 3: Integration with existing system
            \item PR 4: Tests and documentation
        \end{itemize}
    
    \item \textbf{Preparatory refactoring}: Extract groundwork into preceding PRs
        \begin{itemize}
            \item PR 1: Extract reusable utilities
            \item PR 2: Refactor existing code for extensibility
            \item PR 3: Add new feature using prepared foundation
        \end{itemize}
\end{enumerate}

\subsection{Pull Request Templates}

Implement comprehensive PR templates to standardize information capture:

\subsubsection{Required Template Elements}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Change description}
        \begin{itemize}
            \item What changed and why
            \item Link to issue/ticket/design doc
            \item Context for reviewers unfamiliar with the area
        \end{itemize}
    
    \item \textbf{Risk assessment}
        \begin{itemize}
            \item Blast radius: what could break?
            \item Performance impact
            \item Security implications
            \item Data migration risks
        \end{itemize}
    
    \item \textbf{Test plan}
        \begin{itemize}
            \item Unit test coverage
            \item Integration test scenarios
            \item Manual testing performed
            \item Edge cases considered
        \end{itemize}
    
    \item \textbf{Deployment considerations}
        \begin{itemize}
            \item Feature flags used?
            \item Rollout strategy (canary, blue-green, etc.)
            \item Rollback plan
            \item Dependencies on other systems
        \end{itemize}
    
    \item \textbf{Reviewer checklist}
        \begin{itemize}
            \item Code matches requirements
            \item Tests are comprehensive
            \item Documentation is updated
            \item No obvious security issues
            \item Performance impact is acceptable
        \end{itemize}
\end{enumerate}

See Appendix~\ref{app:pr-template} for a complete template example.

\subsection{Stacked Pull Request Workflow}

For dependent changes, use a stacking workflow to maintain small PRs while enabling sequential development.

\subsubsection{What Are Stacked PRs?}

Stacked PRs are a series of small, dependent pull requests where each PR builds on the previous one. Instead of a single 2000-line PR, you create:

\begin{itemize}[leftmargin=*]
    \item PR 1 (→ main): Add database tables (50 LOC)
    \item PR 2 (→ PR 1): Add repository layer (100 LOC)
    \item PR 3 (→ PR 2): Add service layer (150 LOC)
    \item PR 4 (→ PR 3): Add API endpoints (120 LOC)
\end{itemize}

\subsubsection{Benefits}

\begin{itemize}[leftmargin=*]
    \item \best{Parallel review}: Different reviewers can work on different layers simultaneously
    \item \best{Fail fast}: Issues caught early in the stack prevent compounding problems
    \item \best{Incremental merging}: Merge and ship value as each layer is approved
    \item \best{Context preservation}: Each PR maintains focused scope
\end{itemize}

\subsubsection{Tooling Options}

\begin{table}[h]
\centering
\small
\begin{tabular}{p{2.5cm}p{4cm}p{6cm}}
\toprule
\textbf{Tool} & \textbf{Approach} & \textbf{Key Features} \\
\midrule
Graphite & Web-based + CLI & Visual stack management, auto-rebase, sync with GitHub \\
git-stack & CLI-only & Lightweight, no external service \\
stacked-PRs & GitHub Actions & Native GitHub, no CLI required \\
ghstack & Meta/Facebook & Heavy automation, complex setups \\
\bottomrule
\end{tabular}
\caption{Stacked PR tooling comparison}
\end{table}

\subsubsection{Workflow Procedures}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Create the stack}
        \begin{lstlisting}[style=yaml]
# Using Graphite as example
git checkout main
git checkout -b feature/step-1
# Make changes, commit
gt stack create

git checkout -b feature/step-2
# Make changes, commit
gt stack create

git checkout -b feature/step-3
# Make changes, commit
gt stack create

# Push entire stack
gt stack push
        \end{lstlisting}
    
    \item \textbf{Review process}
        \begin{itemize}
            \item Review PRs from bottom of stack (closest to main) first
            \item Each PR approved independently
            \item Merge bottom PR first, tool auto-rebases stack
        \end{itemize}
    
    \item \textbf{Handle feedback}
        \begin{itemize}
            \item Checkout the specific branch in stack
            \item Make changes, commit
            \item Tool propagates changes up the stack
            \item Push updates
        \end{itemize}
\end{enumerate}

\subsection{Draft Pull Requests}

Encourage liberal use of draft PRs for:

\begin{itemize}[leftmargin=*]
    \item \textbf{Early design feedback}: Share architectural approaches before full implementation
    \item \textbf{CI validation}: Verify tests pass before formal review request
    \item \textbf{Exploratory work}: Demonstrate prototypes or proof-of-concepts
    \item \textbf{Incremental progress}: Show work-in-progress on long-running features
\end{itemize}

\keypoint{Guideline}: Draft PRs should be marked "Ready for Review" only when:
\begin{itemize}[leftmargin=*]
    \item All CI checks pass
    \item Author has self-reviewed the changes
    \item Description and test plan are complete
    \item No known issues remain
\end{itemize}

\subsection{Commit Message Standards}

Enforce structured commit messages for maintainability:

\subsubsection{Conventional Commits Format}

\begin{lstlisting}[style=markdown]
<type>(<scope>): <subject>

<body>

<footer>
\end{lstlisting}

\textbf{Types}: \texttt{feat}, \texttt{fix}, \texttt{docs}, \texttt{style}, \texttt{refactor}, \texttt{perf}, \texttt{test}, \texttt{chore}

\textbf{Example}:
\begin{lstlisting}[style=markdown]
feat(auth): implement OAuth2 token refresh

Add automatic token refresh when access token expires.
Includes retry logic with exponential backoff.

Closes #1234
\end{lstlisting}

% ============================================================================
% SECTION 4: AUTOMATION AND TOOLING
% ============================================================================
\section{Automation and Tooling}

\subsection{Continuous Integration Pipeline}

CI/CD is the foundation of automated PR validation. Every PR must trigger:

\subsubsection{Essential CI Checks}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Build verification}
        \begin{itemize}
            \item Compilation succeeds
            \item Dependencies resolve
            \item No syntax errors
        \end{itemize}
    
    \item \textbf{Test execution}
        \begin{itemize}
            \item Unit tests pass (100\% execution)
            \item Integration tests pass
            \item Coverage meets threshold (e.g., 80\%)
            \item No flaky test failures
        \end{itemize}
    
    \item \textbf{Static analysis}
        \begin{itemize}
            \item Linting (code style)
            \item Type checking
            \item Complexity analysis
            \item Dead code detection
        \end{itemize}
    
    \item \textbf{Security scanning}
        \begin{itemize}
            \item Dependency vulnerability check
            \item Secret detection
            \item SAST (static application security testing)
            \item License compliance
        \end{itemize}
    
    \item \textbf{Performance regression}
        \begin{itemize}
            \item Benchmark comparison against baseline
            \item Memory leak detection
            \item Build time regression
        \end{itemize}
\end{enumerate}

\subsubsection{GitHub Actions Example}

\begin{lstlisting}[style=yaml]
name: Pull Request Validation

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Lint
        run: npm run lint
      
      - name: Type check
        run: npm run type-check
      
      - name: Run tests
        run: npm test -- --coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
      
      - name: Security audit
        run: npm audit --audit-level=moderate
      
      - name: Check bundle size
        run: npm run build && npm run check-size
\end{lstlisting}

\subsection{Code Owners (CODEOWNERS)}

Automate review routing and ensure domain expertise:

\subsubsection{CODEOWNERS File Structure}

\begin{lstlisting}[style=markdown]
# Default owners for everything
*       @org/engineering-team

# Frontend ownership
/src/frontend/           @org/frontend-team
/src/components/         @org/frontend-team @tech-lead-ui

# Backend services
/src/api/                @org/backend-team
/src/services/auth/      @org/security-team @backend-team
/src/services/payments/  @org/payments-team @backend-team

# Infrastructure
/terraform/              @org/platform-team
/.github/workflows/      @org/devops-team
/k8s/                    @org/platform-team @org/sre-team

# Documentation
/docs/                   @org/tech-writers @tech-lead-docs
*.md                     @org/tech-writers

# Critical security files
/src/auth/               @org/security-team
/src/crypto/             @org/security-team @ciso

# Database migrations
/migrations/             @org/dba-team @backend-team
\end{lstlisting}

\subsubsection{CODEOWNERS Best Practices}

\begin{itemize}[leftmargin=*]
    \item \textbf{Specificity}: More specific paths override general rules
    \item \textbf{Required reviews}: Use branch protection to enforce CODEOWNERS approvals
    \item \textbf{Load balancing}: Rotate individuals in CODEOWNERS to prevent bottlenecks
    \item \textbf{Fallback owners}: Always specify a default owner (\texttt{*})
    \item \textbf{Cross-training}: Include secondary reviewers to build redundancy
\end{itemize}

\subsection{Branch Protection Rules}

Enforce quality gates before merge:

\subsubsection{Recommended Protection Rules}

\begin{table}[h]
\centering
\small
\begin{tabular}{p{4cm}p{8.5cm}}
\toprule
\textbf{Rule} & \textbf{Configuration} \\
\midrule
Require pull request & \textbf{On} --- All changes must go through PR \\
Required approvals & \textbf{2 approvals} (adjust based on team size) \\
Dismiss stale approvals & \textbf{On} --- Re-review after new commits \\
Require review from CODEOWNERS & \textbf{On} --- Enforce domain expertise \\
Required status checks & \textbf{Specify all CI jobs} (lint, test, security) \\
Require branches up to date & \textbf{On} --- Prevent merge conflicts \\
Require linear history & \textbf{On} --- No merge commits (rebase or squash) \\
Require signed commits & \textbf{Optional} --- For compliance requirements \\
Include administrators & \textbf{On} --- No special bypass privileges \\
Restrict who can push & \textbf{On} --- Only automated systems and admins \\
\bottomrule
\end{tabular}
\caption{Branch protection rule recommendations for main branch}
\end{table}

\subsubsection{Configuration Example}

\begin{lstlisting}[style=yaml]
# .github/branch-protection.yml (using API or web UI)
required_pull_request_reviews:
  dismissal_restrictions:
    users: []
    teams: []
  dismiss_stale_reviews: true
  require_code_owner_reviews: true
  required_approving_review_count: 2

required_status_checks:
  strict: true
  contexts:
    - "ci/lint"
    - "ci/test"
    - "ci/security-scan"
    - "ci/build"

enforce_admins: true
required_linear_history: true
allow_force_pushes: false
allow_deletions: false
\end{lstlisting}

\subsection{Automated Merge and Bots}

Reduce manual intervention for low-risk PRs:

\subsubsection{Auto-Merge Policies}

Define categories of PRs eligible for automated merge:

\begin{table}[h]
\centering
\small
\begin{tabular}{p{3cm}p{4cm}p{5.5cm}}
\toprule
\textbf{PR Type} & \textbf{Criteria} & \textbf{Auto-Merge Policy} \\
\midrule
Dependency updates & Dependabot, renovate & Auto-merge if CI passes, minor/patch only \\
Documentation & Only \texttt{*.md} changes & Auto-merge if 1 approval + CI pass \\
Config tweaks & \texttt{*.yml}, \texttt{*.json} & Auto-merge if 1 approval + CI pass \\
Code formatting & Only style changes & Auto-merge if CI passes \\
Test additions & Only \texttt{test/} directory & Auto-merge if 1 approval + tests pass \\
\bottomrule
\end{tabular}
\caption{Auto-merge policy matrix}
\end{table}

\subsubsection{Dependabot Configuration}

\begin{lstlisting}[style=yaml]
# .github/dependabot.yml
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
      day: "monday"
      time: "09:00"
    open-pull-requests-limit: 5
    reviewers:
      - "org/frontend-team"
    labels:
      - "dependencies"
      - "auto-merge-candidate"
    commit-message:
      prefix: "chore"
      include: "scope"
    
  - package-ecosystem: "docker"
    directory: "/"
    schedule:
      interval: "weekly"
    reviewers:
      - "org/platform-team"
\end{lstlisting}

\subsubsection{Auto-Merge GitHub Action}

\begin{lstlisting}[style=yaml]
name: Auto-merge

on:
  pull_request:
    types: [labeled, synchronize]
  check_suite:
    types: [completed]

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: |
      contains(github.event.pull_request.labels.*.name, 'auto-merge') &&
      github.event.pull_request.user.login == 'dependabot[bot]'
    steps:
      - name: Auto-merge
        uses: pascalgn/automerge-action@v0.15.6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MERGE_LABELS: "auto-merge,!work-in-progress"
          MERGE_METHOD: "squash"
          MERGE_COMMIT_MESSAGE: "pull-request-title"
          MERGE_RETRIES: 6
          MERGE_RETRY_SLEEP: 10000
\end{lstlisting}

\subsection{Code Quality Thresholds}

Block PRs that degrade quality metrics:

\subsubsection{Coverage Thresholds}

\begin{lstlisting}[style=yaml]
# jest.config.js (for JavaScript/TypeScript)
module.exports = {
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    },
    './src/critical/': {
      branches: 95,
      functions: 95,
      lines: 95,
      statements: 95
    }
  }
};
\end{lstlisting}

\subsubsection{Complexity Limits}

\begin{lstlisting}[style=yaml]
# .eslintrc.json
{
  "rules": {
    "complexity": ["error", { "max": 10 }],
    "max-depth": ["error", 4],
    "max-lines": ["error", { "max": 300, "skipBlankLines": true }],
    "max-lines-per-function": ["error", { "max": 50 }]
  }
}
\end{lstlisting}

% ============================================================================
% SECTION 5: ORGANIZATIONAL CULTURE
% ============================================================================
\section{Organizational Culture and Guidelines}

\subsection{Psychological Safety Framework}

\subsubsection{No-Blame Code Review Principles}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Assume good intent}: Reviewers presume authors made reasonable decisions with available context
    \item \textbf{Ask questions, don't make demands}: Frame feedback as inquiry ("Could we consider...?") rather than directives
    \item \textbf{Separate person from code}: Critique the implementation, never the implementer
    \item \textbf{Public praise, private criticism}: Celebrate good work openly; address concerns in PR comments, not public channels
    \item \textbf{Learn together}: Treat reviews as mutual learning opportunities
\end{enumerate}

\subsubsection{Example Feedback Patterns}

\begin{table}[h]
\centering
\small
\begin{tabular}{p{5.5cm}p{7cm}}
\toprule
\textbf{❌ Avoid} & \textbf{✓ Prefer} \\
\midrule
"This is wrong" & "I'm concerned this might cause X. Could we discuss alternatives?" \\
"Why didn't you...?" & "Would it make sense to also consider...?" \\
"You should know better" & "For future reference, our team convention is..." \\
"This is terrible" & "This approach works, but I wonder if [alternative] might be more maintainable because..." \\
\bottomrule
\end{tabular}
\caption{Code review feedback anti-patterns vs. constructive patterns}
\end{table}

\subsection{CONTRIBUTING.md Guidelines}

Establish a comprehensive contributor guide:

\subsubsection{Required Sections}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Getting started}
        \begin{itemize}
            \item Development environment setup
            \item How to run tests locally
            \item How to build the project
        \end{itemize}
    
    \item \textbf{Pull request process}
        \begin{itemize}
            \item PR size expectations
            \item Required PR template usage
            \item How to request reviews
            \item Expected review turnaround time
        \end{itemize}
    
    \item \textbf{Code standards}
        \begin{itemize}
            \item Coding style guide (link to style guide)
            \item Naming conventions
            \item Comment and documentation requirements
            \item Test coverage expectations
        \end{itemize}
    
    \item \textbf{Review standards}
        \begin{itemize}
            \item What reviewers should look for
            \item Approval criteria
            \item How to handle disagreements
        \end{itemize}
    
    \item \textbf{Merge criteria}
        \begin{itemize}
            \item Required approvals
            \item CI passing requirements
            \item How conflicts are resolved
        \end{itemize}
\end{enumerate}

See Appendix~\ref{app:contributing} for a complete template.

\subsection{Review Service Level Objectives (SLOs)}

Define explicit expectations for review latency:

\subsubsection{Recommended SLOs}

\begin{table}[h]
\centering
\begin{tabular}{p{3.5cm}p{3cm}p{5.5cm}}
\toprule
\textbf{PR Type} & \textbf{First Review} & \textbf{Final Approval} \\
\midrule
Hotfix / Critical & 1 hour & 2 hours \\
Small PR (<200 LOC) & 4 business hours & 1 business day \\
Medium PR (200--400 LOC) & 1 business day & 2 business days \\
Large PR (>400 LOC) & \multicolumn{2}{l}{\textit{Should be decomposed}} \\
Documentation-only & 1 business day & 2 business days \\
Dependency updates & Automated & Automated \\
\bottomrule
\end{tabular}
\caption{Review SLO guidelines by PR type}
\end{table}

\subsubsection{Monitoring and Accountability}

\begin{itemize}[leftmargin=*]
    \item Track SLO compliance in team dashboards
    \item Identify bottleneck reviewers
    \item Rotate review responsibilities to prevent burnout
    \item Escalate SLO violations to engineering management
\end{itemize}

\subsection{Review Rotation and Capacity Planning}

Distribute review workload equitably:

\subsubsection{Rotation Strategies}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Round-robin}: Assign reviews sequentially across team members
    \item \textbf{Expertise-based}: Route to domain experts via CODEOWNERS, with fallback rotation
    \item \textbf{Load-balanced}: Assign to reviewer with fewest active review requests
    \item \textbf{Hybrid}: Combine expertise routing with load balancing
\end{enumerate}

\subsubsection{Capacity Allocation}

Reserve explicit time for code review:

\begin{itemize}[leftmargin=*]
    \item \textbf{Daily review windows}: Block 30--60 minutes for review
    \item \textbf{Review-only days}: Designate one day/week for focused review work
    \item \textbf{Interrupt-driven}: Respond to review requests within SLO windows
\end{itemize}

\keypoint{Guideline}: Senior engineers should allocate 20--30\% of time to code review; mid-level engineers 10--20\%.

% ============================================================================
% SECTION 6: IMPLEMENTATION ROADMAP
% ============================================================================
\section{Implementation Roadmap}

\subsection{Phase 1: Foundation (Weeks 1--2)}

\subsubsection{Objectives}
\begin{itemize}[leftmargin=*]
    \item Prevent bad merges with automated validation
    \item Standardize PR structure
    \item Establish baseline metrics
\end{itemize}

\subsubsection{Action Items}

\begin{table}[h]
\centering
\small
\begin{tabular}{p{1cm}p{5cm}p{2.5cm}p{3cm}}
\toprule
\textbf{Week} & \textbf{Task} & \textbf{Owner} & \textbf{Success Metric} \\
\midrule
1 & Configure branch protection on main & Platform team & Protection enabled \\
1 & Implement basic CI (lint, test, build) & DevOps team & All PRs run CI \\
1 & Create PR template & Tech lead & Template adoption >80\% \\
1--2 & Document PR size guidelines & Tech lead & Published in wiki \\
2 & Set up code coverage reporting & DevOps team & Coverage visible on PRs \\
2 & Establish baseline metrics & Engineering manager & Dashboard created \\
\bottomrule
\end{tabular}
\caption{Phase 1 implementation tasks}
\end{table}

\subsubsection{Metrics to Track}
\begin{itemize}[leftmargin=*]
    \item PRs created per day
    \item Median PR size (LOC)
    \item Time to first review
    \item Time to merge
    \item CI failure rate
\end{itemize}

\subsection{Phase 2: Intelligent Routing (Weeks 3--4)}

\subsubsection{Objectives}
\begin{itemize}[leftmargin=*]
    \item Automate review assignment
    \item Ensure domain expertise in reviews
    \item Reduce review latency
\end{itemize}

\subsubsection{Action Items}

\begin{table}[h]
\centering
\small
\begin{tabular}{p{1cm}p{5cm}p{2.5cm}p{3cm}}
\toprule
\textbf{Week} & \textbf{Task} & \textbf{Owner} & \textbf{Success Metric} \\
\midrule
3 & Define code ownership boundaries & Tech leads & CODEOWNERS file \\
3 & Implement CODEOWNERS file & Platform team & Auto-assignment works \\
3 & Configure required CODEOWNERS review & Platform team & Protection enforced \\
4 & Set up review load balancing & DevOps team & Balanced distribution \\
4 & Document review SLOs & Engineering manager & SLOs published \\
\bottomrule
\end{tabular}
\caption{Phase 2 implementation tasks}
\end{table}

\subsubsection{Metrics to Track}
\begin{itemize}[leftmargin=*]
    \item Review assignment accuracy (correct expertise)
    \item Review load distribution (Gini coefficient)
    \item SLO compliance percentage
\end{itemize}

\subsection{Phase 3: Automation Layer (Weeks 5--8)}

\subsubsection{Objectives}
\begin{itemize}[leftmargin=*]
    \item Automate low-risk PRs
    \item Reduce manual merge operations
    \item Improve dependency update cadence
\end{itemize}

\subsubsection{Action Items}

\begin{table}[h]
\centering
\small
\begin{tabular}{p{1cm}p{5cm}p{2.5cm}p{3cm}}
\toprule
\textbf{Week} & \textbf{Task} & \textbf{Owner} & \textbf{Success Metric} \\
\midrule
5 & Configure Dependabot & DevOps team & Weekly updates \\
5 & Define auto-merge policies & Tech leads & Policy doc \\
6 & Implement auto-merge action & Platform team & Auto-merge working \\
6 & Set up dependency auto-merge & DevOps team & Deps merge without manual intervention \\
7 & Add security scanning to CI & Security team & Vulns blocked \\
8 & Implement PR size enforcement & Platform team & Large PRs warned \\
\bottomrule
\end{tabular}
\caption{Phase 3 implementation tasks}
\end{table}

\subsubsection{Metrics to Track}
\begin{itemize}[leftmargin=*]
    \item Percentage of PRs auto-merged
    \item Dependency update cycle time
    \item Security vulnerabilities caught pre-merge
\end{itemize}

\subsection{Phase 4: Advanced Workflows (Weeks 9--12)}

\subsubsection{Objectives}
\begin{itemize}[leftmargin=*]
    \item Enable stacked PR workflows for complex changes
    \item Implement review operations dashboards
    \item Establish continuous improvement processes
\end{itemize}

\subsubsection{Action Items}

\begin{table}[h]
\centering
\small
\begin{tabular}{p{1cm}p{5cm}p{2.5cm}p{3cm}}
\toprule
\textbf{Week} & \textbf{Task} & \textbf{Owner} & \textbf{Success Metric} \\
\midrule
9 & Evaluate stacked PR tooling & Tech leads & Tool selected \\
10 & Pilot stacked PRs with one team & Platform team & 5 successful stacks \\
11 & Build review ops dashboard & DevOps team & Dashboard live \\
11 & Document stacked PR workflow & Tech writer & Docs published \\
12 & Conduct retrospective & Engineering manager & Action items identified \\
12 & Roll out stacked PRs org-wide & Platform team & All teams enabled \\
\bottomrule
\end{tabular}
\caption{Phase 4 implementation tasks}
\end{table}

\subsubsection{Metrics to Track}
\begin{itemize}[leftmargin=*]
    \item Stacked PR adoption rate
    \item Complex change cycle time (vs. baseline)
    \item Developer satisfaction (survey)
\end{itemize}

\subsection{Ongoing Operations}

\subsubsection{Weekly Activities}
\begin{itemize}[leftmargin=*]
    \item Review SLO compliance dashboard
    \item Triage stale PRs (>5 days old)
    \item Review load balancing across team
\end{itemize}

\subsubsection{Monthly Activities}
\begin{itemize}[leftmargin=*]
    \item Review metrics trends
    \item Update CODEOWNERS as needed
    \item Refine auto-merge policies based on learnings
\end{itemize}

\subsubsection{Quarterly Activities}
\begin{itemize}[leftmargin=*]
    \item Developer satisfaction survey
    \item Process retrospective
    \item Benchmark against industry standards
\end{itemize}

% ============================================================================
% SECTION 7: OPERATIONAL PROCEDURES
% ============================================================================
\section{Operational Procedures}

\subsection{Daily Review Operations}

\subsubsection{Morning Review Triage (15 minutes)}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Check review dashboard}
        \begin{itemize}
            \item Identify SLO violations
            \item Note blocked PRs
            \item Review queue depth
        \end{itemize}
    
    \item \textbf{Prioritize review queue}
        \begin{itemize}
            \item Hotfixes first
            \item Small PRs (<100 LOC) next
            \item Oldest PRs within SLO window
            \item Large PRs last (after confirming they shouldn't be split)
        \end{itemize}
    
    \item \textbf{Assign urgent reviews}
        \begin{itemize}
            \item Manually assign critical reviews if auto-assignment missed
            \item Escalate SLO violations to team leads
        \end{itemize}
\end{enumerate}

\subsubsection{Review Execution Best Practices}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Pre-review}
        \begin{itemize}
            \item Read PR description and test plan
            \item Check CI status
            \item Review commit history
            \item Identify potential risks
        \end{itemize}
    
    \item \textbf{During review}
        \begin{itemize}
            \item Start with high-level architecture
            \item Check for security issues
            \item Verify test coverage
            \item Review error handling
            \item Check documentation updates
        \end{itemize}
    
    \item \textbf{Post-review}
        \begin{itemize}
            \item Summarize key feedback
            \item Indicate blocking vs. non-blocking comments
            \item Set expectations for next steps
            \item Approve or request changes explicitly
        \end{itemize}
\end{enumerate}

\subsection{Handling Stale Pull Requests}

\subsubsection{Definition}

A PR is considered stale when:
\begin{itemize}[leftmargin=*]
    \item No activity for 5+ business days
    \item Author has not responded to feedback in 3+ business days
    \item Merge conflicts exist for 2+ business days
\end{itemize}

\subsubsection{Stale PR Triage Process}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Identify stale PRs} (automated bot labels)
    \item \textbf{Categorize by reason}
        \begin{itemize}
            \item Awaiting author response
            \item Awaiting reviewer response
            \item Merge conflicts
            \item CI failures
            \item Unclear next steps
        \end{itemize}
    \item \textbf{Take action}
        \begin{itemize}
            \item \textbf{Author blockers}: Ping author, offer to pair
            \item \textbf{Reviewer blockers}: Reassign or escalate
            \item \textbf{Conflicts}: Notify author, offer rebase assistance
            \item \textbf{Unclear}: Triage with tech lead
        \end{itemize}
    \item \textbf{Close abandoned PRs}
        \begin{itemize}
            \item No response after 2 pings over 10 days
            \item Comment with reason and offer to reopen
        \end{itemize}
\end{enumerate}

\subsection{Handling Large Pull Requests}

\subsubsection{Detection}

Automatically flag PRs with:
\begin{itemize}[leftmargin=*]
    \item >400 lines changed
    \item >50 files changed
    \item >10 commits
\end{itemize}

\subsubsection{Response Protocol}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Immediate feedback} (within 1 hour)
        \begin{itemize}
            \item Comment on PR: "This PR is large. Let's discuss decomposition strategy."
            \item Suggest meeting or pairing session
        \end{itemize}
    
    \item \textbf{Decomposition workshop}
        \begin{itemize}
            \item Review with author
            \item Identify independently reviewable units
            \item Plan sequence of smaller PRs
        \end{itemize}
    
    \item \textbf{Options}
        \begin{itemize}
            \item Close large PR, create stack of small PRs
            \item If truly atomic, schedule dedicated review session with multiple reviewers
            \item For emergency/urgent changes, fast-track with senior reviewer pair
        \end{itemize}
\end{enumerate}

\subsection{Conflict Resolution}

\subsubsection{Technical Disagreements}

When reviewer and author disagree on approach:

\begin{enumerate}[leftmargin=*]
    \item \textbf{Document both perspectives}
        \begin{itemize}
            \item Author explains reasoning
            \item Reviewer explains concern
        \end{itemize}
    
    \item \textbf{Escalation path}
        \begin{itemize}
            \item Involve tech lead or architect
            \item Schedule synchronous discussion
            \item Document decision and rationale
        \end{itemize}
    
    \item \textbf{Resolution criteria}
        \begin{itemize}
            \item Security/correctness concerns: reviewer judgment prevails
            \item Style/preference: defer to existing patterns or CODEOWNERS
            \item Architecture: tech lead or architect decides
            \item If urgent: senior engineer makes call, document for future discussion
        \end{itemize}
\end{enumerate}

\subsubsection{Process Violations}

When PR violates established guidelines:

\begin{enumerate}[leftmargin=*]
    \item \textbf{Automated enforcement} (preferred)
        \begin{itemize}
            \item CI fails for violations
            \item PR cannot merge until resolved
        \end{itemize}
    
    \item \textbf{Manual enforcement}
        \begin{itemize}
            \item Reviewer politely points to guideline
            \item Request changes
            \item If pattern persists, discuss with engineer and manager
        \end{itemize}
\end{enumerate}

% ============================================================================
% SECTION 8: METRICS AND CONTINUOUS IMPROVEMENT
% ============================================================================
\section{Metrics and Continuous Improvement}

\subsection{Key Performance Indicators}

\subsubsection{Velocity Metrics}

\begin{table}[h]
\centering
\small
\begin{tabular}{p{4cm}p{4cm}p{4.5cm}}
\toprule
\textbf{Metric} & \textbf{Target} & \textbf{Measurement} \\
\midrule
Time to first review & <4 hours (small PRs) & P50, P90, P99 \\
Time to merge & <24 hours (small PRs) & P50, P90, P99 \\
PRs merged per day & Baseline + 20\% & Daily average \\
PRs created per day & Baseline + 30\% & Daily average \\
Merge frequency & Multiple per day & Per developer \\
\bottomrule
\end{tabular}
\caption{Velocity KPIs}
\end{table}

\subsubsection{Quality Metrics}

\begin{table}[h]
\centering
\small
\begin{tabular}{p{4cm}p{4cm}p{4.5cm}}
\toprule
\textbf{Metric} & \textbf{Target} & \textbf{Measurement} \\
\midrule
CI pass rate & >95\% first attempt & Percentage \\
Test coverage & >80\% overall & Per PR delta \\
Code review comments & 3--8 per PR & Average \\
Reverts/rollbacks & <2\% of merges & Percentage \\
Security issues caught & 100\% in PR & Pre-merge detections \\
\bottomrule
\end{tabular}
\caption{Quality KPIs}
\end{table}

\subsubsection{Efficiency Metrics}

\begin{table}[h]
\centering
\small
\begin{tabular}{p{4cm}p{4cm}p{4.5cm}}
\toprule
\textbf{Metric} & \textbf{Target} & \textbf{Measurement} \\
\midrule
PR size & <200 LOC median & P50, P90 \\
Review iterations & <2 rounds & Average rounds to merge \\
Merge conflicts & <5\% of PRs & Percentage \\
Auto-merge rate & >30\% eligible PRs & Percentage \\
Stale PR rate & <10\% & PRs open >5 days \\
\bottomrule
\end{tabular}
\caption{Efficiency KPIs}
\end{table}

\subsubsection{Experience Metrics}

\begin{table}[h]
\centering
\small
\begin{tabular}{p{4cm}p{4cm}p{4.5cm}}
\toprule
\textbf{Metric} & \textbf{Target} & \textbf{Measurement} \\
\midrule
Developer satisfaction & >8/10 & Quarterly survey \\
Review load balance & Gini <0.3 & Distribution \\
SLO compliance & >90\% & Percentage \\
Reviewer burnout & <20\% high load & Self-reported \\
\bottomrule
\end{tabular}
\caption{Experience KPIs}
\end{table}

\subsection{Dashboard Implementation}

\subsubsection{Essential Visualizations}

\begin{enumerate}[leftmargin=*]
    \item \textbf{PR flow diagram}
        \begin{itemize}
            \item PRs opened, reviewed, merged per day
            \item Cumulative flow diagram
        \end{itemize}
    
    \item \textbf{Cycle time trends}
        \begin{itemize}
            \item Time to first review (trend over weeks)
            \item Time to merge (trend over weeks)
            \item Breakdown by PR size
        \end{itemize}
    
    \item \textbf{SLO compliance}
        \begin{itemize}
            \item Percentage meeting review SLO
            \item Percentage meeting merge SLO
            \item Violations by reviewer
        \end{itemize}
    
    \item \textbf{Review workload}
        \begin{itemize}
            \item Active reviews per person
            \item Review comments per person
            \item Time spent in review (if tracked)
        \end{itemize}
    
    \item \textbf{Quality indicators}
        \begin{itemize}
            \item CI pass rate trend
            \item Code coverage trend
            \item Revert rate
        \end{itemize}
\end{enumerate}

\subsubsection{Tooling Options}

\begin{itemize}[leftmargin=*]
    \item \textbf{GitHub Insights}: Native GitHub analytics
    \item \textbf{LinearB}: Engineering intelligence platform
    \item \textbf{Swarmia}: Engineering effectiveness dashboard
    \item \textbf{Jellyfish}: Engineering management platform
    \item \textbf{Custom dashboards}: Grafana + GitHub API
\end{itemize}

\subsection{Retrospective Cadence}

\subsubsection{Monthly Team Retrospective}

\textbf{Agenda} (60 minutes):
\begin{enumerate}[leftmargin=*]
    \item Review metrics vs. targets (10 min)
    \item Discuss top friction points (20 min)
    \item Identify successful patterns (15 min)
    \item Propose process experiments (10 min)
    \item Commit to action items (5 min)
\end{enumerate}

\textbf{Focus questions}:
\begin{itemize}[leftmargin=*]
    \item Which PRs took longest? Why?
    \item Where did we exceed SLOs? What worked?
    \item What caused most review iterations?
    \item Which automations saved the most time?
    \item What's still painful?
\end{itemize}

\subsubsection{Quarterly Process Review}

\textbf{Deep-dive analysis}:
\begin{enumerate}[leftmargin=*]
    \item Trend analysis across 3 months
    \item Benchmark against initial baseline
    \item Compare against industry standards
    \item Developer satisfaction survey review
    \item Major process changes assessment
\end{enumerate}

\textbf{Outputs}:
\begin{itemize}[leftmargin=*]
    \item Updated process documentation
    \item Revised SLOs if needed
    \item New automation opportunities identified
    \item Training needs assessment
\end{itemize}

\subsection{Continuous Improvement Experiments}

\subsubsection{A/B Testing Process Changes}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Hypothesis}: "Reducing required approvals from 2 to 1 for small PRs will decrease time-to-merge by 30\% without increasing revert rate"
    
    \item \textbf{Experiment design}
        \begin{itemize}
            \item Control group: Team A (2 approvals)
            \item Treatment group: Team B (1 approval for <100 LOC PRs)
            \item Duration: 2 weeks
        \end{itemize}
    
    \item \textbf{Metrics}
        \begin{itemize}
            \item Time to merge (primary)
            \item Revert rate (safety check)
            \item Developer satisfaction (survey)
        \end{itemize}
    
    \item \textbf{Decision criteria}
        \begin{itemize}
            \item Adopt if time-to-merge improves >20\% AND revert rate doesn't increase >10\%
        \end{itemize}
\end{enumerate}

% ============================================================================
% SECTION 9: TROUBLESHOOTING GUIDE
% ============================================================================
\section{Troubleshooting Common Issues}

\subsection{Problem: Review Latency Increasing}

\subsubsection{Symptoms}
\begin{itemize}[leftmargin=*]
    \item Time-to-first-review >8 hours
    \item SLO violations increasing
    \item Developer complaints about waiting
\end{itemize}

\subsubsection{Diagnosis}

\begin{enumerate}[leftmargin=*]
    \item Check review load distribution
        \begin{itemize}
            \item Is one person a bottleneck?
            \item Are CODEOWNERS too concentrated?
        \end{itemize}
    
    \item Analyze PR characteristics
        \begin{itemize}
            \item Are PRs getting larger?
            \item More complex changes?
            \item Insufficient context in descriptions?
        \end{itemize}
    
    \item Review team capacity
        \begin{itemize}
            \item Team members on PTO?
            \item Increased PR volume?
            \item Other priorities consuming time?
        \end{itemize}
\end{enumerate}

\subsubsection{Solutions}

\begin{itemize}[leftmargin=*]
    \item \textbf{Short-term}
        \begin{itemize}
            \item Temporarily reduce approval requirements
            \item Assign backup reviewers
            \item Escalate urgent PRs to management
        \end{itemize}
    
    \item \textbf{Long-term}
        \begin{itemize}
            \item Expand CODEOWNERS to more team members
            \item Implement review rotation
            \item Reinforce PR size guidelines
            \item Add more automated validation
        \end{itemize}
\end{itemize}

\subsection{Problem: High Merge Conflict Rate}

\subsubsection{Symptoms}
\begin{itemize}[leftmargin=*]
    \item >10\% of PRs have merge conflicts
    \item Developers spending significant time rebasing
    \item Frustration with "conflict hell"
\end{itemize}

\subsubsection{Diagnosis}

\begin{enumerate}[leftmargin=*]
    \item Identify conflict hotspots
        \begin{itemize}
            \item Which files conflict most?
            \item Are conflicts in shared utilities?
            \item Architectural coupling issues?
        \end{itemize}
    
    \item Analyze PR patterns
        \begin{itemize}
            \item Are PRs too large?
            \item Too many PRs touching same areas?
            \item Long-lived feature branches?
        \end{itemize}
\end{enumerate}

\subsubsection{Solutions}

\begin{itemize}[leftmargin=*]
    \item \textbf{Immediate}
        \begin{itemize}
            \item Enable "require branches up to date" protection
            \item Implement auto-rebase bot
            \item Coordinate work on high-conflict areas
        \end{itemize}
    
    \item \textbf{Structural}
        \begin{itemize}
            \item Refactor hotspot files for better modularity
            \item Use feature flags instead of long-lived branches
            \item Adopt stacked PRs for dependent changes
            \item Reduce PR size to minimize conflict window
        \end{itemize}
\end{itemize}

\subsection{Problem: Low Auto-Merge Adoption}

\subsubsection{Symptoms}
\begin{itemize}[leftmargin=*]
    \item <10\% of eligible PRs auto-merge
    \item Manual intervention still required
    \item Dependency updates pile up
\end{itemize}

\subsubsection{Diagnosis}

\begin{enumerate}[leftmargin=*]
    \item Check auto-merge configuration
        \begin{itemize}
            \item Are labels applied correctly?
            \item CI passing consistently?
            \item Branch protection conflicts?
        \end{itemize}
    
    \item Review eligibility criteria
        \begin{itemize}
            \item Too strict policies?
            \item Missing automation for eligible categories?
        \end{itemize}
\end{enumerate}

\subsubsection{Solutions}

\begin{itemize}[leftmargin=*]
    \item Expand auto-merge categories
    \item Improve CI stability
    \item Auto-label eligible PRs
    \item Document auto-merge policies clearly
\end{itemize}

\subsection{Problem: Quality Regressions}

\subsubsection{Symptoms}
\begin{itemize}[leftmargin=*]
    \item Increased bug reports from production
    \item Rising revert rate
    \item Failed deployments
\end{itemize}

\subsubsection{Diagnosis}

\begin{enumerate}[leftmargin=*]
    \item Analyze reverted PRs
        \begin{itemize}
            \item What was missed in review?
            \item Test coverage gaps?
            \item Rushed reviews?
        \end{itemize}
    
    \item Review velocity vs. quality tradeoff
        \begin{itemize}
            \item Are reviewers sacrificing thoroughness for speed?
            \item Insufficient approval requirements?
        \end{itemize}
\end{enumerate}

\subsubsection{Solutions}

\begin{itemize}[leftmargin=*]
    \item \textbf{Process tightening}
        \begin{itemize}
            \item Increase approval requirements temporarily
            \item Add mandatory security/architecture reviews for certain areas
            \item Implement pre-merge integration testing
        \end{itemize}
    
    \item \textbf{Automation strengthening}
        \begin{itemize}
            \item Expand test coverage requirements
            \item Add more static analysis rules
            \item Implement regression test requirements
        \end{itemize}
    
    \item \textbf{Cultural reinforcement}
        \begin{itemize}
            \item Review postmortems for reverted PRs
            \item Share learnings widely
            \item Celebrate catching issues in review
        \end{itemize}
\end{itemize}

% ============================================================================
% SECTION 10: ADVANCED TOPICS
% ============================================================================
\section{Advanced Topics}

\subsection{Monorepo-Specific Strategies}

Monorepos require special considerations for PR operations at scale:

\subsubsection{Challenges}

\begin{itemize}[leftmargin=*]
    \item Large checkout sizes
    \item Slow CI due to breadth
    \item Difficult to scope reviews
    \item Cross-team coordination
\end{itemize}

\subsubsection{Solutions}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Affected path detection}
        \begin{lstlisting}[style=yaml]
# GitHub Action to run tests only for affected packages
name: Selective CI
on: [pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Get changed packages
        id: packages
        run: |
          CHANGED=$(git diff --name-only HEAD^ HEAD | grep -oP '^packages/\K[^/]+' | sort -u)
          echo "packages=$CHANGED" >> $GITHUB_OUTPUT
      - name: Run tests
        run: |
          for pkg in ${{ steps.packages.outputs.packages }}; do
            npm test --workspace=$pkg
          done
        \end{lstlisting}
    
    \item \textbf{CODEOWNERS granularity}
        \begin{lstlisting}[style=markdown]
# Monorepo CODEOWNERS with package ownership
/packages/frontend/      @org/frontend-team
/packages/backend/       @org/backend-team
/packages/shared/        @org/platform-team @org/frontend-team @org/backend-team
/packages/mobile/        @org/mobile-team
/libs/                   @org/platform-team
/.github/                @org/devops-team
        \end{lstlisting}
    
    \item \textbf{Scoped reviews}
        \begin{itemize}
            \item Label PRs by affected packages
            \item Route reviews based on package
            \item Allow parallel reviews of independent packages
        \end{itemize}
\end{enumerate}

\subsection{Cross-Repository Dependencies}

Managing PRs across multiple repositories:

\subsubsection{Coordination Patterns}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Synchronized merges}
        \begin{itemize}
            \item Create PRs in dependent repos simultaneously
            \item Link PRs in descriptions
            \item Merge in dependency order
            \item Use GitHub linking: ``Depends on org/repo\#123''
        \end{itemize}
    
    \item \textbf{Backward compatibility window}
        \begin{itemize}
            \item Maintain compatibility for N versions
            \item Allows independent deployment
            \item Deprecate old APIs over time
        \end{itemize}
    
    \item \textbf{Feature flags for cross-repo features}
        \begin{itemize}
            \item Ship code in both repos independently
            \item Enable feature once both deployed
            \item Roll back single repo if needed
        \end{itemize}
\end{enumerate}

\subsection{Security-Sensitive Repositories}

Additional PR considerations for high-security codebases:

\subsubsection{Enhanced Controls}

\begin{itemize}[leftmargin=*]
    \item \textbf{Mandatory security review}
        \begin{itemize}
            \item Designated security team approval required
            \item Automated threat modeling
            \item Secret scanning enforcement
        \end{itemize}
    
    \item \textbf{Signed commits}
        \begin{itemize}
            \item Require GPG/SSH signatures
            \item Verify commit identity
            \item Audit trail for compliance
        \end{itemize}
    
    \item \textbf{Two-person rule}
        \begin{itemize}
            \item Minimum 2 approvals for production code
            \item At least one from security team
            \item No self-merge allowed
        \end{itemize}
    
    \item \textbf{Automated compliance checks}
        \begin{itemize}
            \item SAST (Semgrep, CodeQL)
            \item Dependency vulnerability scanning
            \item Secrets detection (Gitleaks, TruffleHog)
            \item License compliance
        \end{itemize}
\end{itemize}

\subsection{Open Source Repository Considerations}

Managing external contributions:

\subsubsection{Contributor Experience}

\begin{itemize}[leftmargin=*]
    \item Clear CONTRIBUTING.md with expectations
    \item First-time contributor welcome bot
    \item Detailed PR template for external contributors
    \item Gracious feedback on rejected PRs
\end{itemize}

\subsubsection{Trust and Verification}

\begin{itemize}[leftmargin=*]
    \item Required CLA (Contributor License Agreement)
    \item Enhanced review for external PRs
    \item Fork-based workflow
    \item Limit CI resources for forks (prevent abuse)
\end{itemize}

% ============================================================================
% APPENDICES
% ============================================================================
\appendix

\section{Pull Request Template Example}
\label{app:pr-template}

\begin{lstlisting}[style=markdown]
## Description
<!-- Provide a clear and concise description of your changes -->

**What changed:**

**Why it changed:**

**Related issues/tickets:**
<!-- Link to GitHub issues, Jira tickets, design docs, etc. -->
Closes #

## Type of Change
<!-- Check all that apply -->
- [ ] Bug fix (non-breaking change which fixes an issue)
- [ ] New feature (non-breaking change which adds functionality)
- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)
- [ ] Refactoring (no functional changes)
- [ ] Documentation update
- [ ] Configuration change

## Risk Assessment
<!-- Help reviewers understand potential impact -->

**Blast radius:** 
<!-- What could break? Which users/systems are affected? -->

**Performance impact:** 
<!-- Does this change performance? Better/worse? By how much? -->

**Security implications:** 
<!-- Are there authentication, authorization, or data privacy concerns? -->

**Database changes:** 
<!-- Schema changes? Data migrations? Backward compatible? -->

## Testing
<!-- Describe the tests you ran and how to reproduce -->

**Test coverage:**
- [ ] Unit tests added/updated
- [ ] Integration tests added/updated
- [ ] End-to-end tests added/updated

**Test scenarios covered:**
1. 
2. 
3. 

**Manual testing performed:**
<!-- What did you test manually? Include steps to reproduce -->

**Edge cases considered:**
<!-- What edge cases did you think about? -->

## Deployment Considerations

**Feature flags:** 
<!-- Is this behind a feature flag? Which one? -->

**Rollout strategy:** 
<!-- Canary? Blue-green? All at once? -->

**Rollback plan:** 
<!-- How do we roll back if something goes wrong? -->

**Dependencies:** 
<!-- Does this depend on other services, configs, or deployments? -->

**Monitoring:** 
<!-- What metrics/logs should we watch? -->

## Documentation
<!-- Check all that apply -->
- [ ] Code comments added/updated
- [ ] README updated
- [ ] API documentation updated
- [ ] Architecture decision record (ADR) created
- [ ] No documentation needed

## Reviewer Checklist
<!-- Reviewers: please confirm before approving -->
- [ ] Code matches requirements and design
- [ ] Tests are comprehensive and pass
- [ ] No obvious security vulnerabilities
- [ ] Performance impact is acceptable
- [ ] Documentation is updated
- [ ] Error handling is appropriate
- [ ] Code follows team standards and conventions

## Screenshots/Videos
<!-- If applicable, add screenshots or videos to demonstrate changes -->

## Additional Context
<!-- Add any other context or information reviewers should know -->
\end{lstlisting}

\section{CONTRIBUTING.md Template}
\label{app:contributing}

\begin{lstlisting}[style=markdown]
# Contributing to [Project Name]

Thank you for considering contributing to our project! This document outlines our development process and expectations.

## Table of Contents
- [Getting Started](#getting-started)
- [Development Workflow](#development-workflow)
- [Pull Request Process](#pull-request-process)
- [Code Standards](#code-standards)
- [Review Standards](#review-standards)
- [Communication](#communication)

## Getting Started

### Prerequisites
- Node.js 20+
- npm 10+
- Git 2.40+

### Setup
```bash
# Clone the repository
git clone https://github.com/org/repo.git
cd repo

# Install dependencies
npm install

# Run tests
npm test

# Start development server
npm run dev
```

### Running Tests
```bash
# Unit tests
npm test

# Integration tests
npm run test:integration

# Test coverage
npm run test:coverage

# Lint
npm run lint

# Type check
npm run type-check
```

## Development Workflow

### Branching Strategy
- `main` - production-ready code
- `feature/[name]` - new features
- `fix/[name]` - bug fixes
- `docs/[name]` - documentation updates

### Commit Messages
We follow [Conventional Commits](https://www.conventionalcommits.org/):

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Types:**
- `feat` - New feature
- `fix` - Bug fix
- `docs` - Documentation
- `style` - Formatting, no code change
- `refactor` - Code restructuring
- `perf` - Performance improvement
- `test` - Adding tests
- `chore` - Maintenance

**Example:**
```
feat(auth): add OAuth2 token refresh

Implement automatic token refresh with exponential backoff
retry logic.

Closes #123
```

## Pull Request Process

### Before Creating a PR

1. **Ensure CI passes locally**
   ```bash
   npm run lint
   npm test
   npm run type-check
   ```

2. **Rebase on latest main**
   ```bash
   git fetch origin
   git rebase origin/main
   ```

3. **Self-review your changes**
   - Read through the diff
   - Remove debug code
   - Check for console.logs or commented code

### PR Size Guidelines
- **Target:** 100-300 lines of changed code
- **Maximum:** 400 lines (larger PRs require justification)
- **If >400 lines:** Discuss decomposition strategy with team

### PR Template
Use the provided PR template and fill out all sections:
- Description and context
- Risk assessment
- Test plan
- Deployment considerations
- Reviewer checklist

### Review SLOs
- **First review:** Within 4 business hours for small PRs
- **Approval:** Within 1 business day for small PRs
- **Hotfixes:** Within 1 hour

## Code Standards

### Style Guide
- Follow existing code style
- Use Prettier for formatting (runs on commit)
- Use ESLint rules (blocking CI failures)

### File Organization
```
src/
  components/      # React components
  services/        # Business logic
  utils/           # Shared utilities
  types/           # TypeScript types
  __tests__/       # Tests co-located with code
```

### Testing Requirements
- **Unit test coverage:** >80% for new code
- **Integration tests:** For API endpoints and critical paths
- **Test naming:** `describe` blocks for grouping, `it` for specific behaviors
  
**Example:**
```typescript
describe('UserService', () => {
  describe('createUser', () => {
    it('should create user with valid data', () => {
      // test
    });
    
    it('should throw error for duplicate email', () => {
      // test
    });
  });
});
```

### Documentation
- **Code comments:** For complex logic, not obvious code
- **JSDoc:** For public APIs and exported functions
- **README:** Update if adding features or changing setup

## Review Standards

### What Reviewers Look For
1. **Correctness:** Does it work? Does it meet requirements?
2. **Design:** Is the approach sound? Is it maintainable?
3. **Tests:** Are edge cases covered? Are tests meaningful?
4. **Security:** Any vulnerabilities? Data validation?
5. **Performance:** Any obvious inefficiencies?
6. **Documentation:** Are changes documented?

### Providing Feedback
- **Be respectful and constructive**
- **Ask questions rather than making demands**
  - ✓ "Could we consider using X here because Y?"
  - ✗ "This is wrong, use X instead"
- **Distinguish blocking vs. non-blocking comments**
  - Blocking: "This has a security issue"
  - Non-blocking: "Consider renaming for clarity"
- **Approve explicitly:** Use GitHub's review feature

### Receiving Feedback
- **Assume good intent**
- **Ask for clarification if needed**
- **Respond to all comments** (even if just acknowledging)
- **Don't take it personally** - code review is about the code, not you

### Handling Disagreements
1. **Discuss in the PR** - explain your reasoning
2. **If unresolved** - involve tech lead or architect
3. **Document decision** - explain why approach was chosen
4. **Move forward** - don't let disagreements block progress unnecessarily

## Communication

### Getting Help
- **Slack:** #engineering channel for quick questions
- **GitHub Discussions:** For design discussions
- **Office Hours:** Tuesdays 2-3pm with tech leads

### Reporting Issues
Use GitHub Issues with:
- Clear title
- Steps to reproduce
- Expected vs. actual behavior
- Environment details

### Code of Conduct
- Be respectful and professional
- Welcome new contributors
- Focus on constructive feedback
- Assume good intent

## Review Process Details

### Approval Requirements
- **2 approvals** from team members
- **1 approval from CODEOWNERS** for specific files
- **All CI checks passing**
- **No unresolved discussions**

### Merge Process
1. Ensure all feedback is addressed
2. Get required approvals
3. Ensure CI is green
4. **Squash merge** (default) or rebase
5. Delete branch after merge

## Questions?

If you have questions about the contribution process, reach out to:
- Slack: #engineering
- Email: engineering@example.com
- GitHub Discussions

Thank you for contributing! 🎉
\end{lstlisting}

\section{GitHub Actions CI/CD Examples}
\label{app:cicd}

\subsection{Comprehensive PR Validation}

\begin{lstlisting}[style=yaml]
name: PR Validation

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

# Cancel previous runs when new commits pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Skip checks for draft PRs
  check-draft:
    runs-on: ubuntu-latest
    outputs:
      is-draft: ${{ steps.draft-check.outputs.is-draft }}
    steps:
      - id: draft-check
        run: |
          if [ "${{ github.event.pull_request.draft }}" = "true" ]; then
            echo "is-draft=true" >> $GITHUB_OUTPUT
          else
            echo "is-draft=false" >> $GITHUB_OUTPUT
          fi

  # Validate PR size
  pr-size-check:
    runs-on: ubuntu-latest
    needs: check-draft
    if: needs.check-draft.outputs.is-draft == 'false'
    steps:
      - uses: actions/checkout@v4
      
      - name: Check PR size
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const additions = pr.additions;
            const deletions = pr.deletions;
            const totalChanges = additions + deletions;
            
            const warningThreshold = 400;
            const errorThreshold = 1000;
            
            if (totalChanges > errorThreshold) {
              core.setFailed(
                `PR is too large (${totalChanges} LOC). ` +
                `Please consider splitting into smaller PRs. ` +
                `See CONTRIBUTING.md for guidelines.`
              );
            } else if (totalChanges > warningThreshold) {
              core.warning(
                `PR is large (${totalChanges} LOC). ` +
                `Consider splitting for faster review.`
              );
            }

  # Lint and format check
  lint:
    runs-on: ubuntu-latest
    needs: check-draft
    if: needs.check-draft.outputs.is-draft == 'false'
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run ESLint
        run: npm run lint
      
      - name: Check formatting
        run: npm run format:check

  # Type checking
  type-check:
    runs-on: ubuntu-latest
    needs: check-draft
    if: needs.check-draft.outputs.is-draft == 'false'
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Type check
        run: npm run type-check

  # Unit and integration tests
  test:
    runs-on: ubuntu-latest
    needs: check-draft
    if: needs.check-draft.outputs.is-draft == 'false'
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm test -- --coverage --ci
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/lcov.info
          flags: unittests
          fail_ci_if_error: true
      
      - name: Check coverage threshold
        run: |
          npm run test:coverage-check || {
            echo "Coverage below threshold"
            exit 1
          }

  # Security scanning
  security:
    runs-on: ubuntu-latest
    needs: check-draft
    if: needs.check-draft.outputs.is-draft == 'false'
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run npm audit
        run: npm audit --audit-level=moderate
      
      - name: Run Snyk security scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high
      
      - name: Secret scanning
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.pull_request.base.sha }}
          head: ${{ github.event.pull_request.head.sha }}

  # Build check
  build:
    runs-on: ubuntu-latest
    needs: check-draft
    if: needs.check-draft.outputs.is-draft == 'false'
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build
        run: npm run build
      
      - name: Check bundle size
        uses: andresz1/size-limit-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}

  # All checks passed
  all-checks:
    runs-on: ubuntu-latest
    needs: [pr-size-check, lint, type-check, test, security, build]
    if: always()
    steps:
      - name: Check if all jobs succeeded
        run: |
          if [ "${{ contains(needs.*.result, 'failure') }}" = "true" ]; then
            echo "Some checks failed"
            exit 1
          fi
          echo "All checks passed!"
\end{lstlisting}

\subsection{Auto-Merge for Dependabot}

\begin{lstlisting}[style=yaml]
name: Dependabot Auto-Merge

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  pull-requests: write
  contents: write

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: |
      github.actor == 'dependabot[bot]' &&
      github.event_name == 'pull_request'
    steps:
      - name: Fetch PR metadata
        id: metadata
        uses: dependabot/fetch-metadata@v1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Auto-approve minor and patch updates
        if: |
          steps.metadata.outputs.update-type == 'version-update:semver-minor' ||
          steps.metadata.outputs.update-type == 'version-update:semver-patch'
        run: |
          gh pr review --approve "$PR_URL"
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Enable auto-merge for minor and patch
        if: |
          steps.metadata.outputs.update-type == 'version-update:semver-minor' ||
          steps.metadata.outputs.update-type == 'version-update:semver-patch'
        run: |
          gh pr merge --auto --squash "$PR_URL"
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Comment on major updates
        if: steps.metadata.outputs.update-type == 'version-update:semver-major'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '⚠️ This is a **major version update**. Please review changelog and test thoroughly before merging.'
            })
\end{lstlisting}

\section{Metrics Dashboard Query Examples}
\label{app:metrics}

\subsection{GitHub GraphQL Queries}

\subsubsection{PR Velocity Metrics}

\begin{lstlisting}[style=yaml]
query PRVelocityMetrics($owner: String!, $repo: String!, $since: DateTime!) {
  repository(owner: $owner, name: $repo) {
    pullRequests(
      first: 100
      orderBy: {field: CREATED_AT, direction: DESC}
      states: [MERGED]
      baseRefName: "main"
    ) {
      nodes {
        number
        title
        createdAt
        mergedAt
        additions
        deletions
        changedFiles
        reviews(first: 10) {
          totalCount
          nodes {
            submittedAt
            state
          }
        }
        timelineItems(first: 1, itemTypes: [READY_FOR_REVIEW_EVENT]) {
          nodes {
            ... on ReadyForReviewEvent {
              createdAt
            }
          }
        }
        commits {
          totalCount
        }
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
}
\end{lstlisting}

\subsubsection{Review Workload Distribution}

\begin{lstlisting}[style=yaml]
query ReviewWorkload($owner: String!, $repo: String!, $since: DateTime!) {
  repository(owner: $owner, name: $repo) {
    pullRequests(
      first: 100
      orderBy: {field: CREATED_AT, direction: DESC}
      states: [MERGED, OPEN]
    ) {
      nodes {
        reviews(first: 50) {
          nodes {
            author {
              login
            }
            submittedAt
            state
            comments {
              totalCount
            }
          }
        }
        reviewRequests(first: 10) {
          nodes {
            requestedReviewer {
              ... on User {
                login
              }
            }
          }
        }
      }
    }
  }
}
\end{lstlisting}

\subsection{Analysis Scripts}

\subsubsection{Calculate Time-to-Merge Statistics}

\begin{lstlisting}[language=Python]
import json
from datetime import datetime
import statistics

def analyze_pr_velocity(prs):
    """Calculate PR velocity metrics"""
    time_to_first_review = []
    time_to_merge = []
    pr_sizes = []
    
    for pr in prs:
        created = datetime.fromisoformat(
            pr['createdAt'].replace('Z', '+00:00')
        )
        merged = datetime.fromisoformat(
            pr['mergedAt'].replace('Z', '+00:00')
        )
        
        # Time to merge
        ttm = (merged - created).total_seconds() / 3600  # hours
        time_to_merge.append(ttm)
        
        # PR size
        size = pr['additions'] + pr['deletions']
        pr_sizes.append(size)
        
        # Time to first review
        reviews = pr['reviews']['nodes']
        if reviews:
            first_review = min(
                datetime.fromisoformat(r['submittedAt'].replace('Z', '+00:00'))
                for r in reviews
            )
            ttfr = (first_review - created).total_seconds() / 3600
            time_to_first_review.append(ttfr)
    
    return {
        'time_to_merge': {
            'median': statistics.median(time_to_merge),
            'p90': statistics.quantiles(time_to_merge, n=10)[8],
            'p99': statistics.quantiles(time_to_merge, n=100)[98],
        },
        'time_to_first_review': {
            'median': statistics.median(time_to_first_review),
            'p90': statistics.quantiles(time_to_first_review, n=10)[8],
        },
        'pr_size': {
            'median': statistics.median(pr_sizes),
            'p90': statistics.quantiles(pr_sizes, n=10)[8],
        },
        'total_prs': len(prs),
    }

# Usage
with open('pr_data.json') as f:
    data = json.load(f)
    prs = data['data']['repository']['pullRequests']['nodes']
    metrics = analyze_pr_velocity(prs)
    print(json.dumps(metrics, indent=2))
\end{lstlisting}

\section{References and Further Reading}
\label{app:references}

\subsection{Industry Research}

\begin{itemize}[leftmargin=*]
    \item \textbf{DORA Metrics}. "Accelerate: State of DevOps Reports" (2019--2024). Comprehensive research on software delivery performance.
    
    \item \textbf{Google Engineering Practices}. "Code Review Developer Guide" (2020). Best practices from Google's engineering org.
    
    \item \textbf{Microsoft Research}. "Code Reviews Do Not Find Bugs: How the Current Code Review Best Practice Slows Us Down" (2015). Analysis of 1M+ code reviews.
    
    \item \textbf{SmartBear}. "Best Practices for Peer Code Review" (2024). Industry survey of 600+ developers.
\end{itemize}

\subsection{Tools and Platforms}

\begin{itemize}[leftmargin=*]
    \item \textbf{Graphite}: \url{https://graphite.dev} --- Stacked PR workflows
    \item \textbf{GitHub Actions}: \url{https://docs.github.com/actions} --- CI/CD automation
    \item \textbf{Dependabot}: \url{https://github.com/dependabot} --- Dependency updates
    \item \textbf{CodeQL}: \url{https://codeql.github.com} --- Static analysis and security
    \item \textbf{Codecov}: \url{https://codecov.io} --- Code coverage tracking
\end{itemize}

\subsection{Books}

\begin{itemize}[leftmargin=*]
    \item Forsgren, N., Humble, J., \& Kim, G. (2018). \textit{Accelerate: The Science of Lean Software and DevOps}. IT Revolution Press.
    
    \item Kim, G., Debois, P., Willis, J., \& Humble, J. (2016). \textit{The DevOps Handbook}. IT Revolution Press.
    
    \item Winters, T., Manshreck, T., \& Wright, H. (2020). \textit{Software Engineering at Google}. O'Reilly Media.
\end{itemize}

% ============================================================================
% END DOCUMENT
% ============================================================================
\end{document}
