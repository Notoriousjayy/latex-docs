\documentclass[11pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{url}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{tcolorbox}

\hypersetup{
  colorlinks=true,
  linkcolor=blue!70!black,
  urlcolor=blue!70!black,
  citecolor=blue!70!black,
  pdftitle={Event-Driven Integration Blueprint: ServiceNow + GitHub Security Products},
  pdfauthor={AppSec / SecOps Engineering},
  pdfsubject={Security Integration Architecture}
}

% ---------- Color Definitions ----------
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{codered}{rgb}{0.8,0.1,0.1}
\definecolor{codeblue}{rgb}{0.1,0.1,0.8}
\definecolor{backcolour}{rgb}{0.97,0.97,0.97}
\definecolor{warningbg}{RGB}{255,250,230}
\definecolor{warningborder}{RGB}{255,193,7}
\definecolor{infobg}{RGB}{230,247,255}
\definecolor{infoborder}{RGB}{0,123,255}
\definecolor{successbg}{RGB}{230,255,230}
\definecolor{successborder}{RGB}{40,167,69}

% ---------- Listings Configurations ----------
\lstdefinelanguage{yaml}{
  keywords={true,false,null,y,n},
  keywordstyle=\color{codeblue}\bfseries,
  basicstyle=\ttfamily\small,
  sensitive=false,
  comment=[l]{\#},
  commentstyle=\color{codegray}\ttfamily,
  stringstyle=\color{codegreen}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinelanguage{JavaScript}{
  keywords={break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,in,instanceof,let,new,return,super,switch,this,throw,try,typeof,var,void,while,with,yield,async,await,of},
  ndkeywords={true,false,null,undefined},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]"
}

\lstdefinelanguage{TypeScript}[]{JavaScript}{
  morekeywords={interface,type,enum,implements,public,private,protected,readonly,namespace,abstract,as,unknown,never,any,boolean,number,string,symbol,bigint,asserts,satisfies},
}



\lstdefinelanguage{json}{
  basicstyle=\ttfamily\small,
  stringstyle=\color{codegreen}\ttfamily,
  commentstyle=\color{codegray}\ttfamily,
  morestring=[b]",
  literate=
    *{:}{{{\color{codepurple}:}}}{1}
    {,}{{{\color{codepurple},}}}{1}
    {\{}{{{\color{codeblue}\{}}}{1}
    {\}}{{{\color{codeblue}\}}}}{1}
    {[}{{{\color{codeblue}[}}}{1}
    {]}{{{\color{codeblue}]}}}{1}
}

\lstdefinestyle{codestyle}{
  backgroundcolor=\color{backcolour},
  basicstyle=\ttfamily\small,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{codegreen},
  frame=single,
  framesep=3pt,
  keepspaces=true,
  keywordstyle=\color{codeblue}\bfseries,
  numbers=left,
  numbersep=8pt,
  numberstyle=\tiny\color{codegray},
  rulecolor=\color{black!20},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stringstyle=\color{codered},
  tabsize=2,
  xleftmargin=2em,
  framexleftmargin=1.5em
}

\lstset{style=codestyle}

% ---------- TColorBox Environments ----------
\newtcolorbox{warningbox}{
  colback=warningbg,
  colframe=warningborder,
  fonttitle=\bfseries,
  title=Warning,
  sharp corners,
  boxrule=1pt,
  left=5pt,
  right=5pt,
  top=3pt,
  bottom=3pt
}

\newtcolorbox{infobox}{
  colback=infobg,
  colframe=infoborder,
  fonttitle=\bfseries,
  title=Note,
  sharp corners,
  boxrule=1pt,
  left=5pt,
  right=5pt,
  top=3pt,
  bottom=3pt
}

\newtcolorbox{successbox}{
  colback=successbg,
  colframe=successborder,
  fonttitle=\bfseries,
  title=Best Practice,
  sharp corners,
  boxrule=1pt,
  left=5pt,
  right=5pt,
  top=3pt,
  bottom=3pt
}

% ---------- Header/Footer ----------
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small ServiceNow + GitHub Security Integration}
\fancyhead[R]{\small v2.0 --- January 2026}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

\titleformat{\section}{\Large\bfseries}{\thesection}{0.75em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{0.75em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{0.5em}{}

\title{
  \vspace{-1cm}
  \textbf{Event-Driven Integration Blueprint}\\[0.5em]
  \Large ServiceNow + GitHub Secret Protection \& Code Security\\[0.3em]
  \large Dependabot, Code Scanning, Secret Scanning, and\\Security Campaign Automation
}
\author{
  Prepared for Internal AppSec / SecOps Enablement\\
  \small Architecture \& Engineering Reference
}
\date{Version 2.0 --- Updated: January 14, 2026}

\begin{document}
\maketitle

\begin{abstract}
\noindent This document provides a comprehensive architectural blueprint for integrating GitHub's security products (Secret Protection and Code Security, formerly bundled as GitHub Advanced Security) with ServiceNow's Vulnerability Response and Application Vulnerability Response modules. The integration enables automated intake, triage, assignment, SLA enforcement, and remediation tracking for Dependabot alerts, Code Scanning alerts, and Secret Scanning alerts through event-driven webhook processing, REST API reconciliation, and native ServiceNow integration patterns.

\vspace{0.5em}
\noindent \textbf{Key Updates (2025--2026):} This revision incorporates GitHub's April 2025 product unbundling into GitHub Secret Protection and GitHub Code Security, the November 2025 GA release of alert assignees and security campaigns with corresponding webhook and REST API support, enhanced Copilot Autofix integration, and updated ServiceNow GitHub Application Vulnerability Integration capabilities.
\end{abstract}

\tableofcontents
\newpage

% ===========================
\section{Executive Summary}
\label{sec:executive-summary}

An event-driven system integrating ServiceNow and GitHub's security products can be implemented to automate the complete vulnerability management lifecycle for:

\begin{itemize}[leftmargin=1.5em]
  \item \textbf{Dependabot alerts} --- Software Composition Analysis (SCA) covering dependency vulnerabilities, with automated PR generation and auto-merge capabilities for low-risk updates
  \item \textbf{Code Scanning alerts} --- Static Application Security Testing (SAST) powered by CodeQL and third-party SARIF-producing tools, now with GA Copilot Autofix suggestions and alert assignees
  \item \textbf{Secret Scanning alerts} --- Credential exposure detection including push protection bypass events, AI-powered detection, validity checking, and security campaigns for coordinated remediation
\end{itemize}

GitHub provides first-class webhook events for these alert families (\texttt{dependabot\_alert}, \texttt{code\_scanning\_alert}, \texttt{secret\_scanning\_alert}) and mandates validating deliveries using the \texttt{X-Hub-Signature-256} HMAC header.\footnote{\url{https://docs.github.com/en/webhooks/using-webhooks/validating-webhook-deliveries}}

\begin{infobox}
\textbf{Product Evolution (April 2025):} GitHub Advanced Security (GHAS) has been unbundled into two standalone products:
\begin{itemize}[leftmargin=1.5em, topsep=0pt]
  \item \textbf{GitHub Secret Protection} (\$19/month per active committer) --- push protection, secret scanning, AI-powered detection, validity checking
  \item \textbf{GitHub Code Security} (\$30/month per active committer) --- code scanning, Copilot Autofix, security campaigns, Dependency Review Action
\end{itemize}
Both products are now available to GitHub Team plan customers without requiring GitHub Enterprise.\footnote{\url{https://github.blog/changelog/2025-03-04-introducing-github-secret-protection-and-github-code-security/}}
\end{infobox}

On the ServiceNow side, the \textbf{GitHub Application Vulnerability Integration} (via the ServiceNow Store) provides the most direct path to import findings into \textbf{Vulnerability Response} / \textbf{Application Vulnerability Response} and manage remediation workflows at scale.\footnote{\url{https://store.servicenow.com/store/app/006dafe21b646a50a85b16db234bcba2}}

\subsection{Recommended Strategy: Hybrid Architecture}
\label{subsec:hybrid-strategy}

A production-grade design employs a \textbf{hybrid} approach combining three complementary integration patterns:

\begin{enumerate}[leftmargin=1.5em]
  \item \textbf{Baseline Ingestion} --- Official ServiceNow integration application for authoritative normalization, deduplication, GHSA-to-CVE mapping, and SecOps domain model alignment
  \item \textbf{Event-Driven Updates} --- GitHub webhooks into a hardened receiver (API Gateway, cloud function, or ServiceNow Scripted REST API) for immediate routing, assignment, security campaign synchronization, and workflow triggers
  \item \textbf{Reconciliation Polling} --- Scheduled jobs using GitHub REST APIs to detect missed events, synchronize assignee changes, campaign status updates, and ensure state convergence
\end{enumerate}

This approach preserves OOTB integration benefits while achieving near-real-time automation with provable correctness.

% ===========================
\section{Target Outcomes and Non-Functional Requirements}
\label{sec:outcomes-nfrs}

\subsection{Operational Outcomes}
\label{subsec:operational-outcomes}

\begin{itemize}[leftmargin=1.5em]
  \item \textbf{Time-to-triage reduction}: Automated classification, routing, and prioritization at ingestion with sub-minute latency for critical alerts
  \item \textbf{SLA enforcement}: Deterministic due dates based on severity, exploitability (EPSS), asset criticality, and alert type (secrets typically warrant shortest SLAs)
  \item \textbf{Automated lifecycle tracking}: State synchronization (open $\rightarrow$ in-progress $\rightarrow$ fixed/dismissed) bidirectionally between GitHub and ServiceNow
  \item \textbf{Security campaign orchestration}: Synchronized campaign status, deadlines, and assignee notifications across both platforms
  \item \textbf{Audit-grade traceability}: Immutable event log of alert state transitions, assignment changes, and workflow actions with correlation IDs
  \item \textbf{Copilot Autofix integration}: Track autofix suggestions, acceptance rates, and time-to-remediation metrics
\end{itemize}

\subsection{Non-Functional Requirements (NFRs)}
\label{subsec:nfrs}

\begin{longtable}{@{}p{0.20\textwidth}p{0.75\textwidth}@{}}
\toprule
\textbf{Category} & \textbf{Requirements} \\
\midrule
\textbf{Security} & 
\begin{itemize}[leftmargin=1em, topsep=0pt, itemsep=0pt]
  \item HMAC-SHA256 signature verification for all webhook deliveries
  \item Least-privilege GitHub App tokens with fine-grained permissions
  \item Secrets vaulting (never log secret values from secret scanning)
  \item OAuth 2.0 / mutual TLS for ServiceNow API authentication
  \item IP allow-listing and WAF protection for webhook endpoints
\end{itemize} \\
\midrule
\textbf{Reliability} & 
\begin{itemize}[leftmargin=1em, topsep=0pt, itemsep=0pt]
  \item Idempotent processing using \texttt{X-GitHub-Delivery} and canonical alert keys
  \item Exponential backoff retries with jitter
  \item Dead-letter queues (DLQ) with alerting and manual replay capability
  \item At-least-once delivery guarantee with deduplication
\end{itemize} \\
\midrule
\textbf{Scalability} & 
\begin{itemize}[leftmargin=1em, topsep=0pt, itemsep=0pt]
  \item Burst handling for webhook storms (large codebase scans)
  \item Queue-based backpressure with configurable concurrency
  \item GitHub API rate limit awareness (5,000 requests/hour for Apps)
  \item Horizontal scaling of webhook processors
\end{itemize} \\
\midrule
\textbf{Maintainability} & 
\begin{itemize}[leftmargin=1em, topsep=0pt, itemsep=0pt]
  \item Clear ownership boundaries: GitHub config / integration code / ServiceNow workflows
  \item Version-controlled mapping rules and transformation logic
  \item Staged rollout capability with canary repositories
  \item Comprehensive logging and distributed tracing
\end{itemize} \\
\bottomrule
\end{longtable}

% ===========================
\section{Reference Architecture}
\label{sec:reference-architecture}

\subsection{High-Level Component Diagram}
\label{subsec:component-diagram}

The integration architecture consists of five primary layers:

\begin{enumerate}[leftmargin=1.5em]
  \item \textbf{Source Layer (GitHub)}
    \begin{itemize}[leftmargin=1.5em]
      \item GitHub Secret Protection (secret scanning, push protection)
      \item GitHub Code Security (CodeQL, code scanning, Copilot Autofix)
      \item Dependabot (dependency vulnerability alerts, automated PRs)
      \item Security Campaigns (coordinated remediation initiatives)
    \end{itemize}
  
  \item \textbf{Transport Layer (Webhooks + APIs)}
    \begin{itemize}[leftmargin=1.5em]
      \item Outbound webhooks with HMAC signatures
      \item REST API v3 for reconciliation and bidirectional sync
      \item GraphQL API for complex queries and bulk operations
    \end{itemize}
  
  \item \textbf{Ingestion Layer (Webhook Receiver)}
    \begin{itemize}[leftmargin=1.5em]
      \item Signature validation and request authentication
      \item Event normalization and enrichment
      \item Durable queue publication (SQS, Pub/Sub, Azure Service Bus)
      \item DLQ handling and replay infrastructure
    \end{itemize}
  
  \item \textbf{Processing Layer (Integration Services)}
    \begin{itemize}[leftmargin=1.5em]
      \item Event transformation and mapping
      \item ServiceNow API client with retry logic
      \item Reconciliation scheduler
      \item Metrics and observability collection
    \end{itemize}
  
  \item \textbf{Destination Layer (ServiceNow)}
    \begin{itemize}[leftmargin=1.5em]
      \item Scripted REST API or IntegrationHub endpoint
      \item Vulnerability Response / Application Vulnerability Response
      \item Flow Designer workflows for automation
      \item CMDB integration for asset correlation
    \end{itemize}
\end{enumerate}

\subsection{Data Flow: Event Path (Near Real-Time)}
\label{subsec:event-path}

\begin{enumerate}[leftmargin=1.5em]
  \item GitHub emits a webhook delivery on alert lifecycle changes:
    \begin{itemize}[leftmargin=1.5em]
      \item \textbf{Code Scanning}: \texttt{created}, \texttt{reopened}, \texttt{closed\_by\_user}, \texttt{fixed}, \texttt{appeared\_in\_branch}, \texttt{reopened\_by\_user}
      \item \textbf{Secret Scanning}: \texttt{created}, \texttt{resolved}, \texttt{revoked}, \texttt{reopened}, \texttt{validated} (validity status change)
      \item \textbf{Dependabot}: \texttt{created}, \texttt{dismissed}, \texttt{fixed}, \texttt{reintroduced}, \texttt{auto\_dismissed}, \texttt{auto\_reopened}
      \item \textbf{New (2025)}: Alert assignee changes trigger webhook events for both code scanning and secret scanning alerts\footnote{\url{https://github.blog/changelog/2025-12-16-code-scanning-alert-assignees-are-now-generally-available/}}
    \end{itemize}
  
  \item The \textbf{Webhook Receiver} validates:
    \begin{itemize}[leftmargin=1.5em]
      \item HMAC signature via \texttt{X-Hub-Signature-256} header
      \item Event type via \texttt{X-GitHub-Event} header
      \item Unique delivery ID via \texttt{X-GitHub-Delivery} header
      \item Optional: IP allow-list against GitHub's webhook IP ranges
    \end{itemize}
  
  \item Receiver publishes normalized event to durable queue with metadata:
    \begin{itemize}[leftmargin=1.5em]
      \item Original payload (optionally redacted for secrets)
      \item Computed canonical alert key
      \item Received timestamp and processing priority
    \end{itemize}
  
  \item ServiceNow consumer processes the event:
    \begin{itemize}[leftmargin=1.5em]
      \item Idempotent upsert into staging/event table
      \item Map to Vulnerability Response domain objects
      \item Trigger Flow Designer subflows for triage, assignment, and SLA
      \item Update GitHub alert state/assignee if bidirectional sync enabled
    \end{itemize}
\end{enumerate}

\subsection{Data Flow: Baseline Path (Authoritative Ingestion)}
\label{subsec:baseline-path}

The ServiceNow \textbf{GitHub Application Vulnerability Integration} provides:

\begin{itemize}[leftmargin=1.5em]
  \item \textbf{Code Scanning Integration}: SAST data import with rule metadata, CWE mapping, and CVSS enrichment
  \item \textbf{Dependabot Integration}: SCA data with advisory severity, GHSA-to-CVE correlation, and remediation guidance
  \item \textbf{Secret Scanning Integration}: Credential exposure findings with secret type, validity status, and location metadata
  \item \textbf{Recent Improvements (2025)}: Enhanced GHSA ID fallback when CVE is absent, improved delta sync for Dependabot alerts using sort field parameters\footnote{\url{https://store.servicenow.com/store/app/006dafe21b646a50a85b16db234bcba2}}
\end{itemize}

\begin{successbox}
\textbf{Hybrid Approach Rationale}: GitHub's integration guidance recommends webhooks for long-term metric collection and real-time alerting, while REST APIs provide point-in-time snapshots requiring polling infrastructure. The ServiceNow integration app provides optimal alignment to SecOps data models. Combining both yields speed \emph{and} correctness.
\end{successbox}

% ===========================
\section{Integration Patterns and Selection Criteria}
\label{sec:integration-patterns}

\subsection{Pattern A: OOTB Import-Driven (Scheduled)}
\label{subsec:pattern-a}

\textbf{Use when:} Fastest time-to-value is priority and minutes-to-hours latency is acceptable for non-critical alerts.

\textbf{Mechanism:} Configure the GitHub Application Vulnerability Integration to ingest findings on a scheduled cadence (hourly, daily).

\textbf{Strengths:}
\begin{itemize}[leftmargin=1.5em]
  \item Normalized ingestion with GHSA/CVE deduplication
  \item Native SecOps workflows (assignment, exception handling, false positives)
  \item Minimal custom code; vendor-supported upgrade path
  \item Automatic CWE and CVSS enrichment
\end{itemize}

\textbf{Limitations:}
\begin{itemize}[leftmargin=1.5em]
  \item Not truly event-driven; insufficient for rapid-response use cases
  \item Secret exposure may remain unaddressed for hours
  \item No support for real-time assignee or campaign synchronization
\end{itemize}

\subsection{Pattern B: Webhook-First Event Processing}
\label{subsec:pattern-b}

\textbf{Use when:} Near-real-time automation is required (seconds to minutes latency).

\textbf{Mechanism:} Configure organization or repository webhooks for security alert events:
\begin{itemize}[leftmargin=1.5em]
  \item \texttt{code\_scanning\_alert}
  \item \texttt{dependabot\_alert}
  \item \texttt{secret\_scanning\_alert}
  \item \texttt{security\_and\_analysis} (for enablement/disablement tracking)
\end{itemize}

\textbf{Strengths:}
\begin{itemize}[leftmargin=1.5em]
  \item Immediate alerting, incident creation, and paging/escalation
  \item Avoids API polling overhead and rate limit consumption
  \item Supports real-time assignee and campaign synchronization
  \item Can trigger lightweight workflows without waiting for import cadence
\end{itemize}

\textbf{Limitations:}
\begin{itemize}[leftmargin=1.5em]
  \item Requires idempotency and replay design
  \item Possible missed deliveries without reconciliation
  \item More complex infrastructure requirements
\end{itemize}

\subsection{Pattern C: Webhooks + Queue + Reconciliation (Recommended)}
\label{subsec:pattern-c}

\textbf{Use when:} Near-real-time processing \emph{and} provable correctness are both required.

\textbf{Mechanism:}
\begin{itemize}[leftmargin=1.5em]
  \item Webhooks for instant triggers with acknowledgment within 10 seconds
  \item Durable message queue (SQS, Pub/Sub, Service Bus) with DLQ
  \item Periodic REST reconciliation for convergence (every 15--60 minutes)
  \item Security campaign status sync via REST API
\end{itemize}

\begin{warningbox}
For \textbf{secret scanning alerts}, always err on the side of immediate action. Leaked credentials can be exploited within minutes of exposure. Pattern C is strongly recommended for any deployment handling secret scanning.
\end{warningbox}

% ===========================
\section{Data Model Mapping}
\label{sec:data-model}

\subsection{ServiceNow Domain Objects}
\label{subsec:servicenow-domain}

ServiceNow Vulnerability Response uses the following core tables:

\begin{itemize}[leftmargin=1.5em]
  \item \textbf{Vulnerable Items} (\texttt{sn\_vul\_vulnerable\_item}): Infrastructure-style vulnerabilities tied to CIs
  \item \textbf{Application Vulnerable Items} (\texttt{sn\_vul\_app\_vulnerable\_item}): Application-scoped findings from third-party scanners
  \item \textbf{Third-Party Vulnerabilities} (\texttt{sn\_vul\_third\_party\_entry}): External vulnerability definitions (CVE, GHSA, CWE)
  \item \textbf{Vulnerability Groups}: Logical groupings for bulk operations and reporting
\end{itemize}

The GitHub Application Vulnerability Integration maps findings to Application Vulnerable Items with proper third-party entry linkage.

\subsection{Canonical Alert Identifier}
\label{subsec:canonical-identifier}

Define a deterministic, unique identifier for idempotent upserts:

\begin{lstlisting}[language=json,caption={Canonical Alert Key Format}]
{
  "format": "<provider>:<org>/<repo>:<alert_type>:<alert_number>",
  "examples": [
    "github:acme/payments:dependabot:1234",
    "github:acme/api-gateway:code_scanning:5678",
    "github:acme/infrastructure:secret_scanning:9012"
  ]
}
\end{lstlisting}

Store this key in:
\begin{itemize}[leftmargin=1.5em]
  \item Custom event staging table (\texttt{x\_ghas\_event})
  \item External reference field on the target SecOps record
  \item Correlation ID for bidirectional synchronization
\end{itemize}

\subsection{State Mapping Matrix}
\label{subsec:state-mapping}

\begin{longtable}{@{}p{0.22\textwidth}p{0.25\textwidth}p{0.48\textwidth}@{}}
\toprule
\textbf{GitHub Status} & \textbf{ServiceNow State} & \textbf{Automation Actions} \\
\midrule
\texttt{open} / \texttt{active} & Open / New & Create or reopen task; start SLA clock; assign to owner \\
\midrule
\texttt{dismissed} & Risk Accepted / False Positive / Exception & Require documented reason; risk acceptance owner approval; set expiration date; record compensating controls \\
\midrule
\texttt{fixed} / \texttt{resolved} & Resolved & Validate via PR merge, dependency update, or secret rotation; stop SLA clock; update metrics \\
\midrule
\texttt{reopened} & Reopened & Re-trigger assignment; recalculate SLA; notify original assignee \\
\midrule
\texttt{auto\_dismissed} & Auto-Closed (Dependency) & Record auto-dismissal reason; no manual action required \\
\midrule
\texttt{reintroduced} & Reopened (Regression) & High-priority flag; escalate if repeat occurrence \\
\bottomrule
\end{longtable}

\subsection{Alert Assignee Mapping (New 2025)}
\label{subsec:assignee-mapping}

With alert assignees now GA for both code scanning and secret scanning:

\begin{lstlisting}[language=json,caption={Assignee Synchronization Payload Structure}]
{
  "alert_key": "github:acme/api:code_scanning:1234",
  "assignees": [
    {
      "github_login": "jsmith",
      "servicenow_user": "john.smith@acme.com",
      "assigned_at": "2026-01-14T10:30:00Z",
      "assigned_by": "security-bot"
    }
  ],
  "sync_direction": "github_to_servicenow",
  "last_synced": "2026-01-14T10:30:05Z"
}
\end{lstlisting}

% ===========================
\section{GitHub Configuration}
\label{sec:github-config}

\subsection{Webhook Events to Enable}
\label{subsec:webhook-events}

At minimum, enable these webhook events at the organization level:

\begin{lstlisting}[language=yaml,caption={Required Webhook Events}]
webhook_events:
  # Core security alert events
  - code_scanning_alert      # SAST findings lifecycle
  - dependabot_alert         # SCA/dependency vulnerabilities
  - secret_scanning_alert    # Credential exposure detection
  
  # Supplementary events (recommended)
  - security_and_analysis    # Feature enablement changes
  - repository_advisory      # Private vulnerability reports
  
  # CI/CD correlation (optional)
  - check_run                # CodeQL analysis completion
  - workflow_run             # Security workflow status
\end{lstlisting}

\subsection{Webhook Security Controls}
\label{subsec:webhook-security}

\begin{enumerate}[leftmargin=1.5em]
  \item \textbf{Configure webhook secret}: Generate a cryptographically strong secret (minimum 32 characters):
    \begin{lstlisting}[language=bash,caption={Generate Webhook Secret}]
openssl rand -base64 32
    \end{lstlisting}
  
  \item \textbf{Validate X-Hub-Signature-256}: GitHub computes HMAC-SHA256 of the payload body using your secret
  
  \item \textbf{Log X-GitHub-Delivery}: Unique UUID for each delivery; use for deduplication and replay tracking
  
  \item \textbf{Verify X-GitHub-Event}: Ensure event type matches expected values to prevent injection
  
  \item \textbf{Optional IP filtering}: GitHub publishes webhook IP ranges via the Meta API
\end{enumerate}

\subsection{GitHub App Authentication (Recommended)}
\label{subsec:github-app-auth}

For production integrations, use a GitHub App instead of personal access tokens:

\begin{lstlisting}[language=yaml,caption={GitHub App Required Permissions}]
github_app_permissions:
  repository_permissions:
    # Read access for alert data
    security_events: read
    contents: read
    metadata: read
    
    # Write access for bidirectional sync
    security_events: write  # To update alert state/assignees
    
  organization_permissions:
    # For org-wide alert access
    organization_administration: read
    
  webhook_events:
    - code_scanning_alert
    - dependabot_alert
    - secret_scanning_alert
    - security_and_analysis
\end{lstlisting}

\textbf{Benefits of GitHub App}:
\begin{itemize}[leftmargin=1.5em]
  \item Higher rate limits (5,000 requests/hour vs 5,000/hour for PATs)
  \item Fine-grained permissions scoped to specific repositories
  \item Installation tokens with short TTL (1 hour)
  \item Better audit trail and revocation capabilities
  \item No dependency on individual user accounts
\end{itemize}

\subsection{REST APIs for Reconciliation}
\label{subsec:rest-apis}

These endpoints support periodic snapshots and repair:

\begin{longtable}{@{}p{0.25\textwidth}p{0.70\textwidth}@{}}
\toprule
\textbf{Alert Type} & \textbf{API Endpoint} \\
\midrule
Code Scanning & \texttt{GET /repos/\{owner\}/\{repo\}/code-scanning/alerts} \\
 & \texttt{GET /orgs/\{org\}/code-scanning/alerts} \\
\midrule
Secret Scanning & \texttt{GET /repos/\{owner\}/\{repo\}/secret-scanning/alerts} \\
 & \texttt{GET /orgs/\{org\}/secret-scanning/alerts} \\
\midrule
Dependabot & \texttt{GET /repos/\{owner\}/\{repo\}/dependabot/alerts} \\
 & \texttt{GET /orgs/\{org\}/dependabot/alerts} \\
\midrule
Security Campaigns & \texttt{GET /orgs/\{org\}/security-campaigns} (New 2025) \\
\bottomrule
\end{longtable}

% ===========================
\section{ServiceNow Configuration}
\label{sec:servicenow-config}

\subsection{Baseline: GitHub Application Vulnerability Integration}
\label{subsec:servicenow-baseline}

Install and configure from the ServiceNow Store:

\begin{enumerate}[leftmargin=1.5em]
  \item Navigate to \textbf{System Applications} $\rightarrow$ \textbf{All Available Applications} $\rightarrow$ \textbf{All}
  \item Search for ``GitHub Application Vulnerability Integration''
  \item Install the application (requires SecOps license)
  \item Configure credentials:
    \begin{itemize}[leftmargin=1.5em]
      \item Create a Connection record with GitHub App credentials
      \item Configure organization scope and repository filters
      \item Set import schedule (recommended: hourly for critical repos)
    \end{itemize}
\end{enumerate}

\subsection{Event-Driven Inbound Options}
\label{subsec:inbound-options}

\subsubsection{Option 1: External Receiver (Recommended)}

Deploy a hardened webhook receiver outside ServiceNow:

\begin{itemize}[leftmargin=1.5em]
  \item \textbf{Infrastructure}: API Gateway (AWS, Azure, GCP) + serverless function
  \item \textbf{Responsibilities}: Signature validation, rate limiting, queue publication
  \item \textbf{Benefits}: Enhanced security, independent scaling, multi-region support
  \item \textbf{ServiceNow integration}: Authenticated REST call with OAuth bearer token
\end{itemize}

\subsubsection{Option 2: ServiceNow Scripted REST API}

Direct webhook endpoint within ServiceNow:

\begin{itemize}[leftmargin=1.5em]
  \item \textbf{Use case}: Simpler deployments, moderate volumes
  \item \textbf{Requirements}: Strict ACLs, signature verification, async processing
  \item \textbf{Limitation}: ServiceNow must respond within webhook timeout
\end{itemize}

\subsubsection{Option 3: IntegrationHub with External Trigger}

Leverage ServiceNow's IntegrationHub:

\begin{itemize}[leftmargin=1.5em]
  \item Create External Trigger Definition tied to Flow Designer flow
  \item Configure authentication (OAuth, API Key, mutual TLS)
  \item Use GitHub Spoke for bidirectional management where available
\end{itemize}

\subsection{Recommended ServiceNow Workflow Components}
\label{subsec:workflow-components}

\begin{lstlisting}[language=yaml,caption={Flow Designer Subflow Architecture}]
flow_designer_subflows:
  # Inbound Processing
  - name: ProcessGHASWebhookEvent
    trigger: External Trigger / Scripted REST
    actions:
      - ValidatePayload
      - ComputeCanonicalKey
      - UpsertStagingRecord
      - QueueForProcessing
  
  # Triage and Classification
  - name: TriageAndPrioritizeAlert
    inputs: [alert_type, severity, repo_criticality]
    actions:
      - ComputeNormalizedPriority
      - ApplyBusinessRules
      - SetSLADueDates
  
  # Assignment
  - name: AssignToOwningTeam
    inputs: [repo_name, alert_type, priority]
    actions:
      - LookupCMDBApplication
      - ResolveOwnerFromCodeowners
      - FallbackToTriageQueue
      - NotifyAssignee
  
  # Lifecycle Management
  - name: HandleAlertStateChange
    inputs: [current_state, new_state, reason]
    actions:
      - ValidateStateTransition
      - UpdateVulnerableItem
      - SyncToGitHub (if bidirectional)
      - RecordAuditTrail
  
  # Exception Handling
  - name: ProcessExceptionRequest
    inputs: [alert_key, reason, approver, expiration]
    actions:
      - ValidateApproverAuthority
      - RecordCompensatingControls
      - SetExpirationReminder
      - UpdateGitHubDismissalReason
\end{lstlisting}

% ===========================
\section{Implementation: Webhook Receiver}
\label{sec:webhook-receiver}

\subsection{Node.js/TypeScript Implementation}
\label{subsec:nodejs-receiver}

The following production-ready implementation includes signature validation, structured logging, queue integration, and comprehensive error handling:

\begin{lstlisting}[language=TypeScript,caption={TypeScript Webhook Receiver with Full Validation}]
import express, { Request, Response, NextFunction } from 'express';
import crypto from 'crypto';
import { SQSClient, SendMessageCommand } from '@aws-sdk/client-sqs';
import pino from 'pino';

// Configuration
const config = {
  port: parseInt(process.env.PORT || '8080'),
  webhookSecret: process.env.GITHUB_WEBHOOK_SECRET!,
  sqsQueueUrl: process.env.SQS_QUEUE_URL!,
  awsRegion: process.env.AWS_REGION || 'us-east-1',
  servicenowUrl: process.env.SERVICENOW_INGEST_URL,
  servicenowToken: process.env.SERVICENOW_BEARER_TOKEN,
};

// Initialize clients
const logger = pino({ level: 'info' });
const sqs = new SQSClient({ region: config.awsRegion });
const app = express();

// CRITICAL: Use raw body for HMAC verification
app.use('/webhook', express.raw({ type: 'application/json', limit: '5mb' }));
app.use(express.json());

// Interfaces
interface WebhookHeaders {
  signature: string;
  event: string;
  delivery: string;
}

interface ProcessedEvent {
  deliveryId: string;
  eventType: string;
  action: string;
  alertKey: string;
  repository: string;
  alertNumber: number;
  severity: string | null;
  state: string;
  assignees: string[];
  receivedAt: string;
  payload: object;
}

// Timing-safe comparison to prevent timing attacks
function timingSafeEqual(a: string, b: string): boolean {
  if (!a || !b) return false;
  const bufA = Buffer.from(a);
  const bufB = Buffer.from(b);
  if (bufA.length !== bufB.length) return false;
  return crypto.timingSafeEqual(bufA, bufB);
}

// Verify GitHub webhook signature
function verifySignature(payload: Buffer, signature: string): boolean {
  const hmac = crypto.createHmac('sha256', config.webhookSecret);
  hmac.update(payload);
  const expected = `sha256=${hmac.digest('hex')}`;
  return timingSafeEqual(signature, expected);
}

// Extract headers with validation
function extractHeaders(req: Request): WebhookHeaders {
  return {
    signature: req.header('X-Hub-Signature-256') || '',
    event: req.header('X-GitHub-Event') || '',
    delivery: req.header('X-GitHub-Delivery') || '',
  };
}

// Compute canonical alert key
function computeAlertKey(event: string, payload: any): string {
  const repo = payload.repository?.full_name || 'unknown';
  const alertNumber = payload.alert?.number || 0;
  
  const alertTypeMap: Record<string, string> = {
    'code_scanning_alert': 'code_scanning',
    'dependabot_alert': 'dependabot',
    'secret_scanning_alert': 'secret_scanning',
  };
  
  const alertType = alertTypeMap[event] || event;
  return `github:${repo}:${alertType}:${alertNumber}`;
}

// Extract severity from various alert types
function extractSeverity(event: string, payload: any): string | null {
  switch (event) {
    case 'code_scanning_alert':
      return payload.alert?.rule?.severity || 
             payload.alert?.rule?.security_severity_level || null;
    case 'dependabot_alert':
      return payload.alert?.security_advisory?.severity ||
             payload.alert?.security_vulnerability?.severity || null;
    case 'secret_scanning_alert':
      // Secret scanning doesn't have severity; return 'critical' by default
      return 'critical';
    default:
      return null;
  }
}

// Extract assignees (new 2025 feature)
function extractAssignees(payload: any): string[] {
  const assignees = payload.alert?.assignees || [];
  return assignees.map((a: any) => a.login);
}

// Process and normalize the webhook event
function processEvent(headers: WebhookHeaders, payload: any): ProcessedEvent {
  return {
    deliveryId: headers.delivery,
    eventType: headers.event,
    action: payload.action || 'unknown',
    alertKey: computeAlertKey(headers.event, payload),
    repository: payload.repository?.full_name || 'unknown',
    alertNumber: payload.alert?.number || 0,
    severity: extractSeverity(headers.event, payload),
    state: payload.alert?.state || 'unknown',
    assignees: extractAssignees(payload),
    receivedAt: new Date().toISOString(),
    payload: sanitizePayload(headers.event, payload),
  };
}

// Sanitize payload to remove sensitive data
function sanitizePayload(event: string, payload: any): object {
  if (event === 'secret_scanning_alert') {
    // CRITICAL: Never store actual secret values
    const sanitized = { ...payload };
    if (sanitized.alert) {
      sanitized.alert = { 
        ...sanitized.alert,
        secret: '[REDACTED]',
      };
    }
    return sanitized;
  }
  return payload;
}

// Publish to SQS queue
async function publishToQueue(event: ProcessedEvent): Promise<void> {
  const command = new SendMessageCommand({
    QueueUrl: config.sqsQueueUrl,
    MessageBody: JSON.stringify(event),
    MessageAttributes: {
      EventType: { DataType: 'String', StringValue: event.eventType },
      AlertKey: { DataType: 'String', StringValue: event.alertKey },
      Priority: { DataType: 'String', StringValue: event.severity || 'medium' },
    },
    MessageDeduplicationId: event.deliveryId,
    MessageGroupId: event.repository.replace('/', '-'),
  });
  
  await sqs.send(command);
}

// Allowed event types
const ALLOWED_EVENTS = new Set([
  'code_scanning_alert',
  'dependabot_alert',
  'secret_scanning_alert',
  'security_and_analysis',
]);

// Main webhook handler
app.post('/webhook/github', async (req: Request, res: Response) => {
  const startTime = Date.now();
  const headers = extractHeaders(req);
  
  // Log incoming request
  logger.info({
    delivery: headers.delivery,
    event: headers.event,
    userAgent: req.header('User-Agent'),
  }, 'Webhook received');
  
  // Validate signature
  if (!verifySignature(req.body as Buffer, headers.signature)) {
    logger.warn({ delivery: headers.delivery }, 'Invalid signature');
    return res.status(401).json({ 
      error: 'invalid_signature',
      message: 'Webhook signature validation failed',
    });
  }
  
  // Validate event type
  if (!ALLOWED_EVENTS.has(headers.event)) {
    logger.info({ 
      delivery: headers.delivery,
      event: headers.event,
    }, 'Ignored event type');
    return res.status(200).json({ 
      status: 'ignored',
      reason: 'event_type_not_processed',
    });
  }
  
  try {
    const payload = JSON.parse(req.body.toString());
    const event = processEvent(headers, payload);
    
    // Publish to queue for async processing
    await publishToQueue(event);
    
    const duration = Date.now() - startTime;
    logger.info({
      delivery: headers.delivery,
      alertKey: event.alertKey,
      action: event.action,
      duration,
    }, 'Event queued successfully');
    
    return res.status(202).json({
      status: 'accepted',
      delivery_id: headers.delivery,
      alert_key: event.alertKey,
    });
    
  } catch (error) {
    logger.error({
      delivery: headers.delivery,
      error: error instanceof Error ? error.message : 'Unknown error',
    }, 'Processing failed');
    
    // Return 500 so GitHub will retry
    return res.status(500).json({
      error: 'processing_failed',
      delivery_id: headers.delivery,
    });
  }
});

// Health check endpoint
app.get('/health', (req: Request, res: Response) => {
  res.status(200).json({ 
    status: 'healthy',
    timestamp: new Date().toISOString(),
  });
});

// Start server
app.listen(config.port, () => {
  logger.info({ port: config.port }, 'Webhook receiver started');
});
\end{lstlisting}

\subsection{Go Implementation}
\label{subsec:go-receiver}

High-performance Go implementation for high-volume deployments:

\begin{lstlisting}[language=Go,caption={Go Webhook Receiver with Concurrent Processing}]
package main

import (
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"crypto/subtle"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/sqs"
)

type Config struct {
	Port          string
	WebhookSecret string
	SQSQueueURL   string
}

type WebhookEvent struct {
	DeliveryID  string    `json:"delivery_id"`
	EventType   string    `json:"event_type"`
	Action      string    `json:"action"`
	AlertKey    string    `json:"alert_key"`
	Repository  string    `json:"repository"`
	AlertNumber int       `json:"alert_number"`
	Severity    string    `json:"severity,omitempty"`
	State       string    `json:"state"`
	Assignees   []string  `json:"assignees"`
	ReceivedAt  time.Time `json:"received_at"`
	Payload     any       `json:"payload"`
}

type WebhookHandler struct {
	config    *Config
	sqsClient *sqs.Client
	logger    *slog.Logger
}

func NewWebhookHandler(cfg *Config) (*WebhookHandler, error) {
	awsCfg, err := config.LoadDefaultConfig(context.Background())
	if err != nil {
		return nil, fmt.Errorf("failed to load AWS config: %w", err)
	}

	return &WebhookHandler{
		config:    cfg,
		sqsClient: sqs.NewFromConfig(awsCfg),
		logger:    slog.New(slog.NewJSONHandler(os.Stdout, nil)),
	}, nil
}

func (h *WebhookHandler) verifySignature(payload []byte, signature string) bool {
	if !strings.HasPrefix(signature, "sha256=") {
		return false
	}

	mac := hmac.New(sha256.New, []byte(h.config.WebhookSecret))
	mac.Write(payload)
	expected := "sha256=" + hex.EncodeToString(mac.Sum(nil))

	return subtle.ConstantTimeCompare([]byte(signature), []byte(expected)) == 1
}

func (h *WebhookHandler) computeAlertKey(eventType string, payload map[string]any) string {
	repo := "unknown"
	if r, ok := payload["repository"].(map[string]any); ok {
		if fn, ok := r["full_name"].(string); ok {
			repo = fn
		}
	}

	var alertNumber float64
	if alert, ok := payload["alert"].(map[string]any); ok {
		if num, ok := alert["number"].(float64); ok {
			alertNumber = num
		}
	}

	alertTypeMap := map[string]string{
		"code_scanning_alert":   "code_scanning",
		"dependabot_alert":      "dependabot",
		"secret_scanning_alert": "secret_scanning",
	}

	alertType := alertTypeMap[eventType]
	if alertType == "" {
		alertType = eventType
	}

	return fmt.Sprintf("github:%s:%s:%.0f", repo, alertType, alertNumber)
}

func (h *WebhookHandler) extractSeverity(eventType string, payload map[string]any) string {
	alert, ok := payload["alert"].(map[string]any)
	if !ok {
		return ""
	}

	switch eventType {
	case "code_scanning_alert":
		if rule, ok := alert["rule"].(map[string]any); ok {
			if sev, ok := rule["severity"].(string); ok {
				return sev
			}
			if sev, ok := rule["security_severity_level"].(string); ok {
				return sev
			}
		}
	case "dependabot_alert":
		if adv, ok := alert["security_advisory"].(map[string]any); ok {
			if sev, ok := adv["severity"].(string); ok {
				return sev
			}
		}
	case "secret_scanning_alert":
		return "critical"
	}
	return ""
}

func (h *WebhookHandler) extractAssignees(payload map[string]any) []string {
	var assignees []string
	alert, ok := payload["alert"].(map[string]any)
	if !ok {
		return assignees
	}

	if ass, ok := alert["assignees"].([]any); ok {
		for _, a := range ass {
			if user, ok := a.(map[string]any); ok {
				if login, ok := user["login"].(string); ok {
					assignees = append(assignees, login)
				}
			}
		}
	}
	return assignees
}

func (h *WebhookHandler) processEvent(
	deliveryID, eventType string,
	payload map[string]any,
) *WebhookEvent {
	action := ""
	if a, ok := payload["action"].(string); ok {
		action = a
	}

	state := "unknown"
	if alert, ok := payload["alert"].(map[string]any); ok {
		if s, ok := alert["state"].(string); ok {
			state = s
		}
	}

	var alertNumber int
	if alert, ok := payload["alert"].(map[string]any); ok {
		if num, ok := alert["number"].(float64); ok {
			alertNumber = int(num)
		}
	}

	repo := "unknown"
	if r, ok := payload["repository"].(map[string]any); ok {
		if fn, ok := r["full_name"].(string); ok {
			repo = fn
		}
	}

	// Sanitize secret scanning payloads
	sanitizedPayload := payload
	if eventType == "secret_scanning_alert" {
		if alert, ok := sanitizedPayload["alert"].(map[string]any); ok {
			alert["secret"] = "[REDACTED]"
		}
	}

	return &WebhookEvent{
		DeliveryID:  deliveryID,
		EventType:   eventType,
		Action:      action,
		AlertKey:    h.computeAlertKey(eventType, payload),
		Repository:  repo,
		AlertNumber: alertNumber,
		Severity:    h.extractSeverity(eventType, payload),
		State:       state,
		Assignees:   h.extractAssignees(payload),
		ReceivedAt:  time.Now().UTC(),
		Payload:     sanitizedPayload,
	}
}

func (h *WebhookHandler) publishToQueue(ctx context.Context, event *WebhookEvent) error {
	body, err := json.Marshal(event)
	if err != nil {
		return fmt.Errorf("failed to marshal event: %w", err)
	}

	messageGroupID := strings.ReplaceAll(event.Repository, "/", "-")
	
	_, err = h.sqsClient.SendMessage(ctx, &sqs.SendMessageInput{
		QueueUrl:               &h.config.SQSQueueURL,
		MessageBody:            ptrString(string(body)),
		MessageDeduplicationId: &event.DeliveryID,
		MessageGroupId:         &messageGroupID,
	})

	return err
}

func ptrString(s string) *string { return &s }

var allowedEvents = map[string]bool{
	"code_scanning_alert":   true,
	"dependabot_alert":      true,
	"secret_scanning_alert": true,
	"security_and_analysis": true,
}

func (h *WebhookHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Extract headers
	signature := r.Header.Get("X-Hub-Signature-256")
	eventType := r.Header.Get("X-GitHub-Event")
	deliveryID := r.Header.Get("X-GitHub-Delivery")

	// Read body
	body, err := io.ReadAll(io.LimitReader(r.Body, 5<<20)) // 5MB limit
	if err != nil {
		h.logger.Error("Failed to read body", "delivery", deliveryID, "error", err)
		http.Error(w, "Failed to read body", http.StatusBadRequest)
		return
	}

	// Verify signature
	if !h.verifySignature(body, signature) {
		h.logger.Warn("Invalid signature", "delivery", deliveryID)
		w.WriteHeader(http.StatusUnauthorized)
		json.NewEncoder(w).Encode(map[string]string{
			"error":   "invalid_signature",
			"message": "Webhook signature validation failed",
		})
		return
	}

	// Check event type
	if !allowedEvents[eventType] {
		h.logger.Info("Ignored event type", "delivery", deliveryID, "event", eventType)
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]string{
			"status": "ignored",
			"reason": "event_type_not_processed",
		})
		return
	}

	// Parse payload
	var payload map[string]any
	if err := json.Unmarshal(body, &payload); err != nil {
		h.logger.Error("Failed to parse payload", "delivery", deliveryID, "error", err)
		http.Error(w, "Invalid JSON payload", http.StatusBadRequest)
		return
	}

	// Process and queue
	event := h.processEvent(deliveryID, eventType, payload)
	
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	if err := h.publishToQueue(ctx, event); err != nil {
		h.logger.Error("Failed to queue event",
			"delivery", deliveryID,
			"alert_key", event.AlertKey,
			"error", err,
		)
		http.Error(w, "Failed to queue event", http.StatusInternalServerError)
		return
	}

	h.logger.Info("Event queued",
		"delivery", deliveryID,
		"alert_key", event.AlertKey,
		"action", event.Action,
	)

	w.WriteHeader(http.StatusAccepted)
	json.NewEncoder(w).Encode(map[string]string{
		"status":      "accepted",
		"delivery_id": deliveryID,
		"alert_key":   event.AlertKey,
	})
}

func main() {
	cfg := &Config{
		Port:          getEnv("PORT", "8080"),
		WebhookSecret: os.Getenv("GITHUB_WEBHOOK_SECRET"),
		SQSQueueURL:   os.Getenv("SQS_QUEUE_URL"),
	}

	handler, err := NewWebhookHandler(cfg)
	if err != nil {
		slog.Error("Failed to create handler", "error", err)
		os.Exit(1)
	}

	mux := http.NewServeMux()
	mux.Handle("/webhook/github", handler)
	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		json.NewEncoder(w).Encode(map[string]string{
			"status":    "healthy",
			"timestamp": time.Now().UTC().Format(time.RFC3339),
		})
	})

	slog.Info("Starting server", "port", cfg.Port)
	if err := http.ListenAndServe(":"+cfg.Port, mux); err != nil {
		slog.Error("Server failed", "error", err)
		os.Exit(1)
	}
}

func getEnv(key, fallback string) string {
	if v := os.Getenv(key); v != "" {
		return v
	}
	return fallback
}
\end{lstlisting}

\subsection{ServiceNow Scripted REST API Implementation}
\label{subsec:servicenow-rest}

For deployments preferring a ServiceNow-native approach:

\begin{lstlisting}[language=JavaScript,caption={ServiceNow Scripted REST API Resource}]
// Scripted REST API Resource: POST /api/x_ghas/webhook
// Table: x_ghas_event (custom staging table)

(function process(/*RESTAPIRequest*/ request, /*RESTAPIResponse*/ response) {
    'use strict';
    
    var startTime = new GlideDateTime();
    
    // Configuration
    var SECRET = gs.getProperty('x_ghas.webhook.secret');
    var MAX_PAYLOAD_SIZE = 5242880; // 5MB
    
    // Extract headers
    var signature = request.getHeader('X-Hub-Signature-256') || '';
    var eventType = request.getHeader('X-GitHub-Event') || '';
    var deliveryId = request.getHeader('X-GitHub-Delivery') || '';
    
    // Get raw body for signature verification
    var bodyStr = request.body.dataString || '';
    
    // Check payload size
    if (bodyStr.length > MAX_PAYLOAD_SIZE) {
        response.setStatus(413);
        response.setBody({
            error: 'payload_too_large',
            max_size: MAX_PAYLOAD_SIZE
        });
        return;
    }
    
    // Verify signature using Java crypto
    var expectedSignature = 'sha256=' + computeHmacSha256(SECRET, bodyStr);
    if (!constantTimeEquals(signature, expectedSignature)) {
        gs.warn('GHAS Webhook: Invalid signature for delivery ' + deliveryId);
        response.setStatus(401);
        response.setBody({
            error: 'invalid_signature',
            delivery_id: deliveryId
        });
        return;
    }
    
    // Validate event type
    var allowedEvents = [
        'code_scanning_alert',
        'dependabot_alert', 
        'secret_scanning_alert',
        'security_and_analysis'
    ];
    
    if (allowedEvents.indexOf(eventType) === -1) {
        response.setStatus(200);
        response.setBody({
            status: 'ignored',
            reason: 'event_type_not_processed',
            event_type: eventType
        });
        return;
    }
    
    try {
        var payload = JSON.parse(bodyStr);
        
        // Compute canonical alert key
        var alertKey = computeAlertKey(eventType, payload);
        
        // Check for duplicate delivery (idempotency)
        var existingEvent = new GlideRecord('x_ghas_event');
        existingEvent.addQuery('u_delivery_id', deliveryId);
        existingEvent.query();
        
        if (existingEvent.next()) {
            response.setStatus(200);
            response.setBody({
                status: 'duplicate',
                delivery_id: deliveryId,
                existing_sys_id: existingEvent.sys_id.toString()
            });
            return;
        }
        
        // Create staging record
        var eventRecord = new GlideRecord('x_ghas_event');
        eventRecord.initialize();
        eventRecord.u_delivery_id = deliveryId;
        eventRecord.u_event_type = eventType;
        eventRecord.u_action = payload.action || 'unknown';
        eventRecord.u_alert_key = alertKey;
        eventRecord.u_repository = getNestedValue(payload, 'repository.full_name', 'unknown');
        eventRecord.u_alert_number = getNestedValue(payload, 'alert.number', 0);
        eventRecord.u_severity = extractSeverity(eventType, payload);
        eventRecord.u_state = getNestedValue(payload, 'alert.state', 'unknown');
        eventRecord.u_assignees = JSON.stringify(extractAssignees(payload));
        eventRecord.u_processing_state = 'received';
        eventRecord.u_received_at = startTime;
        
        // Sanitize and store payload
        var sanitizedPayload = sanitizePayload(eventType, payload);
        eventRecord.u_payload = JSON.stringify(sanitizedPayload);
        
        var sysId = eventRecord.insert();
        
        if (!sysId) {
            throw new Error('Failed to insert event record');
        }
        
        // Queue for async processing via event
        gs.eventQueue('x_ghas.event.received', eventRecord, deliveryId, eventType);
        
        // Calculate processing time
        var endTime = new GlideDateTime();
        var duration = GlideDateTime.subtract(startTime, endTime).getNumericValue();
        
        gs.info('GHAS Webhook: Queued event ' + deliveryId + 
                ' (' + alertKey + ') in ' + duration + 'ms');
        
        response.setStatus(202);
        response.setBody({
            status: 'accepted',
            delivery_id: deliveryId,
            alert_key: alertKey,
            sys_id: sysId,
            processing_time_ms: duration
        });
        
    } catch (e) {
        gs.error('GHAS Webhook: Processing error for ' + deliveryId + ': ' + e.message);
        response.setStatus(500);
        response.setBody({
            error: 'processing_failed',
            delivery_id: deliveryId,
            message: e.message
        });
    }
    
    // ========== Helper Functions ==========
    
    function computeHmacSha256(key, data) {
        var Mac = Packages.javax.crypto.Mac;
        var SecretKeySpec = Packages.javax.crypto.spec.SecretKeySpec;
        var StandardCharsets = Packages.java.nio.charset.StandardCharsets;
        
        var mac = Mac.getInstance('HmacSHA256');
        var keyBytes = new java.lang.String(key).getBytes(StandardCharsets.UTF_8);
        var keySpec = new SecretKeySpec(keyBytes, 'HmacSHA256');
        mac.init(keySpec);
        
        var dataBytes = new java.lang.String(data).getBytes(StandardCharsets.UTF_8);
        var hashBytes = mac.doFinal(dataBytes);
        
        var sb = new java.lang.StringBuilder();
        for (var i = 0; i < hashBytes.length; i++) {
            sb.append(java.lang.String.format('%02x', hashBytes[i] & 0xff));
        }
        return sb.toString();
    }
    
    function constantTimeEquals(a, b) {
        if (!a || !b || a.length !== b.length) return false;
        var result = 0;
        for (var i = 0; i < a.length; i++) {
            result |= a.charCodeAt(i) ^ b.charCodeAt(i);
        }
        return result === 0;
    }
    
    function computeAlertKey(eventType, payload) {
        var repo = getNestedValue(payload, 'repository.full_name', 'unknown');
        var alertNumber = getNestedValue(payload, 'alert.number', 0);
        
        var typeMap = {
            'code_scanning_alert': 'code_scanning',
            'dependabot_alert': 'dependabot',
            'secret_scanning_alert': 'secret_scanning'
        };
        
        var alertType = typeMap[eventType] || eventType;
        return 'github:' + repo + ':' + alertType + ':' + alertNumber;
    }
    
    function extractSeverity(eventType, payload) {
        var alert = payload.alert || {};
        
        switch (eventType) {
            case 'code_scanning_alert':
                var rule = alert.rule || {};
                return rule.severity || rule.security_severity_level || '';
            case 'dependabot_alert':
                var advisory = alert.security_advisory || {};
                return advisory.severity || '';
            case 'secret_scanning_alert':
                return 'critical';
            default:
                return '';
        }
    }
    
    function extractAssignees(payload) {
        var assignees = [];
        var alertAssignees = getNestedValue(payload, 'alert.assignees', []);
        
        for (var i = 0; i < alertAssignees.length; i++) {
            if (alertAssignees[i] && alertAssignees[i].login) {
                assignees.push(alertAssignees[i].login);
            }
        }
        return assignees;
    }
    
    function sanitizePayload(eventType, payload) {
        if (eventType === 'secret_scanning_alert') {
            var sanitized = JSON.parse(JSON.stringify(payload));
            if (sanitized.alert) {
                sanitized.alert.secret = '[REDACTED]';
            }
            return sanitized;
        }
        return payload;
    }
    
    function getNestedValue(obj, path, defaultValue) {
        var parts = path.split('.');
        var current = obj;
        
        for (var i = 0; i < parts.length; i++) {
            if (current === null || current === undefined) {
                return defaultValue;
            }
            current = current[parts[i]];
        }
        
        return (current !== null && current !== undefined) ? current : defaultValue;
    }
    
})(request, response);
\end{lstlisting}

% ===========================
\section{Implementation: Reconciliation Worker}
\label{sec:reconciliation}

\subsection{Python Reconciliation Service}
\label{subsec:python-reconciliation}

Production-grade Python implementation with comprehensive API support:

\begin{lstlisting}[language=Python,caption={Python Reconciliation Worker with Full Feature Support}]
#!/usr/bin/env python3
"""
GitHub Security Alerts Reconciliation Worker

Synchronizes GitHub security alerts with ServiceNow, supporting:
- Code scanning, secret scanning, and Dependabot alerts
- Alert assignees (new 2025 feature)
- Security campaigns
- Bidirectional state synchronization
"""

import os
import sys
import json
import logging
import hashlib
from datetime import datetime, timedelta, timezone
from typing import Any, Iterator, Optional
from dataclasses import dataclass, asdict
from enum import Enum

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class AlertType(Enum):
    CODE_SCANNING = "code_scanning"
    SECRET_SCANNING = "secret_scanning"
    DEPENDABOT = "dependabot"


@dataclass
class GitHubConfig:
    """GitHub API configuration."""
    token: str
    api_base: str = "https://api.github.com"
    api_version: str = "2022-11-28"
    
    @property
    def headers(self) -> dict[str, str]:
        return {
            "Accept": "application/vnd.github+json",
            "Authorization": f"Bearer {self.token}",
            "X-GitHub-Api-Version": self.api_version,
        }


@dataclass
class ServiceNowConfig:
    """ServiceNow API configuration."""
    instance_url: str
    username: str
    password: str
    ingest_endpoint: str = "/api/x_ghas/reconciliation"
    
    @property
    def full_url(self) -> str:
        return f"{self.instance_url.rstrip('/')}{self.ingest_endpoint}"


@dataclass
class NormalizedAlert:
    """Normalized alert structure for ServiceNow ingestion."""
    provider: str
    alert_type: str
    organization: str
    repository: str
    alert_number: int
    canonical_key: str
    state: str
    severity: Optional[str]
    created_at: str
    updated_at: str
    html_url: str
    rule_id: Optional[str]
    rule_description: Optional[str]
    cwe_ids: list[str]
    assignees: list[str]
    dismissed_by: Optional[str]
    dismissed_reason: Optional[str]
    fixed_at: Optional[str]
    raw_alert: dict[str, Any]


class GitHubClient:
    """GitHub API client with retry logic and pagination support."""
    
    def __init__(self, config: GitHubConfig):
        self.config = config
        self.session = self._create_session()
    
    def _create_session(self) -> requests.Session:
        session = requests.Session()
        
        # Configure retries with exponential backoff
        retry_strategy = Retry(
            total=5,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "PATCH"],
            respect_retry_after_header=True,
        )
        
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("https://", adapter)
        session.headers.update(self.config.headers)
        
        return session
    
    def _paginate(
        self, 
        url: str, 
        params: Optional[dict[str, Any]] = None
    ) -> Iterator[dict[str, Any]]:
        """Paginate through GitHub API results."""
        params = params or {}
        params.setdefault("per_page", 100)
        
        while url:
            response = self.session.get(url, params=params, timeout=30)
            response.raise_for_status()
            
            # Check rate limits
            remaining = int(response.headers.get("X-RateLimit-Remaining", 0))
            if remaining < 100:
                reset_time = int(response.headers.get("X-RateLimit-Reset", 0))
                logger.warning(
                    f"Rate limit low: {remaining} remaining, "
                    f"resets at {datetime.fromtimestamp(reset_time)}"
                )
            
            data = response.json()
            if isinstance(data, list):
                yield from data
            else:
                yield data
            
            # Get next page URL from Link header
            url = None
            params = None  # Only apply params on first request
            
            link_header = response.headers.get("Link", "")
            for link in link_header.split(","):
                if 'rel="next"' in link:
                    url = link[link.find("<") + 1:link.find(">")]
                    break
    
    def list_code_scanning_alerts(
        self,
        owner: str,
        repo: str,
        state: str = "open",
        since: Optional[datetime] = None,
    ) -> Iterator[dict[str, Any]]:
        """List code scanning alerts for a repository."""
        url = f"{self.config.api_base}/repos/{owner}/{repo}/code-scanning/alerts"
        params = {"state": state}
        
        if since:
            # Filter by tool_name and created_at if needed
            pass
        
        yield from self._paginate(url, params)
    
    def list_secret_scanning_alerts(
        self,
        owner: str,
        repo: str,
        state: str = "open",
    ) -> Iterator[dict[str, Any]]:
        """List secret scanning alerts for a repository."""
        url = f"{self.config.api_base}/repos/{owner}/{repo}/secret-scanning/alerts"
        params = {"state": state}
        yield from self._paginate(url, params)
    
    def list_dependabot_alerts(
        self,
        owner: str,
        repo: str,
        state: str = "open",
    ) -> Iterator[dict[str, Any]]:
        """List Dependabot alerts for a repository."""
        url = f"{self.config.api_base}/repos/{owner}/{repo}/dependabot/alerts"
        params = {"state": state}
        yield from self._paginate(url, params)
    
    def list_org_repos(
        self,
        org: str,
        repo_type: str = "all",
    ) -> Iterator[dict[str, Any]]:
        """List repositories in an organization."""
        url = f"{self.config.api_base}/orgs/{org}/repos"
        params = {"type": repo_type, "sort": "updated", "direction": "desc"}
        yield from self._paginate(url, params)
    
    def update_alert_assignees(
        self,
        owner: str,
        repo: str,
        alert_type: AlertType,
        alert_number: int,
        assignees: list[str],
    ) -> dict[str, Any]:
        """Update alert assignees (bidirectional sync)."""
        if alert_type == AlertType.CODE_SCANNING:
            url = f"{self.config.api_base}/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
        elif alert_type == AlertType.SECRET_SCANNING:
            url = f"{self.config.api_base}/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
        else:
            raise ValueError(f"Assignees not supported for {alert_type}")
        
        response = self.session.patch(
            url,
            json={"assignees": assignees},
            timeout=30,
        )
        response.raise_for_status()
        return response.json()


class AlertNormalizer:
    """Normalize GitHub alerts to common format."""
    
    @staticmethod
    def compute_canonical_key(
        org: str,
        repo: str,
        alert_type: AlertType,
        alert_number: int,
    ) -> str:
        """Compute deterministic canonical key."""
        return f"github:{org}/{repo}:{alert_type.value}:{alert_number}"
    
    @classmethod
    def normalize_code_scanning(
        cls,
        org: str,
        repo: str,
        alert: dict[str, Any],
    ) -> NormalizedAlert:
        """Normalize code scanning alert."""
        rule = alert.get("rule", {})
        
        # Extract CWE IDs from tags
        cwe_ids = [
            tag.replace("external/cwe/", "")
            for tag in rule.get("tags", [])
            if tag.startswith("external/cwe/")
        ]
        
        # Extract assignees
        assignees = [a.get("login", "") for a in alert.get("assignees", [])]
        
        return NormalizedAlert(
            provider="github",
            alert_type=AlertType.CODE_SCANNING.value,
            organization=org,
            repository=repo,
            alert_number=alert.get("number", 0),
            canonical_key=cls.compute_canonical_key(
                org, repo, AlertType.CODE_SCANNING, alert.get("number", 0)
            ),
            state=alert.get("state", "unknown"),
            severity=rule.get("severity") or rule.get("security_severity_level"),
            created_at=alert.get("created_at", ""),
            updated_at=alert.get("updated_at", ""),
            html_url=alert.get("html_url", ""),
            rule_id=rule.get("id"),
            rule_description=rule.get("description"),
            cwe_ids=cwe_ids,
            assignees=assignees,
            dismissed_by=alert.get("dismissed_by", {}).get("login") if alert.get("dismissed_by") else None,
            dismissed_reason=alert.get("dismissed_reason"),
            fixed_at=alert.get("fixed_at"),
            raw_alert=alert,
        )
    
    @classmethod
    def normalize_secret_scanning(
        cls,
        org: str,
        repo: str,
        alert: dict[str, Any],
    ) -> NormalizedAlert:
        """Normalize secret scanning alert.
        
        CRITICAL: Never store actual secret values.
        """
        # Redact secret value
        sanitized_alert = {**alert}
        if "secret" in sanitized_alert:
            sanitized_alert["secret"] = "[REDACTED]"
        
        assignees = [a.get("login", "") for a in alert.get("assignees", [])]
        
        return NormalizedAlert(
            provider="github",
            alert_type=AlertType.SECRET_SCANNING.value,
            organization=org,
            repository=repo,
            alert_number=alert.get("number", 0),
            canonical_key=cls.compute_canonical_key(
                org, repo, AlertType.SECRET_SCANNING, alert.get("number", 0)
            ),
            state=alert.get("state", "unknown"),
            severity="critical",  # Secret exposure is always critical
            created_at=alert.get("created_at", ""),
            updated_at=alert.get("updated_at", ""),
            html_url=alert.get("html_url", ""),
            rule_id=alert.get("secret_type"),
            rule_description=f"Exposed {alert.get('secret_type_display_name', 'secret')}",
            cwe_ids=["CWE-798"],  # Hard-coded credentials
            assignees=assignees,
            dismissed_by=alert.get("resolved_by", {}).get("login") if alert.get("resolved_by") else None,
            dismissed_reason=alert.get("resolution"),
            fixed_at=alert.get("resolved_at"),
            raw_alert=sanitized_alert,
        )
    
    @classmethod
    def normalize_dependabot(
        cls,
        org: str,
        repo: str,
        alert: dict[str, Any],
    ) -> NormalizedAlert:
        """Normalize Dependabot alert."""
        advisory = alert.get("security_advisory", {})
        vulnerability = alert.get("security_vulnerability", {})
        
        # Extract CWE IDs
        cwe_ids = [
            cwe.get("cwe_id", "")
            for cwe in advisory.get("cwes", [])
        ]
        
        return NormalizedAlert(
            provider="github",
            alert_type=AlertType.DEPENDABOT.value,
            organization=org,
            repository=repo,
            alert_number=alert.get("number", 0),
            canonical_key=cls.compute_canonical_key(
                org, repo, AlertType.DEPENDABOT, alert.get("number", 0)
            ),
            state=alert.get("state", "unknown"),
            severity=advisory.get("severity") or vulnerability.get("severity"),
            created_at=alert.get("created_at", ""),
            updated_at=alert.get("updated_at", ""),
            html_url=alert.get("html_url", ""),
            rule_id=advisory.get("ghsa_id") or advisory.get("cve_id"),
            rule_description=advisory.get("summary"),
            cwe_ids=cwe_ids,
            assignees=[],  # Dependabot doesn't support assignees
            dismissed_by=alert.get("dismissed_by", {}).get("login") if alert.get("dismissed_by") else None,
            dismissed_reason=alert.get("dismissed_reason"),
            fixed_at=alert.get("fixed_at"),
            raw_alert=alert,
        )


class ServiceNowClient:
    """ServiceNow API client."""
    
    def __init__(self, config: ServiceNowConfig):
        self.config = config
        self.session = self._create_session()
    
    def _create_session(self) -> requests.Session:
        session = requests.Session()
        session.auth = (self.config.username, self.config.password)
        session.headers.update({
            "Content-Type": "application/json",
            "Accept": "application/json",
        })
        return session
    
    def upsert_alert(self, alert: NormalizedAlert) -> dict[str, Any]:
        """Upsert alert to ServiceNow."""
        payload = asdict(alert)
        
        # Don't send full raw alert to reduce payload size
        payload["raw_alert_hash"] = hashlib.sha256(
            json.dumps(alert.raw_alert, sort_keys=True).encode()
        ).hexdigest()
        del payload["raw_alert"]
        
        response = self.session.post(
            self.config.full_url,
            json=payload,
            timeout=30,
        )
        response.raise_for_status()
        return response.json()
    
    def upsert_alerts_batch(
        self,
        alerts: list[NormalizedAlert],
        batch_size: int = 100,
    ) -> dict[str, Any]:
        """Batch upsert alerts."""
        results = {"success": 0, "failed": 0, "errors": []}
        
        for i in range(0, len(alerts), batch_size):
            batch = alerts[i:i + batch_size]
            
            payloads = []
            for alert in batch:
                payload = asdict(alert)
                payload["raw_alert_hash"] = hashlib.sha256(
                    json.dumps(alert.raw_alert, sort_keys=True).encode()
                ).hexdigest()
                del payload["raw_alert"]
                payloads.append(payload)
            
            try:
                response = self.session.post(
                    f"{self.config.full_url}/batch",
                    json={"alerts": payloads},
                    timeout=60,
                )
                response.raise_for_status()
                result = response.json()
                results["success"] += result.get("success", 0)
                results["failed"] += result.get("failed", 0)
            except Exception as e:
                logger.error(f"Batch upsert failed: {e}")
                results["failed"] += len(batch)
                results["errors"].append(str(e))
        
        return results


class ReconciliationWorker:
    """Main reconciliation orchestrator."""
    
    def __init__(
        self,
        github_client: GitHubClient,
        servicenow_client: ServiceNowClient,
    ):
        self.github = github_client
        self.servicenow = servicenow_client
        self.normalizer = AlertNormalizer()
    
    def reconcile_repository(
        self,
        org: str,
        repo: str,
        alert_types: Optional[list[AlertType]] = None,
        states: Optional[list[str]] = None,
    ) -> dict[str, Any]:
        """Reconcile alerts for a single repository."""
        alert_types = alert_types or list(AlertType)
        states = states or ["open", "dismissed", "fixed"]
        
        results = {
            "repository": f"{org}/{repo}",
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "alerts_processed": 0,
            "by_type": {},
        }
        
        all_alerts: list[NormalizedAlert] = []
        
        for alert_type in alert_types:
            type_count = 0
            
            for state in states:
                try:
                    if alert_type == AlertType.CODE_SCANNING:
                        alerts = self.github.list_code_scanning_alerts(org, repo, state)
                        for alert in alerts:
                            normalized = self.normalizer.normalize_code_scanning(org, repo, alert)
                            all_alerts.append(normalized)
                            type_count += 1
                    
                    elif alert_type == AlertType.SECRET_SCANNING:
                        alerts = self.github.list_secret_scanning_alerts(org, repo, state)
                        for alert in alerts:
                            normalized = self.normalizer.normalize_secret_scanning(org, repo, alert)
                            all_alerts.append(normalized)
                            type_count += 1
                    
                    elif alert_type == AlertType.DEPENDABOT:
                        alerts = self.github.list_dependabot_alerts(org, repo, state)
                        for alert in alerts:
                            normalized = self.normalizer.normalize_dependabot(org, repo, alert)
                            all_alerts.append(normalized)
                            type_count += 1
                
                except requests.HTTPError as e:
                    if e.response.status_code == 404:
                        logger.info(f"{alert_type.value} not enabled for {org}/{repo}")
                    else:
                        logger.error(f"Error fetching {alert_type.value} for {org}/{repo}: {e}")
            
            results["by_type"][alert_type.value] = type_count
        
        # Batch upsert to ServiceNow
        if all_alerts:
            sync_result = self.servicenow.upsert_alerts_batch(all_alerts)
            results["sync_result"] = sync_result
        
        results["alerts_processed"] = len(all_alerts)
        return results
    
    def reconcile_organization(
        self,
        org: str,
        alert_types: Optional[list[AlertType]] = None,
        max_repos: Optional[int] = None,
    ) -> dict[str, Any]:
        """Reconcile alerts for all repositories in an organization."""
        results = {
            "organization": org,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "repositories_processed": 0,
            "total_alerts": 0,
            "repositories": [],
        }
        
        repo_count = 0
        for repo in self.github.list_org_repos(org):
            if max_repos and repo_count >= max_repos:
                break
            
            repo_name = repo.get("name", "")
            logger.info(f"Reconciling {org}/{repo_name}")
            
            try:
                repo_result = self.reconcile_repository(
                    org, repo_name, alert_types
                )
                results["repositories"].append(repo_result)
                results["total_alerts"] += repo_result["alerts_processed"]
            except Exception as e:
                logger.error(f"Failed to reconcile {org}/{repo_name}: {e}")
                results["repositories"].append({
                    "repository": f"{org}/{repo_name}",
                    "error": str(e),
                })
            
            repo_count += 1
        
        results["repositories_processed"] = repo_count
        return results


def main():
    """Main entry point."""
    # Load configuration from environment
    github_config = GitHubConfig(
        token=os.environ["GITHUB_TOKEN"],
    )
    
    servicenow_config = ServiceNowConfig(
        instance_url=os.environ["SERVICENOW_INSTANCE_URL"],
        username=os.environ["SERVICENOW_USERNAME"],
        password=os.environ["SERVICENOW_PASSWORD"],
    )
    
    # Initialize clients
    github_client = GitHubClient(github_config)
    servicenow_client = ServiceNowClient(servicenow_config)
    
    # Create worker
    worker = ReconciliationWorker(github_client, servicenow_client)
    
    # Run reconciliation
    org = os.environ.get("GITHUB_ORG", "")
    repo = os.environ.get("GITHUB_REPO", "")
    
    if repo:
        # Single repository mode
        result = worker.reconcile_repository(org, repo)
    else:
        # Organization mode
        result = worker.reconcile_organization(org)
    
    # Output results
    print(json.dumps(result, indent=2, default=str))
    
    # Exit with error if failures occurred
    if result.get("sync_result", {}).get("failed", 0) > 0:
        sys.exit(1)


if __name__ == "__main__":
    main()
\end{lstlisting}

% ===========================
\section{Implementation: GitHub Actions Integration}
\label{sec:github-actions}

\subsection{Security Results to ServiceNow DevOps}
\label{subsec:devops-action}

Leverage the official ServiceNow DevOps Security Results action:

\begin{lstlisting}[language=yaml,caption={GitHub Actions: Complete Security Workflow with ServiceNow Integration}]
name: Security Scanning with ServiceNow Integration

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 6 * * 1'  # Weekly Monday 6 AM UTC

permissions:
  contents: read
  security-events: write
  actions: read

jobs:
  # ============ CodeQL Analysis ============
  codeql-analysis:
    name: CodeQL SAST Scan
    runs-on: ubuntu-latest
    
    strategy:
      fail-fast: false
      matrix:
        language: [javascript, python, go]
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language }}
          queries: +security-extended,security-and-quality
      
      - name: Autobuild
        uses: github/codeql-action/autobuild@v3
      
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:${{ matrix.language }}"

  # ============ Dependency Review ============
  dependency-review:
    name: Dependency Review
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Dependency Review
        uses: actions/dependency-review-action@v4
        with:
          fail-on-severity: high
          deny-licenses: GPL-3.0, AGPL-3.0

  # ============ Container Scanning ============
  container-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Build container image
        run: docker build -t app:${{ github.sha }} .
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'app:${{ github.sha }}'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'
      
      - name: Upload Trivy scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'container-scanning'

  # ============ ServiceNow Integration ============
  servicenow-sync:
    name: Sync to ServiceNow DevOps
    runs-on: ubuntu-latest
    needs: [codeql-analysis]
    if: always() && github.event_name == 'push'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Register Security Results with ServiceNow
        uses: ServiceNow/servicenow-devops-security-result@v3.1.0
        with:
          devops-integration-token: ${{ secrets.SN_DEVOPS_INTEGRATION_TOKEN }}
          instance-url: ${{ secrets.SN_INSTANCE_URL }}
          tool-id: ${{ secrets.SN_ORCHESTRATION_TOOL_ID }}
          context-github: ${{ toJSON(github) }}
          job-name: 'ServiceNow Security Results'
      
      - name: Notify on critical findings
        if: failure()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": ":rotating_light: Critical security findings detected in ${{ github.repository }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Security Alert*\nCritical findings detected in `${{ github.repository }}`\n<${{ github.server_url }}/${{ github.repository }}/security|View Security Dashboard>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_SECURITY_WEBHOOK }}

  # ============ SBOM Generation ============
  sbom-generation:
    name: Generate and Upload SBOM
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          format: spdx-json
          output-file: sbom.spdx.json
      
      - name: Upload SBOM to ServiceNow
        uses: ServiceNow/vulnerability-response@v2.0.1
        with:
          snSbomUser: ${{ secrets.SN_SBOM_USERNAME }}
          snSbomPassword: ${{ secrets.SN_SBOM_PASSWORD }}
          snInstanceUrl: ${{ secrets.SN_INSTANCE_URL }}
          ghToken: ${{ secrets.GITHUB_TOKEN }}
          ghAccountOwner: ${{ github.repository_owner }}
          repository: ${{ github.event.repository.name }}
          provider: 'repository'
          path: 'sbom.spdx.json'
\end{lstlisting}

% ===========================
\section{Automation Design: Playbooks and Workflows}
\label{sec:automation-design}

\subsection{Triage and Prioritization Matrix}
\label{subsec:triage-matrix}

Compute normalized priority using multiple signals:

\begin{longtable}{@{}p{0.22\textwidth}p{0.73\textwidth}@{}}
\toprule
\textbf{Signal} & \textbf{Weighting and Logic} \\
\midrule
\textbf{GitHub Severity} & Direct mapping: critical=P1, high=P2, medium=P3, low=P4 \\
\midrule
\textbf{CVSS Score} & $\geq 9.0$: P1, $\geq 7.0$: P2, $\geq 4.0$: P3, $< 4.0$: P4 \\
\midrule
\textbf{EPSS Score} & Exploit Prediction Scoring: $> 0.5$: escalate one level \\
\midrule
\textbf{Asset Criticality} & Business-critical repo: escalate one level \\
\midrule
\textbf{Alert Type} & Secret scanning: always P1 or P2 (credential exposure) \\
\midrule
\textbf{Push Protection Bypass} & If \texttt{push\_protection\_bypassed}: true, immediate escalation \\
\midrule
\textbf{Known Exploited} & If in CISA KEV catalog: immediate P1 \\
\midrule
\textbf{Autofix Available} & Copilot Autofix available: may accelerate SLA \\
\bottomrule
\end{longtable}

\subsection{Assignment Resolution Strategy}
\label{subsec:assignment-strategy}

Ownership resolution follows this precedence:

\begin{enumerate}[leftmargin=1.5em]
  \item \textbf{CMDB/Application Registry}: Map repository to owning application/service via ServiceNow CMDB
  \item \textbf{GitHub CODEOWNERS}: Parse \texttt{.github/CODEOWNERS} file for path-based ownership
  \item \textbf{Repository Metadata}: Use GitHub repository topics or custom properties
  \item \textbf{Recent Committers}: Assign to most active contributor if other methods fail
  \item \textbf{Fallback Queue}: Route to AppSec triage queue for manual assignment
\end{enumerate}

\subsection{SLA Configuration Matrix}
\label{subsec:sla-matrix}

\begin{longtable}{@{}p{0.15\textwidth}p{0.15\textwidth}p{0.18\textwidth}p{0.18\textwidth}p{0.25\textwidth}@{}}
\toprule
\textbf{Priority} & \textbf{Secret} & \textbf{Code} & \textbf{Dependabot} & \textbf{Escalation} \\
\midrule
P1 / Critical & 4 hours & 24 hours & 48 hours & Immediate page \\
P2 / High & 24 hours & 7 days & 14 days & Daily summary \\
P3 / Medium & 7 days & 30 days & 60 days & Weekly report \\
P4 / Low & 30 days & 90 days & 180 days & Quarterly review \\
\bottomrule
\end{longtable}

\subsection{Exception Management Workflow}
\label{subsec:exception-workflow}

For dismissed alerts requiring risk acceptance:

\begin{enumerate}[leftmargin=1.5em]
  \item \textbf{Documented Reason}: Mandatory dismissal reason (false positive, won't fix, used in tests, etc.)
  \item \textbf{Risk Owner Approval}: Designated risk acceptance owner must approve
  \item \textbf{Expiration Date}: All exceptions expire (default: 90 days for code, 30 days for secrets)
  \item \textbf{Compensating Controls}: Document mitigations for accepted risk
  \item \textbf{Review Cycle}: Automated reminder for review before expiration
\end{enumerate}

% ===========================
\section{Reliability Engineering}
\label{sec:reliability}

\subsection{Idempotency Implementation}
\label{subsec:idempotency}

\begin{itemize}[leftmargin=1.5em]
  \item \textbf{Delivery ID}: Store \texttt{X-GitHub-Delivery} UUID; reject duplicates
  \item \textbf{Canonical Key}: Use as record identity for upsert semantics
  \item \textbf{State Machine}: Only allow valid state transitions
  \item \textbf{Optimistic Locking}: Use \texttt{updated\_at} timestamp for conflict detection
\end{itemize}

\subsection{Retry and Dead-Letter Strategy}
\label{subsec:retry-dlq}

\begin{lstlisting}[language=yaml,caption={Retry and DLQ Configuration}]
retry_policy:
  initial_delay_ms: 1000
  max_delay_ms: 300000  # 5 minutes
  backoff_multiplier: 2.0
  jitter_factor: 0.1
  max_attempts: 5
  
  # Retriable error codes
  retriable_status_codes:
    - 429  # Rate limited
    - 500  # Internal server error
    - 502  # Bad gateway
    - 503  # Service unavailable
    - 504  # Gateway timeout

dlq_policy:
  # Move to DLQ after max_attempts exhausted
  max_receive_count: 5
  
  # DLQ retention for investigation
  retention_days: 14
  
  # Alert thresholds
  alert_on_dlq_depth: 10
  alert_on_dlq_age_hours: 24
  
  # Replay configuration
  replay_batch_size: 100
  replay_delay_ms: 500
  require_manual_approval: true
\end{lstlisting}

\subsection{Observability Requirements}
\label{subsec:observability}

Key metrics to capture:

\begin{itemize}[leftmargin=1.5em]
  \item \textbf{Ingest Latency}: GitHub webhook timestamp $\rightarrow$ ServiceNow record creation
  \item \textbf{Processing Success Rate}: By event type and action
  \item \textbf{Deduplication Hits}: Percentage of duplicate deliveries
  \item \textbf{Queue Depth}: Backlog size and age
  \item \textbf{API Rate Limit Consumption}: GitHub and ServiceNow
  \item \textbf{SLA Compliance}: By severity, alert type, and owning team
  \item \textbf{Mean Time to Remediation}: By severity and alert type
  \item \textbf{Autofix Acceptance Rate}: Copilot Autofix suggestions adopted
\end{itemize}

% ===========================
\section{Security Hardening Checklist}
\label{sec:security-hardening}

\begin{enumerate}[leftmargin=1.5em]
  \item \textbf{Webhook Signature Verification}
    \begin{itemize}[leftmargin=1.5em]
      \item Enforce \texttt{X-Hub-Signature-256} validation on every request
      \item Use constant-time comparison to prevent timing attacks
      \item Reject requests with missing or invalid signatures
    \end{itemize}
  
  \item \textbf{Authentication and Authorization}
    \begin{itemize}[leftmargin=1.5em]
      \item Use GitHub App tokens (not PATs) for API access
      \item Implement least-privilege permissions
      \item Rotate tokens regularly; automate rotation where possible
      \item Use OAuth 2.0 or mutual TLS for ServiceNow authentication
    \end{itemize}
  
  \item \textbf{Secret Scanning Data Handling}
    \begin{itemize}[leftmargin=1.5em]
      \item \textbf{CRITICAL}: Never log or store actual secret values
      \item Redact secrets in all stored payloads
      \item Retain only remediation-relevant metadata
      \item Implement data retention policies for alert data
    \end{itemize}
  
  \item \textbf{Network Security}
    \begin{itemize}[leftmargin=1.5em]
      \item Deploy webhook receivers behind WAF
      \item Implement rate limiting (per-IP and per-organization)
      \item Consider IP allow-listing using GitHub's Meta API
      \item Use TLS 1.3 for all connections
    \end{itemize}
  
  \item \textbf{ServiceNow Security}
    \begin{itemize}[leftmargin=1.5em]
      \item Restrict Scripted REST API with ACLs
      \item Use dedicated integration user with minimal permissions
      \item Enable audit logging for all security operations
      \item Implement input validation and sanitization
    \end{itemize}
  
  \item \textbf{Change Management}
    \begin{itemize}[leftmargin=1.5em]
      \item Version-control all mapping logic and workflow rules
      \item Use staged rollout with canary repositories
      \item Maintain rollback capability for configuration changes
      \item Document all integration touchpoints
    \end{itemize}
\end{enumerate}

% ===========================
\section{Rollout Plan}
\label{sec:rollout}

\subsection{Phase 0: Prerequisites (Week 1--2)}
\label{subsec:phase-0}

\begin{itemize}[leftmargin=1.5em]
  \item Confirm GitHub Secret Protection and/or Code Security is enabled for target org/repos
  \item Install ServiceNow GitHub Application Vulnerability Integration
  \item Confirm SecOps licenses and roles are provisioned
  \item Define ownership mapping source of truth (CMDB vs CODEOWNERS)
  \item Establish SLA policies and escalation procedures
  \item Create GitHub App with required permissions
\end{itemize}

\subsection{Phase 1: Baseline Import (Week 3--4)}
\label{subsec:phase-1}

\begin{itemize}[leftmargin=1.5em]
  \item Enable official integration ingestion; verify records land correctly
  \item Validate severity mapping and deduplication logic
  \item Configure CWE/CVE enrichment
  \item Stand up initial dashboards and reports
  \item Establish baseline metrics for comparison
\end{itemize}

\subsection{Phase 2: Webhook Event Path (Week 5--8)}
\label{subsec:phase-2}

\begin{itemize}[leftmargin=1.5em]
  \item Deploy webhook receiver (external recommended)
  \item Implement signature verification and staging table
  \item Configure durable queue with DLQ
  \item Build Flow Designer workflows: assignment + SLA + notifications
  \item Test with canary repositories (non-critical)
  \item Monitor latency and error rates
\end{itemize}

\subsection{Phase 3: Reconciliation and Advanced Features (Week 9--12)}
\label{subsec:phase-3}

\begin{itemize}[leftmargin=1.5em]
  \item Deploy reconciliation poller with API rate limit awareness
  \item Implement drift detection: GitHub state vs ServiceNow state
  \item Add assignee synchronization (bidirectional if needed)
  \item Configure security campaign integration
  \item Add governance gates: false positive approvals, risk acceptance expiry
  \item Implement Copilot Autofix tracking and metrics
\end{itemize}

\subsection{Phase 4: Production Hardening (Week 13--16)}
\label{subsec:phase-4}

\begin{itemize}[leftmargin=1.5em]
  \item Performance testing under load (webhook storms)
  \item Security review and penetration testing
  \item Documentation and runbook completion
  \item Training for SecOps and development teams
  \item Full production rollout across organization
  \item Establish operational review cadence
\end{itemize}

% ===========================
\section{Appendix A: Webhook Payload Examples}
\label{sec:appendix-payloads}

\subsection{Code Scanning Alert Created (with Assignees)}
\label{subsec:code-scanning-payload}

\begin{lstlisting}[language=json,caption={Code Scanning Alert Webhook Payload}]
{
  "action": "created",
  "alert": {
    "number": 42,
    "created_at": "2026-01-14T10:30:00Z",
    "updated_at": "2026-01-14T10:30:00Z",
    "url": "https://api.github.com/repos/acme/api/code-scanning/alerts/42",
    "html_url": "https://github.com/acme/api/security/code-scanning/42",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "assignees": [
      {
        "login": "jsmith",
        "id": 12345,
        "type": "User"
      }
    ],
    "rule": {
      "id": "js/sql-injection",
      "severity": "error",
      "security_severity_level": "critical",
      "description": "SQL injection vulnerability",
      "name": "SQL Injection",
      "tags": ["security", "external/cwe/cwe-089"],
      "help": {
        "text": "Use parameterized queries..."
      }
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.23.8"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "state": "open",
      "commit_sha": "abc123def456",
      "location": {
        "path": "src/db/queries.js",
        "start_line": 42,
        "end_line": 42,
        "start_column": 10,
        "end_column": 55
      },
      "message": {
        "text": "User input flows to SQL query without sanitization"
      }
    }
  },
  "ref": "refs/heads/main",
  "commit_oid": "abc123def456",
  "repository": {
    "id": 987654,
    "name": "api",
    "full_name": "acme/api",
    "private": true,
    "default_branch": "main"
  },
  "organization": {
    "login": "acme",
    "id": 111222
  },
  "sender": {
    "login": "github-actions[bot]",
    "type": "Bot"
  }
}
\end{lstlisting}

\subsection{Secret Scanning Alert with Push Protection Bypass}
\label{subsec:secret-scanning-payload}

\begin{lstlisting}[language=json,caption={Secret Scanning Alert Webhook Payload}]
{
  "action": "created",
  "alert": {
    "number": 15,
    "created_at": "2026-01-14T11:00:00Z",
    "updated_at": "2026-01-14T11:00:00Z",
    "url": "https://api.github.com/repos/acme/api/secret-scanning/alerts/15",
    "html_url": "https://github.com/acme/api/security/secret-scanning/15",
    "locations_url": "https://api.github.com/repos/acme/api/secret-scanning/alerts/15/locations",
    "state": "open",
    "secret_type": "aws_access_key_id",
    "secret_type_display_name": "AWS Access Key ID",
    "secret": "[REDACTED - never stored]",
    "validity": "unknown",
    "push_protection_bypassed": true,
    "push_protection_bypassed_by": {
      "login": "developer",
      "id": 54321
    },
    "push_protection_bypassed_at": "2026-01-14T10:55:00Z",
    "resolution": null,
    "resolved_by": null,
    "resolved_at": null,
    "resolution_comment": null,
    "assignees": [
      {
        "login": "security-team",
        "id": 99999,
        "type": "Team"
      }
    ]
  },
  "repository": {
    "id": 987654,
    "name": "api",
    "full_name": "acme/api",
    "private": true
  },
  "organization": {
    "login": "acme",
    "id": 111222
  },
  "sender": {
    "login": "developer",
    "type": "User"
  }
}
\end{lstlisting}

% ===========================
\section{Appendix B: Normalized Event Envelope}
\label{sec:appendix-envelope}

\begin{lstlisting}[language=json,caption={Normalized Event Envelope for ServiceNow Staging}]
{
  "delivery_id": "550e8400-e29b-41d4-a716-446655440000",
  "event_type": "code_scanning_alert",
  "action": "created",
  "provider": "github",
  "organization": "acme",
  "repository": "acme/api",
  "alert_type": "code_scanning",
  "alert_number": 42,
  "canonical_key": "github:acme/api:code_scanning:42",
  "state": "open",
  "severity": "critical",
  "priority_computed": "P1",
  "rule_id": "js/sql-injection",
  "cwe_ids": ["CWE-089"],
  "assignees": ["jsmith"],
  "html_url": "https://github.com/acme/api/security/code-scanning/42",
  "autofix_available": true,
  "received_at": "2026-01-14T10:30:05Z",
  "processing_state": "received",
  "raw_payload_ref": "attachment_sys_id_or_hash"
}
\end{lstlisting}

% ===========================
\section{Appendix C: Primary References}
\label{sec:appendix-references}

\subsection{GitHub Documentation}
\begin{itemize}[leftmargin=1.5em]
  \item Webhook events and payloads --- \url{https://docs.github.com/en/webhooks/webhook-events-and-payloads}
  \item Validating webhook deliveries --- \url{https://docs.github.com/en/webhooks/using-webhooks/validating-webhook-deliveries}
  \item Auditing security alerts --- \url{https://docs.github.com/en/code-security/getting-started/auditing-security-alerts}
  \item REST API: Code scanning --- \url{https://docs.github.com/en/rest/code-scanning/code-scanning}
  \item REST API: Secret scanning --- \url{https://docs.github.com/en/rest/secret-scanning/secret-scanning}
  \item REST API: Dependabot alerts --- \url{https://docs.github.com/en/rest/dependabot/alerts}
  \item GitHub Apps --- \url{https://docs.github.com/en/apps}
\end{itemize}

\subsection{GitHub Changelog (2025)}
\begin{itemize}[leftmargin=1.5em]
  \item GitHub Secret Protection and Code Security --- \url{https://github.blog/changelog/2025-03-04-introducing-github-secret-protection-and-github-code-security/}
  \item Secret scanning alert assignees GA --- \url{https://github.blog/changelog/2025-11-25-secret-scanning-alert-assignees-security-campaigns-are-generally-available/}
  \item Code scanning alert assignees GA --- \url{https://github.blog/changelog/2025-12-16-code-scanning-alert-assignees-are-now-generally-available/}
\end{itemize}

\subsection{ServiceNow Documentation}
\begin{itemize}[leftmargin=1.5em]
  \item GitHub Application Vulnerability Integration --- \url{https://store.servicenow.com/store/app/006dafe21b646a50a85b16db234bcba2}
  \item Vulnerability Response documentation --- \url{https://www.servicenow.com/docs/bundle/security-management}
  \item ServiceNow DevOps Security Results action --- \url{https://github.com/ServiceNow/servicenow-devops-security-result}
  \item ServiceNow Vulnerability Response action --- \url{https://github.com/ServiceNow/vulnerability-response}
\end{itemize}

\vspace{2em}
\hrule
\vspace{1em}
\begin{center}
\textit{Document Version 2.0 --- January 14, 2026}\\
\textit{For questions or feedback, contact the AppSec Engineering team}
\end{center}

\end{document}
