
% !TEX TS-program = pdflatex
% Compile with: pdflatex -shell-escape dependabot-cheatsheet.tex
\documentclass[11pt,letterpaper]{article}

% ---------- Minted (CI-safe fallback) ----------
\usepackage{xparse}
\usepackage{iftex}
\usepackage{ifthen}

% Some repos run pdflatex without -shell-escape in CI.
% Use minted when shell-escape is enabled; otherwise fall back to listings.
\newif\ifciShellEscape
\ifdefined\pdfshellescape
  \ifnum\pdfshellescape=1\relax
    \ciShellEscapetrue
  \else
    \ciShellEscapefalse
  \fi
\else
  \ciShellEscapefalse
\fi

\ifciShellEscape
  \usepackage[newfloat]{minted}
\else
  \usepackage{listings}
  \usepackage{newfloat}
  \DeclareFloatingEnvironment[fileext=lol, listname={List of Listings}, name=Listing]{listing}

  % Basic listings defaults (safe for UTF-8 text in code blocks)
  \lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    breakatwhitespace=false,
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    tabsize=2,
    frame=single,
    upquote=true,
    % Common Unicode glyphs seen in docs/snippets
    literate=
      {•}{{\textbullet}}1
      {–}{{--}}1
      {—}{{---}}1
      {→}{{$\rightarrow$}}1
      {←}{{$\leftarrow$}}1
  }

  % Define a few common "languages" so listings won't error
  \lstdefinelanguage{yaml}{} 
  \lstdefinelanguage{json}{} 
  \lstdefinelanguage{bash}{} 
  \lstdefinelanguage{console}{} 
  \lstdefinelanguage{powershell}{} 
  \lstdefinelanguage{markdown}{} 
  \lstdefinelanguage{text}{} 

  % minted compatibility shims (ignore minted-style options safely)
  \NewDocumentEnvironment{minted}{ O{} m }{%
    \def\minted@opts{#1}%
    \def\minted@lang{#2}%
    \ifthenelse{\begingroup\edef\temp{\minted@opts}\endgroup\in@{linenos}{\temp}\relax=1\relax}{%
      \lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=6pt}%
    }{%
      \lstset{numbers=none}%
    }%
    \lstset{language=\minted@lang}%
    \begin{lstlisting}%
  }{%
    \end{lstlisting}%
  }

  \NewDocumentCommand{\mintinline}{ O{} m m }{\texttt{#3}}
  \NewDocumentCommand{\inputminted}{ O{} m m }{\lstinputlisting[language=#2]{#3}}

  \NewDocumentCommand{\setminted}{ O{} m }{}
  \NewDocumentCommand{\setmintedinline}{ O{} m }{}
  \NewDocumentCommand{\usemintedstyle}{ m }{}

  % \newminted{lang}{opts} -> defines an environment <lang>code
  \NewDocumentCommand{\newminted}{ m O{} }{%
    \NewDocumentEnvironment{#1code}{ O{} }{\begin{minted}{#1}}{\end{minted}}%
  }
  % \newmintedfile{lang}{opts} -> defines \input<lang>code{file}
  \NewDocumentCommand{\newmintedfile}{ m O{} }{%
    \expandafter\NewDocumentCommand\csname input#1code\endcsname{ m }{\inputminted{#1}{##1}}%
  }
\fi

% ---------- Encoding & fonts ----------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{inconsolata}  % monospace
\usepackage{microtype}

% ---------- Page & links ----------
\usepackage[margin=1in]{geometry}
\usepackage{parskip}
\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=black,
  urlcolor=blue,
  citecolor=black
}

% ---------- Colors ----------
\usepackage[dvipsnames]{xcolor}
\definecolor{CodeBg}{RGB}{248,248,248}
\definecolor{Accent}{RGB}{0,86,179}
\definecolor{NoteBg}{RGB}{240,248,255}

% ---------- Headings ----------
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries\color{Accent}}{\thesection}{0.6em}{}
\titleformat{\subsection}{\bfseries}{\thesubsection}{0.5em}{}
\titlespacing*{\section}{0pt}{8pt}{4pt}
\titlespacing*{\subsection}{0pt}{6pt}{3pt}

% ---------- Lists & tables ----------
\usepackage{enumitem}
\setlist{itemsep=2pt, topsep=4pt, leftmargin=1.1em}
\usepackage{booktabs}
\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\arraybackslash}p{#1}}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}

% ---------- Code (minted) ----------
\setminted{cache=false,
  fontsize=\small,
  breaklines=true,
  breakanywhere=true,
  bgcolor=CodeBg,
  frame=lines,
  framesep=2mm,
  autogobble=true,
  linenos
}
\usemintedstyle{friendly}

% ---------- Nice callouts ----------
\usepackage[most]{tcolorbox}
\tcbset{before skip=6pt, after skip=6pt}
\newtcolorbox{noteBox}{
  colback=NoteBg, colframe=Accent!60!black, sharp corners, boxrule=0.5pt
}

% ---------- Title ----------
\title{\textbf{Dependabot Alerts \& Workflows — Hands-On Cheatsheet}}
\author{}
\date{}

% ---------- Silence first-run missing .toc (prevents strict latexmk aborts) ----------
\makeatletter
\let\ci@orig@starttoc\@starttoc
\def\@starttoc#1{%
  \begingroup
  \IfFileExists{\jobname.#1}{\ci@orig@starttoc{#1}}{}%
  \endgroup
}
\makeatother

% ---------- Fix inconsolata/zi4 italic warning (fallback to slanted) ----------
\makeatletter
\@ifundefined{DeclareFontShape}{}{%
  \DeclareFontShape{T1}{zi4}{m}{it}{<->ssub*zi4/m/sl}{}
  \DeclareFontShape{T1}{zi4}{b}{it}{<->ssub*zi4/b/sl}{}
}
\makeatother

\begin{document}
\maketitle

\begin{noteBox}
\textbf{Heads-up:} This document uses \texttt{minted} for syntax highlighting. If you want actual GraphQL highlighting, install the Pygments lexer plugin \texttt{pygments-graphql} and switch the block back to \texttt{graphql}. Compile with: \texttt{pdflatex -shell-escape dependabot-cheatsheet.tex} (or \texttt{xelatex} with \texttt{-shell-escape}).
\end{noteBox}

\section{Core Concepts}
\begin{itemize}
  \item \textbf{Dependency types:} Direct dependencies are packages your code imports/uses. \textit{Transitive} dependencies are packages required by your direct dependencies.
  \item \textbf{Where alerts appear:} Security tab (repository overview), Pull Requests (as comments/checks), and via API/CLI.
  \item \textbf{Security updates:} Dependabot can automatically open PRs to bump vulnerable versions.
\end{itemize}

\section{Enable Security Updates}
Add or adjust \texttt{dependabot.yml} at repo/org level to scan ecosystems and open PRs automatically.
\begin{minted}[label=Minimal dependabot.yml]{yaml}
version: 2
updates:
  - package-ecosystem: "pip"        # npm, maven, gradle, gomod, etc.
    directory: "/"                  # location of manifest
    schedule:
      interval: "daily"             # daily, weekly, monthly
    open-pull-requests-limit: 5
    rebase-strategy: auto
    reviewers: ["team/security"]
    labels: ["dependencies","security"]
\end{minted}

\section{Triage \& Remediation Workflow}
\begin{enumerate}
  \item Review new alerts in \textbf{Security \textrightarrow\ Alerts} or in the PR that raised them.
  \item Validate severity, affected manifests, and suggested upgrade.
  \item Run tests locally and/or in CI (unit, integration, regression).
  \item Merge the Dependabot PR (or create one via \textit{Update now}) and monitor post-merge checks.
\end{enumerate}

\section{Query Alerts Programmatically}
\subsection{GraphQL API (curl)}
\begin{minted}[label=Query via GraphQL (replace TOKEN/owner/repo)]{bash}
curl -s -H "Authorization: bearer TOKEN" \
     -X POST https://api.github.com/graphql \
     -d '{"query":"
query {
  repository(owner:\"OWNER\", name:\"REPO\") {
    vulnerabilityAlerts(first: 20) {
      nodes {
        securityVulnerability { severity package { name } }
        vulnerableManifestFilename
        vulnerableRequirements
        createdAt
        state
      }
    }
  }
}"}' | jq .
\end{minted}

\subsection{GraphQL Shape}
% If your TeX setup lacks a GraphQL lexer, change the language below to `text`.
\begin{minted}[label=GraphQL selection set sketch]{text}
query {
  repository(owner: "OWNER", name: "REPO") {
    vulnerabilityAlerts(first: 20) {
      nodes {
        securityVulnerability { severity package { name } }
        vulnerableManifestFilename
        vulnerableRequirements
        createdAt state
      }
    }
  }
}
\end{minted}
\clearpage

\subsection{REST via GitHub CLI}
\begin{minted}[label=Fetch Dependabot alerts with gh api]{bash}
# Authenticate once
gh auth login --web --hostname github.com

# List alerts (REST): /repos/{owner}/{repo}/dependabot/alerts
gh api repos/OWNER/REPO/dependabot/alerts --paginate > alerts.json

# Convert to CSV (example jq shape)
jq -r '.[] | [
  .number,
  .state,
  .dependency.package.name,
  .security_advisory.severity,
  .security_vulnerability.severity,
  .created_at
] | @csv' alerts.json > alerts.csv
\end{minted}

\section{Working From the Security Tab or PR}
\begin{itemize}
  \item \textbf{Security tab:} Review alert details and use \textit{Update now} to spawn a security update PR.
  \item \textbf{Pull Request:} Dependabot comments highlight the vulnerable dependency and the safe version.
  \item \textbf{Change control:} PR discussion and reviews record decisions and provide traceability.
\end{itemize}

\section{Advisory Intelligence}
\begin{itemize}
  \item Browse the \textbf{GitHub Advisory Database} (filter by ecosystem, severity, CWE, newest).
  \item Use it to proactively check dependencies and plan upgrade windows.
\end{itemize}

\section{Dependabot CLI and Core}
\begin{itemize}
  \item \textbf{Dependabot Core:} Core logic is open source; backend services are proprietary to GitHub.
  \item \textbf{CLI:} Useful for local testing/debugging of update jobs.
\end{itemize}

\section{Automation Tips}
\begin{itemize}
  \item Ensure unit/integration tests run on Dependabot PRs.
  \item Consider grouping updates to reduce PR noise when appropriate.
  \item Label, auto-assign reviewers, and protect main branches with required checks.
\end{itemize}
\clearpage

\section{Quick Commands}
\begin{minted}{bash}
# Authenticate GitHub CLI (web flow)
gh auth login --web --hostname github.com

# List Dependabot alerts (REST)
gh api repos/OWNER/REPO/dependabot/alerts

# Example: narrow by severity (jq)
gh api repos/OWNER/REPO/dependabot/alerts \
 | jq '.[] | select(.security_advisory.severity=="critical")'
\end{minted}

\end{document}
