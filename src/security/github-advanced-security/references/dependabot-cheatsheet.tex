% !TEX TS-program = pdflatex
% Compile with: pdflatex -shell-escape dependabot-cheatsheet.tex
\documentclass[11pt,letterpaper]{article}

\titleformat{\section}{\large\bfseries\color{Accent}}{\thesection}{0.6em}{}
\titleformat{\subsection}{\bfseries}{\thesubsection}{0.5em}{}
\titlespacing*{\section}{0pt}{8pt}{4pt}
\titlespacing*{\subsection}{0pt}{6pt}{3pt}

% ---------- Lists & tables ----------
\usepackage{enumitem}
\setlist{itemsep=2pt, topsep=4pt, leftmargin=1.1em}
\usepackage{booktabs}
\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\arraybackslash}p{#1}}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}

% ---------- Nice callouts ----------
\usepackage[most]{tcolorbox}
\tcbset{before skip=6pt, after skip=6pt}
\newtcolorbox{noteBox}{
  colback=NoteBg, colframe=Accent!60!black, sharp corners, boxrule=0.5pt
}

% ---------- Title ----------

definecolor{soft}{HTML}{F3F4F6}
% ---------- Code blocks (listings only - CI safe) ----------
\usepackage{listings}
\usepackage{upquote}

\lstdefinelanguage{yaml}{
  keywords={true,false,null},
  sensitive=false,
  comment=[l]{\#},
  morestring=[b]',
  morestring=[b]"
}

\lstset{
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{soft},
  breaklines=true,
  breakatwhitespace=false,
  columns=fullflexible,
  keepspaces=true,
  showstringspaces=false,
  frame=single,
  framerule=0.4pt,
  tabsize=2,
  aboveskip=6pt,
  belowskip=6pt,
  literate=
    {—}{{---}}1
    {–}{{--}}1
    {→}{{$\rightarrow$}}1
}

% Minted-compatible environments
\lstnewenvironment{minted}[2][]{\lstset{}}{}
\newcommand{\mintinline}[3][]{\texttt{#3}}
\lstnewenvironment{bashcode}{\lstset{language=bash}}{}
\lstnewenvironment{yamlcode}{\lstset{language=yaml}}{}
\lstnewenvironment{jsoncode}{\lstset{}}{}
\lstnewenvironment{cmakecode}{\lstset{}}{}
\lstnewenvironment{textcode}{\lstset{}}{}
\lstnewenvironment{cppcode}{\lstset{language=C++}}{}
\lstnewenvironment{ccode}{\lstset{language=C}}{}
\lstnewenvironment{inicode}{\lstset{}}{}
\lstnewenvironment{pythoncode}{\lstset{language=Python}}{}

\title{\textbf{Dependabot Alerts \& Workflows — Hands-On Cheatsheet}}
\author{}
\date{}

% ---------- Silence first-run missing .toc (prevents strict latexmk aborts) ----------
\makeatletter
\let\ci@orig@starttoc\@starttoc
\def\@starttoc#1{%
  \begingroup
  \IfFileExists{\jobname.#1}{\ci@orig@starttoc{#1}}{}%
  \endgroup
}
\makeatother

% ---------- Fix inconsolata/zi4 italic warning (fallback to slanted) ----------
\makeatletter
\@ifundefined{DeclareFontShape}{}{%
  \DeclareFontShape{T1}{zi4}{m}{it}{<->ssub*zi4/m/sl}{}
  \DeclareFontShape{T1}{zi4}{b}{it}{<->ssub*zi4/b/sl}{}
}
\makeatother

\begin{document}
\maketitle

\begin{noteBox}
\textbf{Heads-up:} This document uses \texttt{minted} for syntax highlighting. If you want actual GraphQL highlighting, install the Pygments lexer plugin \texttt{pygments-graphql} and switch the block back to \texttt{graphql}. Compile with: \texttt{pdflatex -shell-escape dependabot-cheatsheet.tex} (or \texttt{xelatex} with \texttt{-shell-escape}).
\end{noteBox}

\section{Core Concepts}
\begin{itemize}
  \item \textbf{Dependency types:} Direct dependencies are packages your code imports/uses. \textit{Transitive} dependencies are packages required by your direct dependencies.
  \item \textbf{Where alerts appear:} Security tab (repository overview), Pull Requests (as comments/checks), and via API/CLI.
  \item \textbf{Security updates:} Dependabot can automatically open PRs to bump vulnerable versions.
\end{itemize}

\section{Enable Security Updates}
Add or adjust \texttt{dependabot.yml} at repo/org level to scan ecosystems and open PRs automatically.
\begin{minted}[label=Minimal dependabot.yml]{yaml}
version: 2
updates:
  - package-ecosystem: "pip"        # npm, maven, gradle, gomod, etc.
    directory: "/"                  # location of manifest
    schedule:
      interval: "daily"             # daily, weekly, monthly
    open-pull-requests-limit: 5
    rebase-strategy: auto
    reviewers: ["team/security"]
    labels: ["dependencies","security"]
\end{minted}

\section{Triage \& Remediation Workflow}
\begin{enumerate}
  \item Review new alerts in \textbf{Security \textrightarrow\ Alerts} or in the PR that raised them.
  \item Validate severity, affected manifests, and suggested upgrade.
  \item Run tests locally and/or in CI (unit, integration, regression).
  \item Merge the Dependabot PR (or create one via \textit{Update now}) and monitor post-merge checks.
\end{enumerate}

\section{Query Alerts Programmatically}
\subsection{GraphQL API (curl)}
\begin{minted}[label=Query via GraphQL (replace TOKEN/owner/repo)]{bash}
curl -s -H "Authorization: bearer TOKEN" \
     -X POST https://api.github.com/graphql \
     -d '{"query":"
query {
  repository(owner:\"OWNER\", name:\"REPO\") {
    vulnerabilityAlerts(first: 20) {
      nodes {
        securityVulnerability { severity package { name } }
        vulnerableManifestFilename
        vulnerableRequirements
        createdAt
        state
      }
    }
  }
}"}' | jq .
\end{minted}

\subsection{GraphQL Shape}
% If your TeX setup lacks a GraphQL lexer, change the language below to `text`.
\begin{minted}[label=GraphQL selection set sketch]{text}
query {
  repository(owner: "OWNER", name: "REPO") {
    vulnerabilityAlerts(first: 20) {
      nodes {
        securityVulnerability { severity package { name } }
        vulnerableManifestFilename
        vulnerableRequirements
        createdAt state
      }
    }
  }
}
\end{minted}
\clearpage

\subsection{REST via GitHub CLI}
\begin{minted}[label=Fetch Dependabot alerts with gh api]{bash}
# Authenticate once
gh auth login --web --hostname github.com

# List alerts (REST): /repos/{owner}/{repo}/dependabot/alerts
gh api repos/OWNER/REPO/dependabot/alerts --paginate > alerts.json

# Convert to CSV (example jq shape)
jq -r '.[] | [
  .number,
  .state,
  .dependency.package.name,
  .security_advisory.severity,
  .security_vulnerability.severity,
  .created_at
] | @csv' alerts.json > alerts.csv
\end{minted}

\section{Working From the Security Tab or PR}
\begin{itemize}
  \item \textbf{Security tab:} Review alert details and use \textit{Update now} to spawn a security update PR.
  \item \textbf{Pull Request:} Dependabot comments highlight the vulnerable dependency and the safe version.
  \item \textbf{Change control:} PR discussion and reviews record decisions and provide traceability.
\end{itemize}

\section{Advisory Intelligence}
\begin{itemize}
  \item Browse the \textbf{GitHub Advisory Database} (filter by ecosystem, severity, CWE, newest).
  \item Use it to proactively check dependencies and plan upgrade windows.
\end{itemize}

\section{Dependabot CLI and Core}
\begin{itemize}
  \item \textbf{Dependabot Core:} Core logic is open source; backend services are proprietary to GitHub.
  \item \textbf{CLI:} Useful for local testing/debugging of update jobs.
\end{itemize}

\section{Automation Tips}
\begin{itemize}
  \item Ensure unit/integration tests run on Dependabot PRs.
  \item Consider grouping updates to reduce PR noise when appropriate.
  \item Label, auto-assign reviewers, and protect main branches with required checks.
\end{itemize}
\clearpage

\section{Quick Commands}
\begin{minted}{bash}
# Authenticate GitHub CLI (web flow)
gh auth login --web --hostname github.com

# List Dependabot alerts (REST)
gh api repos/OWNER/REPO/dependabot/alerts

# Example: narrow by severity (jq)
gh api repos/OWNER/REPO/dependabot/alerts \
 | jq '.[] | select(.security_advisory.severity=="critical")'
\end{minted}

\end{document}