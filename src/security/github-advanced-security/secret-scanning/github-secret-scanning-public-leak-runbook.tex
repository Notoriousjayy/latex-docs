% !TeX program = pdflatex
\documentclass[11pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage[hidelinks]{hyperref}
\usepackage{fancyhdr}
\usepackage{verbatim}
\usepackage{tcolorbox}

\setlist[itemize]{leftmargin=*, itemsep=0.35em, topsep=0.35em}
\setlist[enumerate]{leftmargin=*, itemsep=0.35em, topsep=0.35em}

\definecolor{Gray}{gray}{0.25}
\definecolor{LightGray}{gray}{0.94}

\hypersetup{
  pdftitle={GitHub Secret Scanning Runbook: Public Leak Alerts},
  pdfauthor={},
  pdfsubject={Incident response runbook for GitHub Secret Scanning public leak alerts},
  pdfkeywords={GitHub, secret scanning, public leak, multi-repo, validity checks, runbook}
}

\pagestyle{fancy}
\setlength{\headheight}{14pt}
\fancyhf{}
\lhead{\textbf{GitHub Secret Scanning Runbook}}
\rhead{\textbf{Public Leak Alerts}}
\cfoot{\thepage}

\newcommand{\term}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}

\title{\textbf{GitHub Secret Scanning Runbook}\\
\large Handling ``Public leak'' Alerts (with guidance for \code{.vsext} and similar extension/config files)}
\author{%
  % Add your team / org name here
}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
This runbook provides a complete, decision-oriented procedure for triaging and resolving GitHub Secret Scanning alerts labeled \emph{public leak}. It includes: indicators and related indicators; interpretation of \code{.vsext} (and similar) files; recommended actions and safer alternatives for example/onboarding repositories; the rationale behind GitHub's \emph{public leak} designation; and step-by-step verification and resolution workflows, including a professional dismissal message template (``Used in tests'').
\end{abstract}

\tableofcontents
\newpage

\section{Purpose, Scope, and Audience}
\subsection{Purpose}
Provide a standardized incident response and governance workflow for GitHub Secret Scanning alerts labeled \term{public leak}, with special attention to scenarios where the flagged string appears in \code{.vsext} or other extension/configuration artifacts used for onboarding or repository examples.

\subsection{Scope}
This runbook covers:
\begin{itemize}
  \item GitHub Secret Scanning alert triage for provider-based and generic patterns.
  \item Interpretation of the \term{public leak} and \term{multi-repo} indicators.
  \item Validity checks and the meaning of \term{active}, \term{inactive}, and \term{unknown} statuses.
  \item Remediation for confirmed secrets (revoke/rotate, history cleanup, closure).
  \item Handling false positives and ``Used in tests'' scenarios.
  \item Example repository alternatives that preserve onboarding value without embedding real secrets.
  \item Practical operational steps (UI steps, command snippets, and decision tables) suitable for repeatable execution.
\end{itemize}

Out of scope (but referenced where helpful): deep provider-specific credential forensics, legal response playbooks, and platform-specific secret-manager implementation details.

\subsection{Audience}
\begin{itemize}
  \item Application Security (AppSec) and Product Security
  \item Platform Engineering / DevOps / SRE
  \item Repository administrators and maintainers
  \item Security Operations (SecOps) / Incident Response (IR)
\end{itemize}

\subsection{Assumptions}
\begin{itemize}
  \item The repository has Secret Scanning enabled (or a user-level push protection event has created an alert).
  \item The responder can coordinate token rotation with the credential owner (service team or account owner).
  \item The organization treats \emph{public exposure} of real credentials as a security incident (recommended).
\end{itemize}

\section{Definitions and Core Concepts}
\subsection{GitHub Secret Scanning}
GitHub Secret Scanning identifies known credential patterns (partner patterns) and can also detect generic secrets (e.g., private keys or AI-detected passwords) to generate alerts in the repository \code{Security} tab. See GitHub Docs: \href{https://docs.github.com/code-security/secret-scanning/about-secret-scanning}{About secret scanning}.

\subsection{The ``Public leak'' Indicator (What it means)}
GitHub applies a \term{public leak} label when the secret detected in your repository \emph{has also been found in a public location on GitHub.com}. GitHub describes these public locations as including scans of public \emph{code, discussions, gists, issues, pull requests, and wikis}. When present, GitHub may provide links to public locations where the exact string was detected. See: \href{https://docs.github.com/en/enterprise-cloud@latest/code-security/tutorials/remediate-leaked-secrets/evaluating-alerts}{Evaluating alerts (labels table)}.

\subsection{Related Indicator: ``Multi-repo''}
GitHub applies a \term{multi-repo} label when the same secret appears across multiple repositories within an organization or enterprise. This influences prioritization because blast radius is larger. See changelog: \href{https://github.blog/changelog/2024-09-19-secret-scanning-indicates-known-public-leaks-and-duplicate-alerts-for-private-exposures-public-beta/}{Known public leaks and multi-repo labels}.

\subsection{Validity Checks and Validity Statuses}
Validity checks help prioritize alerts by indicating whether a detected secret is currently usable. GitHub commonly uses:
\begin{itemize}
  \item \term{active}: the secret could still be exploited.
  \item \term{inactive}: the secret appears revoked/invalid.
  \item \term{unknown}: GitHub cannot determine validity (no check, or provider does not support/enable it).
\end{itemize}
See GitHub Docs: \href{https://docs.github.com/code-security/secret-scanning/managing-alerts-from-secret-scanning/evaluating-alerts}{Evaluating alerts} and \href{https://docs.github.com/en/enterprise-cloud@latest/code-security/how-tos/secure-your-secrets/customize-leak-detection/enabling-validity-checks-for-your-repository}{Enabling validity checks}.

\subsection{Why ``Validity'' and ``Public leak'' Are Separate}
\begin{itemize}
  \item \term{Public leak} describes \emph{where the string exists} (publicly visible on GitHub.com).
  \item \term{Validity status} describes \emph{whether the string still works} as a credential.
\end{itemize}
A public leak with \term{inactive} validity can still represent risk (e.g., it may indicate prior compromise or poor hygiene), but the exploitability is reduced if revocation is confirmed.

\section{Indicators and Related Indicators}
\subsection{Primary Indicators (GitHub Alert Metadata)}
Use these to classify urgency and choose the correct remediation path:
\begin{itemize}
  \item \term{Public leak}: the same string is present somewhere public on GitHub.com (higher likelihood of exploitation).
  \item \term{Multi-repo}: the same string appears in other repos in the org/enterprise (larger blast radius).
  \item \term{Validity status}: active / inactive / unknown (prioritization signal).
  \item \term{Secret type}: provider partner pattern vs generic secret detection (false-positive rate differs).
  \item \term{Leak locations}: links to public occurrences (when available) enable faster scoping.
  \item \term{Alert timeline}: review who accessed/acknowledged/assigned/closed the alert and when.
\end{itemize}

\subsection{Related Indicators (Environment and Provider Signals)}
Even if GitHub metadata is incomplete, treat the following as escalation triggers:
\begin{itemize}
  \item Provider logs show anomalous token usage (unexpected IPs, user agents, geo, time-of-day).
  \item A token grants write/publish capability (e.g., extension publishing, package publishing, CI/CD, cloud admin).
  \item The leaked string appears in \emph{multiple} files or commits, or across multiple branches/tags/releases.
  \item The repository is public or mirrored/forked into public space.
  \item Automated revocation has already occurred (provider disabled token) but code still references it (risk of outages).
\end{itemize}

\section{Meaning of the Tag for \code{.vsext} Files and Similar Extensions}
\subsection{What \code{.vsext} Typically Is}
The \code{.vsext} file extension is commonly used in the Visual Studio ecosystem as:
\begin{itemize}
  \item An \emph{extension pack} descriptor included at the root of a Visual Studio extension pack project. Microsoft Learn notes: ``The \code{.vsext} file in the root of your project is what turns the project into an extension pack.'' \href{https://learn.microsoft.com/en-us/visualstudio/extensibility/vsix/publish/create-extension-pack?view=visualstudio}{Create an extension pack}.
  \item A JSON-formatted export describing a set of installed extensions associated with a solution or environment (extension manager workflows). Visual Studio Marketplace listings for ``Extension Manager'' describe generating a \code{.vsext} file containing selected extensions. \href{https://marketplace.visualstudio.com/items?itemName=Loop8ack.ExtensionManager2022}{Extension Manager 2022}.
\end{itemize}

In other words, \code{.vsext} is frequently a \emph{manifest-like} or \emph{list-like} file that stores extension identifiers and metadata.

\subsection{Common Safe Content vs Common Risk Content}
\begin{itemize}
  \item \textbf{Common safe content:} extension IDs, product IDs, publisher names, versions, and URLs that are intended to be public.
  \item \textbf{Common risk content:} any bearer token, PAT, API key, publishing credential, or registry credential added to ``make onboarding easy''.
\end{itemize}

\subsection{Similar Files and Extensions to Treat as High-Risk for Secret Leakage}
If an onboarding/example repository is designed to demonstrate environment configuration, these files frequently become accidental secret sinks:
\begin{itemize}
  \item \code{.env}, \code{.envrc}, \code{*.properties}, \code{*.ini}, \code{*.yaml}, \code{*.json}, \code{settings.json}
  \item Package manager auth files: \code{.npmrc}, \code{.pypirc}, \code{pip.conf}, \code{NuGet.Config}
  \item Cloud/CLI credential files: \code{credentials}, \code{config}, \code{*.pem}, \code{*.p12}, \code{*.key}
  \item CI/CD configuration: workflow files, pipeline descriptors, \code{devcontainer.json} (when misused)
  \item Extension packaging/manifest artifacts: \code{.vsix}, \code{.vsixmanifest}, extension metadata
\end{itemize}

\subsection{Example \code{.vsext} Shape (Illustrative)}
Many \code{.vsext} files are JSON-like lists of extensions. The exact schema may vary by tool. The following is an illustrative (sanitized) example:
\begin{verbatim}
{
  "extensions": [
    { "id": "publisher.extensionName", "displayName": "Example Extension" },
    { "id": "anotherPublisher.anotherExtension", "displayName": "Another Extension" }
  ]
}
\end{verbatim}
If your \code{.vsext} contains fields like \code{token}, \code{secret}, \code{pat}, \code{apiKey}, or a long high-entropy string used for authentication, treat it as a likely secret leak.

\section{Why GitHub Flags This as a ``Public Leak''}
\subsection{The Practical Meaning: Elevated Exploit Likelihood}
GitHub treats a public leak as high urgency because the same string is already outside your repository boundary and visible in at least one public location on GitHub.com (code, discussions, gists, issues, pull requests, or wikis). GitHub surfaces links to known public leak locations when available. See: \href{https://docs.github.com/en/enterprise-cloud@latest/code-security/tutorials/remediate-leaked-secrets/evaluating-alerts}{Evaluating alerts (labels table)}.

\subsection{How GitHub Identifies a Public Leak (Operational Model)}
While GitHub does not publish detailed detection internals, the \emph{public leak} label is an observed correlation signal:
\begin{enumerate}
  \item GitHub detects a credential pattern in your repository (partner pattern or generic secret detection).
  \item GitHub observes the \emph{exact same string} in one or more public locations it scans.
  \item GitHub annotates your alert with the \term{public leak} label and, when possible, provides references to those public locations.
\end{enumerate}

\subsection{Why GitHub Flags ``Example'' Repositories}
Even when a repository is explicitly meant to teach standards:
\begin{itemize}
  \item Public repositories are continuously scanned by automated attackers looking for usable credentials.
  \item ``Dev'' or ``example'' environment access is frequently leveraged for lateral movement.
  \item Some providers participate in automated leakage response programs (notification and/or revocation). This can create operational risk if a token is disabled unexpectedly.
\end{itemize}

\section{Pre-Flight Readiness Review}
Complete this checklist \emph{before} making changes:
\begin{longtable}{@{}p{0.30\linewidth}p{0.65\linewidth}@{}}
\toprule
\textbf{Item} & \textbf{Check} \\
\midrule
Access & You have repository admin rights (or have engaged the repo admin) to view and resolve secret scanning alerts. \\
Repo context & Confirm repository visibility (public/private), fork/mirror status, and whether it is an onboarding/example repository. \\
Alert context & Capture: secret type, labels (public leak, multi-repo), validity status, file path(s), commit(s), branch(es). \\
Ownership & Identify the system owner for the credential (team/service/provider account). \\
Provider readiness & Confirm ability to revoke/rotate quickly (provider console access, break-glass path, on-call contacts). \\
Change control & If required, open an incident/ticket and define a communication channel. \\
Evidence preservation & Snapshot alert details and affected commits before rewriting history (screenshots/links/timeline notes). \\
\bottomrule
\end{longtable}

\section{Triage Workflow (Decision-First)}
\subsection{Step 1: Classify the Alert}
\begin{enumerate}
  \item \textbf{Confirm alert category:} provider partner pattern vs generic secret detection.
  \item \textbf{Record indicators:} \term{public leak}, \term{multi-repo}, and \term{validity status}.
  \item \textbf{Locate the value:} identify file path(s) and whether the string is embedded, generated, or referenced.
\end{enumerate}

\subsection{Step 2: Determine What the Value Actually Is}
Use these fast tests:
\begin{itemize}
  \item \textbf{Identifier vs credential:} Extension IDs, publisher IDs, and product IDs are typically public.
  \item \textbf{Grants access?} If used to authenticate (API key, PAT, OAuth token, publishing token), treat as a secret.
  \item \textbf{Validity status:} If \term{active} or \term{unknown}, assume compromise unless conclusively proven otherwise.
  \item \textbf{Public leak locations:} If leak locations show many public occurrences consistent with a public ID, investigate false positive likelihood.
\end{itemize}

\subsection{Step 3: Decision Matrix (Recommended)}
\begin{longtable}{@{}p{0.18\linewidth}p{0.21\linewidth}p{0.22\linewidth}p{0.31\linewidth}@{}}
\toprule
\textbf{Public leak?} & \textbf{Validity} & \textbf{What it likely is} & \textbf{Default response} \\
\midrule
Yes & Active & Real secret & Immediate revoke/rotate; remove from code/history; close as Revoked. \\
Yes & Unknown & Real secret OR ambiguous & Treat as secret until proven public ID; revoke/rotate if uncertain; investigate leak locations. \\
Yes & Inactive & Revoked secret OR public ID & Confirm revocation or non-secret; remove if secret; close as Revoked or False positive. \\
No & Active & Real secret & Revoke/rotate promptly; remove; close as Revoked. \\
No & Unknown & Ambiguous & Investigate; err on side of revocation if any access risk exists. \\
Any & Any & Confirmed public ID & Close as False positive/Used in tests with justification; harden onboarding approach. \\
\bottomrule
\end{longtable}

\subsection{Step 4: Severity Assignment (Recommended)}
\begin{longtable}{@{}p{0.23\linewidth}p{0.18\linewidth}p{0.52\linewidth}@{}}
\toprule
\textbf{Condition} & \textbf{Severity} & \textbf{Default posture} \\
\midrule
Public leak + validity active & SEV-1 (Critical) & Immediate revoke/rotate; treat as exploited until disproven. \\
Public leak + validity unknown & SEV-1 (Critical) & Immediate revoke/rotate unless conclusively a public ID/non-secret. \\
No public leak + validity active & SEV-2 (High) & Revoke/rotate promptly; investigate exposure scope. \\
Validity inactive (any) & SEV-3 (Medium) & Confirm revocation; remove from repo; close as revoked. \\
Confirmed public ID/non-secret & SEV-4 (Low) & Close as false positive/used in tests with justification; prevent recurrence. \\
\bottomrule
\end{longtable}

\section{Remediation Playbooks}
\subsection{Playbook A: Confirmed Secret (or Cannot Disprove Secret)}
\subsubsection{Goal}
Eliminate exploitability quickly and reduce recurrence.

\subsubsection{Recommended Actions}
\begin{enumerate}
  \item \textbf{Revoke and rotate immediately.} Deleting from the repository is not sufficient; secrets persist in Git history and caches.
  \item \textbf{Remove from code and configuration.} Replace with a placeholder and retrieve secrets at runtime.
  \item \textbf{Purge from Git history (as needed).} Use a history rewrite approach (e.g., \code{git-filter-repo}) if the repo is public or widely cloned.
  \item \textbf{Close the alert as ``Revoked''} after rotation/removal. GitHub notes secret scanning does not automatically close alerts when tokens are removed; you must close them manually. \href{https://docs.github.com/code-security/secret-scanning/managing-alerts-from-secret-scanning/resolving-alerts}{Resolving alerts}.
  \item \textbf{Investigate usage.} Review provider logs for suspicious activity during the exposure window.
  \item \textbf{Document and follow up.} Record root cause, timeline, and prevention actions.
\end{enumerate}

\subsubsection{Operational Notes: History Rewriting}
If you rewrite history:
\begin{itemize}
  \item Coordinate with repository owners (force-push impacts collaborators).
  \item Rotate/revoke \emph{before} rewriting history (rewriting does not protect a still-valid secret).
  \item Assume downstream clones/forks may retain the secret; rotate is the only reliable containment.
\end{itemize}

\subsubsection{Example Commands (Sanitized)}
\begin{verbatim}
# 1) Rotate/revoke at the provider FIRST.

# 2) Remove the string from current code.
git checkout main
# edit files to remove the secret and commit

# 3) OPTIONAL: scrub history (example pattern-based removal)
# (Review tool documentation and test in a clone.)
git filter-repo --path path/to/file --invert-paths

# 4) Force push rewritten history (coordinate beforehand)
git push --force --all
git push --force --tags
\end{verbatim}

\subsection{Playbook B: Intentional Non-Production/Test Token (``Used in tests'')}
\subsubsection{Prerequisites (must be true)}
\begin{itemize}
  \item The value does not grant access to protected resources (or only to isolated, disposable test resources).
  \item The value is \emph{not} usable outside the test context (preferably demonstrably invalid/inactive).
  \item The repository purpose justifies keeping the string (e.g., training, onboarding exercises).
\end{itemize}

\subsubsection{Recommended Actions}
\begin{enumerate}
  \item Prefer replacing the token with a \textbf{non-functional placeholder} (best practice).
  \item If the string must remain for training exercises:
  \begin{itemize}
    \item Ensure the value is invalid/inactive (rotate/revoke it if needed).
    \item Close the alert with the resolution reason \term{Used in tests} and add a professional justification.
    \item Add guardrails so real secrets cannot be reintroduced (push protection, pre-commit scanning, CI checks).
  \end{itemize}
  \item If push protection is involved, GitHub requires a bypass reason, and may create alerts resolved as ``used in tests'' when bypassed. See: \href{https://docs.github.com/en/code-security/concepts/secret-security/about-push-protection}{About push protection}.
\end{enumerate}

\subsection{Playbook C: Public ID / False Positive (Common for \code{.vsext} Identifiers)}
\subsubsection{Why a Public ID Might Be Flagged}
\begin{itemize}
  \item \textbf{Pattern matching:} some public identifiers resemble partner credential formats.
  \item \textbf{Public leak correlation:} the exact string is found elsewhere publicly on GitHub (expected for widely used IDs).
  \item \textbf{Detection category differences:} generic secret detection can have higher false-positive rates and ``secrets used in tests.'' See: \href{https://docs.github.com/en/code-security/concepts/secret-security/about-alerts}{About secret scanning alerts}.
  \item \textbf{Pair matching limitations:} some patterns use ``pair matching'' to reduce false positives, but not all patterns support it. GitHub discusses pair matching in troubleshooting documentation. \href{https://docs.github.com/en/code-security/secret-scanning/troubleshooting-secret-scanning-and-push-protection/troubleshooting-secret-scanning}{Troubleshooting secret scanning}.
\end{itemize}

\subsubsection{How to Verify and Resolve}
\begin{enumerate}
  \item \textbf{Confirm what the string represents:} extension ID vs publishing token vs API token.
  \item \textbf{Confirm it is not used for authentication:} search the codebase for where it is consumed.
  \item \textbf{Check validity status:} if \term{active/unknown} and any chance it is a credential, rotate/revoke.
  \item \textbf{Close the alert appropriately:} \term{False positive} if not a secret; \term{Used in tests} if intentionally included for training.
  \item \textbf{Make recurrence unlikely:} replace onboarding content with placeholders/templates; enable push protection and scanning.
\end{enumerate}

\section{Better Alternatives for Your Example Repo}
If the repository is designed to teach coding standards or environment setup, do \emph{not} store real secrets. Use one or more of the following patterns.

\subsection{Alternative 1: Placeholder Values (Most Common)}
Keep the instructional structure while removing risk:
\begin{itemize}
  \item Replace values with \code{<ENTER\_TOKEN\_HERE>} or \code{YOUR\_TOKEN\_HERE}.
  \item Explain where to obtain the token, and the minimum permissions/scope it should have.
\end{itemize}

\subsection{Alternative 2: Template Files}
Provide \code{.example} templates and instruct developers to copy locally:
\begin{itemize}
  \item \code{.env.example} $\rightarrow$ developer copies to \code{.env}.
  \item \code{settings.example.json} $\rightarrow$ developer copies to \code{settings.json}.
  \item \code{extensions.vsext.example} $\rightarrow$ developer copies to \code{extensions.vsext}.
\end{itemize}

\subsection{Alternative 3: Codespaces / Dev Containers with Secrets}
If developers use GitHub Codespaces, store secrets in Codespaces/Repository/Organization secrets rather than code. The environment remains ``configured'' without exposing a token in Git history.

\subsection{Alternative 4: Short-Lived Credentials / Federated Auth}
Prefer mechanisms that avoid long-lived tokens in developer workflows:
\begin{itemize}
  \item OIDC-based federation for CI to obtain short-lived cloud credentials.
  \item Provider-specific short-lived tokens with least privilege and strict scopes.
\end{itemize}

\subsection{Alternative 5: Local Secret Managers}
Use OS keychains or secret managers for developer local environments and reference them via tooling, not hard-coded values.

\section{Recommended Action (Single-Page Summary)}
\begin{tcolorbox}[colback=LightGray,colframe=Gray,title=Recommended Action Summary]
\begin{enumerate}
  \item If \textbf{public leak} and validity is \textbf{active/unknown}: treat as compromised; revoke/rotate immediately; remove from repo and history; close alert as \textbf{Revoked}.
  \item If the value is a \textbf{public identifier} (e.g., extension ID): confirm it is not used for authentication; close as \textbf{False positive} or \textbf{Used in tests} with a strong justification; harden to prevent real secrets from being added.
  \item For onboarding/example repositories: replace live tokens with placeholders and template files; prefer Codespaces/secret managers for real values.
\end{enumerate}
\end{tcolorbox}

\section{How to Verify and Resolve (UI and API)}
\subsection{UI Procedure to Close Alerts}
GitHub requires manual closure; removal from code does not automatically close the alert. See: \href{https://docs.github.com/code-security/secret-scanning/managing-alerts-from-secret-scanning/resolving-alerts}{Resolving alerts from secret scanning}.
\begin{enumerate}
  \item Open repository on GitHub.
  \item Navigate to \code{Security} $\rightarrow$ \code{Secret scanning}.
  \item Open the relevant alert and review labels (public leak, multi-repo) and validity status.
  \item Select \code{Close as} and choose the appropriate resolution reason (\term{Revoked}, \term{False positive}, \term{Used in tests}, etc.).
  \item Add a clear resolution comment (recommended for auditability and future maintainers).
\end{enumerate}

\subsection{API Automation (Optional)}
For organizations that automate triage and reporting, GitHub provides REST API endpoints to update alert status and read/write resolution comments. See: \href{https://docs.github.com/en/rest/secret-scanning/secret-scanning}{REST API endpoints for secret scanning}. GitHub also added support for public leak and multi-repo indicators in webhook and audit log events. See: \href{https://github.blog/changelog/2024-10-24-secret-scanning-support-for-public-leak-and-multi-repository-indicators-in-webhook-and-audit-log-events/}{Secret scanning webhook/audit log support}.

\section{Option 1: Detailed \& Professional (Recommended)}
Use the following text when closing an alert as \term{Used in tests} (or as \term{False positive} with minor edits).

\begin{tcolorbox}[colback=LightGray,colframe=Gray,title=Dismissal Message (Detailed \& Professional)]
This value is a publicly available extension identifier and not a functional private secret. It is intentionally included in this \code{.vsext} file for educational/onboarding purposes to demonstrate environment configuration standards in an example repository. The value does not grant access to any protected resources and is safe to remain in source control.
\end{tcolorbox}

\subsection{Alternate Short Messages (Optional)}
\begin{itemize}
  \item \textbf{Short \& Direct:} Non-sensitive public identifier used for onboarding examples. No credential risk.
  \item \textbf{Context-Specific:} Public Visual Studio extension ID (not a token). Included to show configuration patterns.
\end{itemize}

\section{Appendix A: Quick Reference Tables}
\subsection{Label and Status Interpretation}
\begin{longtable}{@{}p{0.22\linewidth}p{0.72\linewidth}@{}}
\toprule
\textbf{Signal} & \textbf{Interpretation / Action} \\
\midrule
Public leak & Same string observed publicly on GitHub.com; prioritize due to higher exploit likelihood. \\
Multi-repo & Same string appears in multiple repos; investigate blast radius and shared secret practices. \\
Validity: active & Likely exploitable; revoke/rotate immediately. \\
Validity: inactive & Likely revoked; remove from repo and close as revoked; confirm replacement in systems. \\
Validity: unknown & Treat as potentially exploitable until proven otherwise (or verified as public ID). \\
\bottomrule
\end{longtable}

\subsection{Resolution Reasons: Guidance}
\begin{longtable}{@{}p{0.22\linewidth}p{0.72\linewidth}@{}}
\toprule
\textbf{Close as} & \textbf{When to use} \\
\midrule
Revoked & Secret was rotated/revoked at the provider and removed from code. \\
Used in tests & Intentionally present for training/tests, non-production, not granting access (ideally invalid). \\
False positive & The string is not a secret (e.g., a public identifier). \\
Won't fix & Avoid unless formally approved; may be appropriate for non-actionable low-risk cases. \\
\bottomrule
\end{longtable}

\section{Appendix B: References}
\begin{itemize}
  \item GitHub Docs: About secret scanning\\
    \href{https://docs.github.com/code-security/secret-scanning/about-secret-scanning}{https://docs.github.com/code-security/secret-scanning/about-secret-scanning}
  \item GitHub Docs: Evaluating alerts from secret scanning\\
    \href{https://docs.github.com/code-security/secret-scanning/managing-alerts-from-secret-scanning/evaluating-alerts}{https://docs.github.com/code-security/secret-scanning/managing-alerts-from-secret-scanning/evaluating-alerts}
  \item GitHub Docs: Resolving alerts from secret scanning\\
    \href{https://docs.github.com/code-security/secret-scanning/managing-alerts-from-secret-scanning/resolving-alerts}{https://docs.github.com/code-security/secret-scanning/managing-alerts-from-secret-scanning/resolving-alerts}
  \item GitHub Docs: About secret scanning alerts\\
    \href{https://docs.github.com/en/code-security/concepts/secret-security/about-alerts}{https://docs.github.com/en/code-security/concepts/secret-security/about-alerts}
  \item GitHub Docs: Troubleshooting secret scanning\\
    \href{https://docs.github.com/en/code-security/secret-scanning/troubleshooting-secret-scanning-and-push-protection/troubleshooting-secret-scanning}{https://docs.github.com/en/code-security/secret-scanning/troubleshooting-secret-scanning-and-push-protection/troubleshooting-secret-scanning}
  \item GitHub Docs: About push protection\\
    \href{https://docs.github.com/en/code-security/concepts/secret-security/about-push-protection}{https://docs.github.com/en/code-security/concepts/secret-security/about-push-protection}
  \item GitHub Changelog: Known public leaks and duplicate alerts\\
    \href{https://github.blog/changelog/2024-09-19-secret-scanning-indicates-known-public-leaks-and-duplicate-alerts-for-private-exposures-public-beta/}{https://github.blog/changelog/2024-09-19-secret-scanning-indicates-known-public-leaks-and-duplicate-alerts-for-private-exposures-public-beta/}
  \item GitHub Changelog: Webhook and audit log support for public leak/multi-repo indicators\\
    \href{https://github.blog/changelog/2024-10-24-secret-scanning-support-for-public-leak-and-multi-repository-indicators-in-webhook-and-audit-log-events/}{https://github.blog/changelog/2024-10-24-secret-scanning-support-for-public-leak-and-multi-repository-indicators-in-webhook-and-audit-log-events/}
  \item Microsoft Learn: Create an extension pack (\code{.vsext})\\
    \href{https://learn.microsoft.com/en-us/visualstudio/extensibility/vsix/publish/create-extension-pack?view=visualstudio}{https://learn.microsoft.com/en-us/visualstudio/extensibility/vsix/publish/create-extension-pack?view=visualstudio}
  \item Visual Studio Marketplace: Extension Manager 2022 (\code{.vsext})\\
    \href{https://marketplace.visualstudio.com/items?itemName=Loop8ack.ExtensionManager2022}{https://marketplace.visualstudio.com/items?itemName=Loop8ack.ExtensionManager2022}
\end{itemize}

\end{document}
