% !TEX TS-program = pdflatex
\documentclass[11pt,a4paper]{article}

% -------------------- Packages --------------------
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\IfFileExists{inconsolata.sty}{\usepackage{inconsolata}}{\usepackage{zi4}}
\usepackage{upquote}
\usepackage{microtype}
\usepackage[margin=1in]{geometry}
\usepackage{parskip}
\usepackage[hyphens]{url}
\usepackage{hyperref}
\usepackage{bookmark}
\usepackage{enumitem}
\usepackage[dvipsnames]{xcolor}
\usepackage{booktabs}
\usepackage{array}
\usepackage{ragged2e}
\usepackage[most]{tcolorbox}
\usepackage{amsmath,amssymb}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{listings}

% -------------------- Readability Tweaks --------------------
\linespread{1.03}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.55em}
\setlength{\emergencystretch}{2em}
\renewcommand{\arraystretch}{1.12}
\raggedbottom
\clubpenalty=10000
\widowpenalty=10000
\displaywidowpenalty=10000
\titlespacing*{\section}{0pt}{0.9em}{0.35em}
\titlespacing*{\subsection}{0pt}{0.75em}{0.25em}
\setlist{leftmargin=*,itemsep=2pt,topsep=4pt}
\setlist[itemize]{itemsep=2pt}
\setlist[enumerate]{itemsep=2pt}

% -------------------- Colors --------------------
\definecolor{Primary}{HTML}{0E7490}
\definecolor{Accent}{HTML}{0EA5E9}
\definecolor{Soft}{HTML}{F1F5F9}
\definecolor{Ink}{HTML}{0F172A}
\definecolor{Meta}{HTML}{475569}
\definecolor{OK}{HTML}{16A34A}
\definecolor{Warn}{HTML}{EA580C}
\definecolor{Bad}{HTML}{DC2626}

\hypersetup{
  colorlinks=true,
  linkcolor=Primary,
  urlcolor=Primary,
  citecolor=Primary,
  breaklinks=true,
  pdfauthor={},
  pdftitle={User Story Template & Guide}
}
\urlstyle{same}
\titleformat{\section}{\large\bfseries\color{Ink}}{\thesection}{0.6em}{}
\titleformat{\subsection}{\normalsize\bfseries\color{Ink}}{\thesubsection}{0.6em}{}

\newcommand{\checkbox}{\(\square\)}
\newcommand{\checkedbox}{\(\blacksquare\)}
\newcommand{\eg}{e.g.\ }
\newcommand{\ie}{i.e.\ }

% -------------------- Gherkin (listings) --------------------
\lstdefinelanguage{Gherkin}{
  morekeywords={Feature,Background,Scenario,Scenario\ Outline,Examples,Given,When,Then,And,But},
  sensitive=true,
}
\lstset{
  language=Gherkin,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{Primary}\bfseries,
  commentstyle=\itshape\color{Meta},
  showstringspaces=false,
  frame=single,
  framerule=0.4pt,
  rulecolor=\color{Soft},
  backgroundcolor=\color{Soft},
  tabsize=2,
  columns=fullflexible,
  keepspaces=true,
  breaklines=true,
  breakatwhitespace=true,
  xleftmargin=1ex,
  framexleftmargin=1ex,
  framesep=0.6ex,
  aboveskip=3pt,
  belowskip=6pt
}

% -------------------- Card Look & Feel (matches screenshot) --------------------
\tcbset{
  colback=gray!2,
  colframe=gray!50,
  colbacktitle=gray!6,
  coltitle=black,
  fonttitle=\bfseries\large,
  arc=2pt,
  boxrule=0.4pt,
  left=8pt,right=8pt,top=8pt,bottom=8pt,
  enhanced,
  breakable,
  borderline west={2pt}{0pt}{MidnightBlue}
}

% Badges/pills
\newtcbox{\pill}{on line, arc=3pt, boxsep=0.8pt, left=4pt,right=4pt,top=1pt,bottom=1pt,
  colframe=gray!50, colback=gray!15, boxrule=0.3pt}
\newcommand{\badge}[1]{\pill{\footnotesize #1}}

% Footer helpers
\newcommand{\DoR}{\textbf{Definition of Ready:} Persona clear; AC drafted; Dependencies known; Estimate set.}
\newcommand{\DoD}{\textbf{Definition of Done:} All ACs pass; Tests green; Security/a11y checks; Docs updated; Deployed/flagged.}
\let\cb\checkbox

% Widths for robust tables (no tabularx needed)
\newlength{\StoryLabelW}
\setlength{\StoryLabelW}{3.2cm}
\newlength{\StoryValueW}
\setlength{\StoryValueW}{\dimexpr\linewidth-\StoryLabelW-2\tabcolsep\relax}

% -------------------- Story Card macro (exact screenshot layout) --------------------
% 1: ID   2: Title   3: Epic/Feature   4: Business Value
% 5: Priority   6: Estimate(SP)   7: Persona   8: Dependencies   9: Assumptions/Risks
\newcommand{\StoryCard}[9]{%
  \newpage
  \begin{tcolorbox}[title={\textbf{#1}\ \textemdash\ #2}]
  \small
  \begin{tabular}{@{}>{\raggedleft\arraybackslash\bfseries}p{\StoryLabelW} >{\RaggedRight\arraybackslash}p{\StoryValueW}@{}}
    Epic / Feature          & #3 \\
    Business Value          & #4 \\
    Priority / Estimate     & \badge{Priority: #5}\ \badge{SP: #6} \\
    Persona                 & #7 \\
    Dependencies            & #8 \\
    Assumptions / Risks     & #9 \\
  \end{tabular}

  \medskip
  \textbf{Story}\quad
  \emph{As a #7, I want to #2 so that #4.}

  \medskip
  \textbf{Non-Functional}\quad
  \badge{Performance}\ \badge{Security}\ \badge{Reliability}\ \badge{Accessibility}\ \badge{Privacy}\ \badge{i18n}

  \medskip
  \textbf{Acceptance Criteria (BDD)}
  \begin{description}[leftmargin=2.4cm, labelwidth=2.3cm, style=nextline, itemsep=2pt, topsep=2pt]
    \item[\textbf{Scenario}] Happy path
    \item[\textbf{Given}] the target repository and pipeline configuration are available
    \item[\textbf{When}] the user completes the \emph{Hands-on Objective}
    \item[\textbf{Then}] the stated \emph{Outcome} is observable and recorded in the pipeline/job summary
  \end{description}

  \vspace{0.2\baselineskip}
  {\footnotesize\color{gray!60}\DoR\ \textbullet\ \DoD}
  \end{tcolorbox}
}

% -------------------- Tasks box (matches screenshot style) --------------------
\newenvironment{TasksBox}[1][Tasks]{%
  \begin{tcolorbox}[
    enhanced,breakable,
    colback=gray!1, colframe=gray!35,
    colbacktitle=gray!6, coltitle=black,
    title={#1}, fonttitle=\bfseries,
    borderline west={1.8pt}{0pt}{MidnightBlue},
    arc=2pt, boxrule=0.4pt,
    left=10pt,right=10pt,top=6pt,bottom=6pt,
    before skip=6pt, after skip=10pt
  ]
  \small
  \begin{itemize}[label=\cb, leftmargin=*, labelsep=0.6em, itemsep=4pt, topsep=2pt, parsep=0pt]
}{%
  \end{itemize}
  \end{tcolorbox}
}

% -------------------- Document --------------------

\begin{document}
\begin{center}
{\huge \textbf{GHAS Application Security User Stories (AppSec Engineer)}}\\[2pt]
\textcolor{Meta}{Operational stories for Code Scanning and Secret Scanning queue management, PR enforcement, outreach, and ServiceNow (CTASK/SCTASK)}\\[6pt]
\end{center}

\noindent\textbf{Context}\\
You are operating GitHub Advanced Security (GHAS) as an AppSec engineer. Secret Scanning is enabled across the organization, and Code Scanning enforcement was recently tightened to block pull requests (PRs) when 	extbf{critical} findings are introduced or present in the PR diff. Your day-to-day work includes clearing Code Scanning and Secret Scanning queues, engaging IT managers and repository owners with remediation guidance, and managing associated ServiceNow work (CTASK change requests and SCTASK service change tasks) so remediation and configuration changes are approved, traceable, and auditable.

\medskip
\noindent\textbf{Program Objectives}
\begin{itemize}
  \item Reduce Code Scanning and Secret Scanning queues to an actionable steady state (triage, ownership, disposition).
  \item Maintain reliable PR enforcement for critical Code Scanning findings while minimizing delivery disruption.
  \item Increase remediation throughput via structured outreach, playbooks, and clear escalation paths for IT managers.
  \item Standardize ServiceNow CTASK/SCTASK workflows for GHAS-driven remediation and configuration changes, with traceable evidence.
\end{itemize}

\section{User Stories}
\noindent The following stories are organized by epic and tailored to the AppSec engineer persona operating GHAS with ServiceNow integrations.

\subsection*{Epic: Code Scanning Queue Operations \& PR Gate Stabilization}

\StoryCard{GHAS-CSQ-001}{Triage PR-blocking critical Code Scanning alerts daily}{Code Scanning Operations}
{Ensure PRs are not blocked indefinitely by establishing a predictable daily triage and remediation loop for critical findings}
{Must}{3}
{AppSec engineer}
{Code Scanning enabled on PRs; access to security alerts; repository ownership map; communication channels to IT managers}
{High-volume periods can create backlog; unknown repo ownership; time-zone coverage gaps; false positives delaying merges}

\begin{TasksBox}[Implementation Tasks]
  \item \cb Establish a daily PR-block triage window and publish it to engineering and IT managers.
  \item \cb Create a PR-block triage checklist: validate finding, confirm it is in PR diff, identify owner, propose fix or mitigation.
  \item \cb For each blocked PR, record: repository, finding ID, severity, owner, recommended remediation, and ETA.
  \item \cb Escalate unresolved critical blocks older than 1 business day to the owning IT manager with clear next steps.
  \item \cb Close the loop by confirming alert status change (fixed/dismissed/waived) and documenting rationale.
\end{TasksBox}

\textbf{Acceptance Criteria (Gherkin)}
\begin{lstlisting}[language=Gherkin]
Scenario: Critical PR blocks are triaged within one business day
  Given a pull request is blocked due to a critical Code Scanning finding
  When the daily PR-block triage window occurs
  Then the finding is validated (true positive vs false positive)
  And an owning team or IT manager is identified and notified
  And a remediation path is recorded (fix, mitigation, or waiver)

Scenario: Aged critical PR blocks are escalated
  Given a pull request has been blocked for more than 1 business day
  When the AppSec engineer reviews the PR-block queue
  Then an escalation message is sent to the owning IT manager
  And the escalation includes a recommended remediation and target date
\end{lstlisting}

\clearpage

\StoryCard{GHAS-CSQ-002}{Baseline legacy Code Scanning backlog and gate only on new criticals}{Code Scanning Enforcement}
{Prevent delivery disruption by separating legacy backlog from newly introduced critical findings, while still blocking new criticals at merge time}
{Must}{5}
{AppSec engineer}
{Agreement on baseline approach; repository administrator support; CodeQL workflow configured for PR analysis; branch protection/rulesets}
{Incorrect baseline may mask risk; teams may interpret baseline as risk acceptance; inconsistent “new vs existing” determination across repos}

\begin{TasksBox}[Implementation Tasks]
  \item \cb Define and document the baseline approach per repository: snapshot date, scope (Critical/High), and tracking method.
  \item \cb Create a “legacy backlog” work item per repository and link it to the baseline snapshot.
  \item \cb Configure enforcement so PRs are blocked when \emph{new} critical findings are introduced or present in the PR diff.
  \item \cb Validate behavior with a controlled test PR: introduce a known critical, confirm block; remove it, confirm pass.
  \item \cb Communicate baseline policy to IT managers: what is gated, what is tracked, and expected remediation SLAs.
\end{TasksBox}

\textbf{Acceptance Criteria (Gherkin)}
\begin{lstlisting}[language=Gherkin]
Scenario: Legacy backlog does not immediately block current PRs
  Given a repository has pre-existing critical Code Scanning alerts before the baseline date
  When a developer opens a pull request that does not introduce new critical findings
  Then the pull request is not blocked solely due to the legacy backlog
  And the legacy backlog remains tracked via a repository remediation work item

Scenario: New critical findings block PRs
  Given Code Scanning runs on pull requests
  When a pull request introduces a new critical finding
  Then the Code Scanning check fails
  And the pull request cannot be merged until the finding is fixed or waived per policy
\end{lstlisting}

\clearpage

\StoryCard{GHAS-CSQ-003}{Route Code Scanning alerts to the correct owners}{Code Scanning Operations}
{Increase remediation throughput by automatically identifying and engaging the correct repository owners or IT managers for each alert}
{Should}{5}
{AppSec engineer}
{CODEOWNERS present and accurate; team-to-repo ownership mapping; repository metadata; communication channel mapping}
{Missing/incorrect ownership; shared repositories without clear stewardship; organizational changes breaking mappings}

\begin{TasksBox}[Implementation Tasks]
  \item \cb Establish an ownership source of truth (CODEOWNERS, repo topics, ServiceNow CMDB, or internal directory).
  \item \cb For top repositories, validate and correct CODEOWNERS (or equivalent) to ensure actionable routing.
  \item \cb Define a standard outreach package: alert summary, affected code area, recommended fix, references, and SLA.
  \item \cb Implement a weekly “unowned alerts” review and assign interim ownership where necessary.
  \item \cb Track ownership coverage as a metric (e.g., \% of alerts with a confirmed owner).
\end{TasksBox}

\textbf{Acceptance Criteria (Gherkin)}
\begin{lstlisting}[language=Gherkin]
Scenario: Alerts are associated with an owner
  Given a Code Scanning alert exists in a repository
  When the AppSec engineer reviews the alert details
  Then the alert can be mapped to a responsible owner or IT manager
  And the owner is recorded in the remediation tracker

Scenario: Unowned alerts are handled via interim assignment
  Given a Code Scanning alert cannot be mapped to an owner
  When the weekly unowned alerts review occurs
  Then an interim owner is assigned
  And a plan is created to establish a permanent ownership mapping
\end{lstlisting}

\clearpage

\StoryCard{GHAS-CSQ-004}{Reduce Code Scanning noise to keep queues actionable}{Code Scanning Tuning}
{Improve signal-to-noise by reducing false positives and low-value alerts so teams focus on real critical and high-impact fixes}
{Should}{8}
{AppSec engineer}
{Access to CodeQL query suite configuration; ability to dismiss alerts with rationale; agreement on suppression rules; engineering feedback loop}
{Over-suppression can hide real risk; inconsistent dismissal rationale; changes may require change control and approvals}

\begin{TasksBox}[Implementation Tasks]
  \item \cb Identify top recurring alert types by volume and by false-positive rate (per repository and org-wide).
  \item \cb For false positives, document the root cause and suppression approach (dismissal rationale, query configuration, or code annotation).
  \item \cb Standardize dismissal reasons and require evidence for “false positive” (link to analysis, reproduction steps, or code context).
  \item \cb Where appropriate, adjust query suites (e.g., standard vs extended) or enable/disable specific queries with documented justification.
  \item \cb Re-measure queue volume and PR block rate after tuning and publish results to IT managers.
\end{TasksBox}

\textbf{Acceptance Criteria (Gherkin)}
\begin{lstlisting}[language=Gherkin]
Scenario: False positives are dismissed with standardized rationale
  Given a Code Scanning alert is determined to be a false positive
  When the AppSec engineer dismisses the alert
  Then a standardized dismissal reason is selected
  And supporting evidence is recorded (link or notes)

Scenario: Noise reduction improves queue actionability
  Given Code Scanning noise reduction changes have been applied
  When the AppSec engineer measures alerts over the next reporting period
  Then the number of untriaged alerts decreases
  And the percentage of actionable critical/high alerts increases
\end{lstlisting}

\clearpage

\StoryCard{GHAS-CSQ-005}{Implement a time-bounded waiver process for critical PR blocks}{Code Scanning Governance}
{Enable controlled delivery when immediate fixes are not feasible by providing a documented, time-bounded exception path with risk acceptance}
{Must}{5}
{AppSec engineer}
{Defined approvers (AppSec/IT manager); waiver template; storage location for evidence; branch protection process supports exceptions}
{Waivers may become permanent if not enforced; inconsistent approval criteria; auditors require traceability and expiry enforcement}

\begin{TasksBox}[Implementation Tasks]
  \item \cb Define waiver criteria (acceptable scenarios, compensating controls, maximum duration, required approvers).
  \item \cb Create a standard waiver record format: finding ID, justification, compensating controls, expiry date, approvers, and evidence.
  \item \cb Establish how waivers are applied operationally (e.g., temporary rule override, allow-list, or documented merge approval).
  \item \cb Implement a weekly waiver review to confirm expiry and remediation progress.
  \item \cb Report waiver counts and expirations to IT managers and security leadership.
\end{TasksBox}

\textbf{Acceptance Criteria (Gherkin)}
\begin{lstlisting}[language=Gherkin]
Scenario: Waivers require approval and expiry
  Given a pull request is blocked due to a critical Code Scanning finding
  When a team requests a waiver
  Then an approver reviews the request against waiver criteria
  And an expiry date is set
  And the waiver is recorded with evidence and approval

Scenario: Expired waivers are escalated
  Given a waiver has reached its expiry date
  When the weekly waiver review occurs
  Then the waiver is escalated to the owning IT manager
  And the team must remediate or renew the waiver with updated justification
\end{lstlisting}

\clearpage

\subsection*{Epic: Secret Scanning Queue Clearance \& Credential Response}

\StoryCard{GHAS-SSQ-001}{Triage and clear the Secret Scanning alert queue}{Secret Scanning Operations}
{Reduce credential exposure risk by validating, routing, and closing Secret Scanning alerts with consistent evidence and outcomes}
{Must}{5}
{AppSec engineer}
{Secret Scanning enabled; access to alert details; ability to contact owners; credential inventory/owners; approved rotation procedures}
{Large legacy backlog; ambiguous token ownership; third-party credentials; rotation requires coordinated downtime windows}

\begin{TasksBox}[Implementation Tasks]
  \item \cb Establish alert categorization: valid secret, test/dummy secret, false positive, already rotated/revoked, unknown.
  \item \cb For each alert, capture minimum evidence: secret type, location (file/commit), owner, remediation action, and verification.
  \item \cb For valid secrets, initiate credential rotation/revocation with the owning IT manager and track to completion.
  \item \cb For false positives, dismiss with standardized rationale and (where possible) add pattern exclusions to prevent recurrence.
  \item \cb Maintain a daily burn-down tracker for open Secret Scanning alerts by severity and age.
\end{TasksBox}

\textbf{Acceptance Criteria (Gherkin)}
\begin{lstlisting}[language=Gherkin]
Scenario: Secret Scanning alerts are categorized and dispositioned
  Given a Secret Scanning alert exists
  When the AppSec engineer reviews the alert
  Then the alert is categorized (valid, false positive, test/dummy, rotated, unknown)
  And a disposition is recorded (rotate/revoke, dismiss, or investigate)

Scenario: Valid secrets trigger rotation and verification
  Given a Secret Scanning alert is categorized as a valid secret
  When the AppSec engineer engages the owner for remediation
  Then the credential is rotated or revoked
  And the alert is closed with verification evidence recorded
\end{lstlisting}

\clearpage

\StoryCard{GHAS-SSQ-002}{Coordinate credential rotation with IT managers and minimize downtime}{Secret Scanning Remediation}
{Improve remediation success rate by providing IT managers a repeatable rotation workflow, including verification and rollback guidance}
{Must}{3}
{AppSec engineer}
{IT manager engagement; platform-specific rotation steps; change windows; monitoring/rollback procedures; inventory of dependent services}
{Rotation may break dependent systems; incomplete inventory; delayed response from third-party owners; emergencies require expedited process}

\begin{TasksBox}[Implementation Tasks]
  \item \cb Provide an IT-manager-ready rotation playbook (steps, owners, approvals, verification checks).
  \item \cb Define required verification steps (service health checks, auth tests, log validation) per credential type.
  \item \cb If rotation impacts production, route through ServiceNow change controls with a rollback plan.
  \item \cb Confirm the secret is removed from the repository history where feasible (or add documented compensating controls).
  \item \cb Close the alert only after rotation/revocation is verified and evidence is stored.
\end{TasksBox}

\textbf{Acceptance Criteria (Gherkin)}
\begin{lstlisting}[language=Gherkin]
Scenario: Rotation includes verification and rollback
  Given a valid credential is identified via Secret Scanning
  When the credential is rotated or revoked
  Then verification checks confirm dependent services remain healthy
  And a rollback plan exists if verification fails

Scenario: High-impact rotations follow change control
  Given rotation requires a production change window
  When the AppSec engineer requests execution
  Then a ServiceNow change request is created and approved
  And the rotation is executed within the approved window with evidence
\end{lstlisting}

\clearpage

\StoryCard{GHAS-SSQ-003}{Prevent secret re-introduction using push protection and tuned notifications}{Secret Scanning Prevention}
{Reduce repeat incidents by stopping secrets at commit time and ensuring the right owners are notified quickly when exposures occur}
{Should}{5}
{AppSec engineer}
{Push protection licensing and enablement; repository admin support; notification routing; developer communication plan}
{Developer friction if overly strict; false positives can create alert fatigue; uneven adoption across repositories}

\begin{TasksBox}[Implementation Tasks]
  \item \cb Identify high-risk repositories (customer data, production integrations) and enable push protection.
  \item \cb Confirm notification routes: who receives alerts, where (email, chat), and expected response times.
  \item \cb Define a rapid-response workflow for new alerts (e.g., within 4 hours for high-risk repos).
  \item \cb Provide developer guidance for handling blocked pushes and how to request AppSec assistance.
  \item \cb Track prevented exposures (push protection blocks) and publish metrics monthly.
\end{TasksBox}

\textbf{Acceptance Criteria (Gherkin)}
\begin{lstlisting}[language=Gherkin]
Scenario: Push protection blocks committing a valid secret
  Given push protection is enabled for a repository
  When a developer attempts to push a commit containing a detectable secret
  Then the push is blocked
  And the developer receives guidance to remove the secret and rotate if needed

Scenario: Owners are notified for new Secret Scanning alerts
  Given a new Secret Scanning alert is generated
  When notification routing is configured correctly
  Then the owning team or IT manager receives the alert notification
  And the alert is acknowledged within the defined response time
\end{lstlisting}

\clearpage

\StoryCard{GHAS-SSQ-004}{Add custom secret patterns for organization-specific tokens}{Secret Scanning Coverage}
{Increase detection coverage by identifying and detecting organization-specific secrets that are not covered by default patterns}
{Could}{8}
{AppSec engineer}
{List of internal token formats; testing repository; agreement on false-positive thresholds; change approval if org-wide configuration changes}
{Pattern too broad increases false positives; pattern too narrow misses secrets; sensitive pattern details must be protected}

\begin{TasksBox}[Implementation Tasks]
  \item \cb Identify high-value internal token formats (prefixes, lengths, entropy characteristics) and document safely.
  \item \cb Draft custom patterns and validate against known-safe test fixtures to tune false-positive rate.
  \item \cb Roll out custom patterns to a pilot set of repositories, then expand based on measured performance.
  \item \cb Define handling instructions specific to each token type (owner, rotation steps, verification).
  \item \cb Review custom pattern performance quarterly and adjust as needed.
\end{TasksBox}

\textbf{Acceptance Criteria (Gherkin)}
\begin{lstlisting}[language=Gherkin]
Scenario: Custom patterns detect organization-specific tokens
  Given a custom secret pattern is configured
  When a commit contains a matching organization-specific token
  Then a Secret Scanning alert is generated
  And the alert includes handling guidance for rotation and verification

Scenario: Custom patterns meet a defined false-positive threshold
  Given a custom secret pattern has been deployed to pilot repositories
  When alerts are reviewed over the pilot period
  Then the false-positive rate is below the agreed threshold
  And the pattern can be expanded to additional repositories
\end{lstlisting}

\clearpage

\subsection*{Epic: ServiceNow Change Orchestration (CTASK/SCTASK)}

\StoryCard{GHAS-SNOW-001}{Standardize ServiceNow CTASK creation for GHAS remediation changes}{ServiceNow Remediation Workflow}
{Improve traceability and approvals by linking GHAS alerts to ServiceNow CTASK records with consistent fields and evidence expectations}
{Must}{5}
{AppSec engineer}
{ServiceNow access; CTASK template fields; mapping between repositories and CI/service owners; evidence storage location}
{Inconsistent ticket quality; owners resist additional process; lack of consistent linkage between GHAS IDs and SNOW fields}

\begin{TasksBox}[Implementation Tasks]
  \item \cb Define the CTASK template: GHAS alert ID(s), repository, severity, remediation summary, risk statement, and SLA.
  \item \cb Require evidence fields: remediation PR link, deployment/merge date, validation steps, and approver sign-off.
  \item \cb Establish a rule: valid secrets and critical Code Scanning findings require a CTASK when remediation impacts production.
  \item \cb Create a weekly CTASK review to ensure aged items are escalated and closed items have adequate evidence.
  \item \cb Provide IT managers a “what good looks like” CTASK example to standardize submissions.
\end{TasksBox}

\textbf{Acceptance Criteria (Gherkin)}
\begin{lstlisting}[language=Gherkin]
Scenario: Remediation CTASK includes required linkage and evidence
  Given a GHAS alert requires production-impacting remediation
  When a CTASK is created in ServiceNow
  Then the CTASK references the GHAS alert ID and repository
  And the CTASK includes remediation and validation evidence before closure

Scenario: Aged CTASKs are escalated
  Given a CTASK is open beyond its SLA
  When the AppSec engineer performs the weekly CTASK review
  Then the CTASK is escalated to the owning IT manager
  And a new target completion date is recorded
\end{lstlisting}

\clearpage

\StoryCard{GHAS-SNOW-002}{Process and close ServiceNow SCTASKs for GHAS configuration changes}{ServiceNow Change Management}
{Ensure GHAS configuration changes (rulesets, workflow updates, enablement) are approved, implemented, and reversible}
{Must}{3}
{AppSec engineer}
{SCTASK process; approvers; change window; rollback plan; access to GitHub org settings and repository admin support}
{Changes can break developer workflows; insufficient rollback documentation; changes applied inconsistently across repositories}

\begin{TasksBox}[Implementation Tasks]
  \item \cb Define what requires an SCTASK: enabling/disabling GHAS features, changing PR enforcement rules, or modifying org-wide policies.
  \item \cb Include required artifacts in each SCTASK: implementation plan, impact assessment, testing plan, and rollback steps.
  \item \cb Execute changes in a pilot first, then expand; record outcomes and issues in the SCTASK.
  \item \cb Validate post-change behavior (checks run, PR gate logic correct, alerts created/updated as expected).
  \item \cb Close SCTASK only after validation evidence and stakeholder communications are complete.
\end{TasksBox}

\textbf{Acceptance Criteria (Gherkin)}
\begin{lstlisting}[language=Gherkin]
Scenario: GHAS configuration changes follow SCTASK approvals
  Given a GHAS configuration change is required
  When the change is executed
  Then an approved SCTASK exists with an implementation and rollback plan
  And validation evidence confirms the expected behavior after the change

Scenario: Rollback is available if change causes disruption
  Given a GHAS configuration change causes unexpected disruption
  When the AppSec engineer initiates rollback
  Then rollback steps from the SCTASK are executed
  And normal developer workflows are restored
\end{lstlisting}

\clearpage

\StoryCard{GHAS-SNOW-003}{Reconcile GHAS alert status with ServiceNow task status weekly}{Operational Reporting}
{Prevent drift by ensuring ServiceNow CTASK/SCTASK records accurately reflect GHAS alert disposition and remediation completion}
{Should}{5}
{AppSec engineer}
{Access to GHAS alert exports/APIs; ServiceNow reporting; consistent identifiers to match records; agreed reconciliation cadence}
{Identifier mismatches; manual reconciliation overhead; incomplete updates by assignees; reporting delays}

\begin{TasksBox}[Implementation Tasks]
  \item \cb Define matching keys between GHAS and ServiceNow (alert URL/ID, repository, commit SHA, PR link).
  \item \cb Generate a weekly reconciliation report: open GHAS alerts with closed SNOW tasks, and open SNOW tasks with resolved GHAS alerts.
  \item \cb For mismatches, notify the owning IT manager and request correction (close/resolve/update evidence).
  \item \cb Track reconciliation exceptions and improve templates/mappings to reduce repeat mismatches.
  \item \cb Publish a short weekly summary: queue sizes, aged items, waivers, and SNOW alignment health.
\end{TasksBox}

\textbf{Acceptance Criteria (Gherkin)}
\begin{lstlisting}[language=Gherkin]
Scenario: Weekly reconciliation identifies mismatches
  Given GHAS alerts and ServiceNow tasks exist for remediation work
  When the weekly reconciliation report is generated
  Then mismatches between GHAS status and SNOW status are identified
  And owning IT managers receive an action request to correct the records

Scenario: Reconciliation improves over time
  Given reconciliation has been performed for multiple weeks
  When the AppSec engineer reviews reconciliation metrics
  Then the number of mismatches decreases
  And templates/mappings are updated to prevent recurring issues
\end{lstlisting}

\clearpage

\end{document}
