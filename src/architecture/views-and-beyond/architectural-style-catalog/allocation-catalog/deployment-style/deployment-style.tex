\documentclass[11pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage[T1]{fontenc}
\usepackage{enumitem}
\usepackage[hidelinks]{hyperref}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{parskip}
\usepackage{graphicx}
% --- CI-safe diagram inclusion ---
% Prefer PNG outputs rendered by the PlantUML workflow (no Inkscape dependency).
\newcommand{\safeincludegraphics}[2][]{%
  \IfFileExists{#2}{%
    \includegraphics[#1]{#2}%
  }{%
    \fbox{\scriptsize\textcolor{red}{Missing image: \detokenize{#2}}}%
  }%
}
\newcommand{\diagram}[2][]{%
  \safeincludegraphics[#1]{png/#2.png}%
}

\usepackage{float}
\usepackage[font=small,labelfont=bf]{caption}

\setlist[itemize]{leftmargin=1.5em}
\setlist[enumerate]{leftmargin=1.5em}

% Section formatting
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

% Header and footer
\pagestyle{fancy}
\setlength{\headheight}{14pt}
\fancyhf{}
\fancyhead[L]{\small Deployment Architectural Style}
\fancyhead[R]{\small Software Architecture Documentation}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Diagram paths
% The render-plantuml workflow creates png/ subdirectory alongside this .tex file
\begin{document}

\title{\textbf{The Deployment Architectural Style}\\[0.5em]
\large A Comprehensive Reference for Mapping Software to Hardware}
\author{}
\date{}
\maketitle

\tableofcontents
\newpage

%==============================================================================
\section{Overview}
%==============================================================================

The deployment style describes the mapping of components and connectors in the software architecture to the hardware of the computing platform. This allocation view is essential for understanding how software will execute in its target environment, answering critical questions about physical resource utilization, network topology, and system distribution.

\begin{figure}[H]
\centering
\diagram[width=0.95\textwidth]{01-basic-deployment-architecture}
\caption{Basic deployment architecture showing the mapping from software elements (C\&C view) to environmental elements (allocation view). Each software component is allocated to a hosting node.}
\label{fig:basic-deployment-architecture}
\end{figure}

Unlike component-and-connector (C\&C) views that focus on runtime behavior and module views that describe code organization, deployment views bridge the gap between logical software design and physical infrastructure. They make explicit the relationship between abstract computational elements and the concrete computing resources that host them.

The deployment style serves as the definitive record of where software resides during execution, what hardware capabilities are required, how components communicate across physical boundaries, and what environmental dependencies exist. This information is indispensable for operations teams, performance engineers, security architects, and anyone responsible for provisioning, configuring, or maintaining the production environment.

\subsection{Scope and Applicability}

The deployment style applies to any system where software must execute on physical or virtualized computing resources. This includes traditional on-premises deployments, cloud-native applications, hybrid architectures, embedded systems, edge computing scenarios, and distributed systems spanning multiple geographic regions.

The style is particularly valuable when the system exhibits any of the following characteristics: distribution across multiple nodes, significant resource constraints, complex network topologies, high availability requirements, performance-sensitive workloads, regulatory compliance obligations affecting data residency, or multi-tenant hosting scenarios.

\subsection{Relationship to Other Views}

Deployment views complement rather than replace other architectural views. They consume information from C\&C views---specifically, the software elements that require allocation---and produce information used by operational views, capacity planning activities, and infrastructure-as-code specifications.

\begin{figure}[H]
\centering
\diagram[width=0.85\textwidth]{15-view-relationships}
\caption{The deployment view's relationship to other architectural views. Deployment views bridge logical design and physical infrastructure.}
\label{fig:view-relationships}
\end{figure}

A complete architectural description typically includes module views (showing code structure), C\&C views (showing runtime behavior), and allocation views including deployment (showing physical mapping). These views together provide a holistic understanding of the system from development through operation.

%==============================================================================
\section{Elements}
%==============================================================================

The deployment style comprises two fundamental categories of elements: software elements that require hosting and environmental elements that provide hosting capabilities.

\subsection{Software Elements}

Software elements are the components and connectors drawn from C\&C views that must be allocated to physical resources. These represent the executable units of the system---processes, services, containers, functions, or other runtime entities that consume computing resources.

\subsubsection{Types of Software Elements}

\begin{figure}[H]
\centering
\diagram[width=0.9\textwidth]{02-software-element-types}
\caption{Classification of software element types in deployment views. Each type has distinct resource requirements and deployment characteristics.}
\label{fig:software-element-types}
\end{figure}

Software elements in deployment views include executables and processes (compiled binaries, interpreted scripts, or managed code that runs as operating system processes), services (long-running processes that provide specific capabilities, often accessed via network protocols), containers (packaged application units including code, runtime, libraries, and configuration), serverless functions (event-driven code units executed by cloud platform infrastructure), middleware components (application servers, message brokers, API gateways, and similar infrastructure software), data stores (databases, caches, file systems, and other persistent storage mechanisms), and batch jobs (scheduled or triggered processes that execute periodically or in response to events).

\subsubsection{Essential Properties of Software Elements}

When documenting software elements for deployment, architects should capture several categories of properties. Resource requirements encompass CPU cores or millicores needed, memory footprint (working set, heap, stack), storage requirements (persistent and ephemeral), network bandwidth consumption, and GPU or specialized hardware needs.

Scalability characteristics describe whether the element is horizontally scalable (can run multiple instances), vertically scalable (benefits from more resources per instance), or constrained in scaling. Minimum and maximum instance counts, along with scaling triggers and thresholds, should be documented.

Availability requirements specify expected uptime percentage, mean time between failures tolerance, recovery time objectives, recovery point objectives, and failover behavior (active-active, active-passive, or cold standby).

Security posture addresses required isolation level (shared, dedicated, air-gapped), encryption requirements (at rest, in transit), compliance certifications needed, and network security zone placement.

Dependencies include other software elements required at runtime, external services consumed, shared resources needed, and initialization ordering constraints.

Configuration requirements cover environment variables, configuration files, secrets, and certificates needed, feature flags and runtime tuning parameters, and logging and monitoring integration points.

\subsection{Environmental Elements}

Environmental elements represent the physical and virtualized computing infrastructure that hosts software elements. These form the target platform onto which software is deployed.

\subsubsection{Types of Environmental Elements}

\begin{figure}[H]
\centering
\diagram[width=0.9\textwidth]{03-environmental-element-types}
\caption{Classification of environmental element types that host software elements. Each provides different capabilities and trade-offs.}
\label{fig:environmental-element-types}
\end{figure}

Environmental elements include physical servers (bare-metal machines in data centers, providing raw computing capacity), virtual machines (software-defined computers running on hypervisors, offering isolation and resource abstraction), containers (lightweight isolated environments sharing a host OS kernel), container orchestration nodes (Kubernetes nodes, Docker Swarm workers, or similar managed compute units), serverless platforms (cloud provider infrastructure executing functions without visible servers), edge devices (computing resources at network periphery, including IoT gateways and edge servers), network infrastructure (routers, switches, load balancers, firewalls, VPN concentrators, and DNS servers), and storage infrastructure (SAN, NAS, object storage, block storage, and distributed file systems).

\subsubsection{Essential Properties of Environmental Elements}

Compute capacity properties include processor architecture (x86\_64, ARM, RISC-V), number and speed of cores, available memory, local storage type and capacity, and hardware acceleration capabilities (GPUs, TPUs, FPGAs).

Network properties encompass network interface count and speed, IP addressing (static, dynamic, IPv4, IPv6), DNS resolution capabilities, network zone membership, firewall rules and security groups, and load balancing configuration.

Reliability properties address redundancy level (N+1, 2N, or higher), failure domain membership, maintenance window constraints, and mean time between failures.

Location properties specify geographic region, data center facility, availability zone, rack position, and regulatory jurisdiction.

Platform properties cover operating system and version, container runtime if applicable, installed middleware and agents, and configuration management baseline.

Cost properties include hourly or monthly cost, reserved versus on-demand pricing, and data transfer costs.

%==============================================================================
\section{Relations}
%==============================================================================

Relations in the deployment style define how software elements map to environmental elements and how allocations may change over time.

\begin{figure}[H]
\centering
\diagram[width=0.95\textwidth]{04-deployment-relations}
\caption{Primary relations in the deployment style: allocated-to for static mapping, migration relations for dynamic changes, and communicates-with for cross-boundary interactions.}
\label{fig:deployment-relations}
\end{figure}

\subsection{Allocated-To Relation}

The primary relation in deployment views is \textit{allocated-to}, which specifies that a software element resides on an environmental element during execution. This relation answers the fundamental question: where does this component run?

\subsubsection{Properties of Allocated-To}

The allocation binding defines the permanence of the allocation.

\begin{figure}[H]
\centering
\diagram[width=0.9\textwidth]{13-allocation-binding-types}
\caption{Allocation binding types: static (fixed at deployment), dynamic (may change at runtime), and lazy (determined on first access).}
\label{fig:allocation-binding-types}
\end{figure}

Static allocation means the assignment is fixed at deployment time and does not change during execution. Dynamic allocation means the assignment may change during execution based on load, failures, or policy. Lazy allocation means the assignment is determined at first access or invocation.

Exclusivity determines resource sharing. Dedicated allocation means the environmental element hosts only this software element. Shared allocation means multiple software elements may coexist on the same environmental element. Isolated allocation means the element has dedicated resources within a shared environment (as with containers or VMs).

Cardinality specifies instance relationships. One-to-one means exactly one software instance per environmental element. One-to-many means one software element may have instances on multiple environmental elements. Many-to-one means multiple software elements share a single environmental element.

Affinity rules may specify that certain software elements must be co-located (affinity) or must not be co-located (anti-affinity) on the same environmental element.

\subsection{Migration Relations}

When allocations change dynamically, migration relations describe how software elements move between environmental elements.

\subsubsection{Migrates-To}

The \textit{migrates-to} relation indicates that a software element relocates from one environmental element to another. The original instance terminates, and a new instance starts on the target element. This typically involves brief unavailability.

Properties of migrates-to include the trigger (what initiates migration, such as failure detection, load threshold, administrative action, or scheduled maintenance), duration (expected time to complete migration), state handling (whether state is discarded, persisted externally, or transferred), and rollback capability (whether failed migration can revert to original allocation).

\subsubsection{Copy-Migrates-To}

The \textit{copy-migrates-to} relation indicates that a software element is replicated to a new environmental element while the original instance continues running. This enables scale-out and redundancy.

Properties include the replication trigger, state synchronization mechanism (shared storage, state transfer, or stateless design), load distribution strategy after replication, and maximum instance count.

\subsubsection{Execution-Migrates-To}

The \textit{execution-migrates-to} relation indicates that active execution context moves between environmental elements while preserving state. This is typically used for live migration of virtual machines or container checkpointing.

Properties include downtime during migration (ideally zero or near-zero), memory transfer mechanism (pre-copy, post-copy, or hybrid), network connection handling, and storage failover behavior.

\subsection{Communicates-With Relation}

While primarily a C\&C concern, the \textit{communicates-with} relation gains additional significance in deployment views when it crosses environmental element boundaries.

Properties relevant to deployment include network protocol and ports used, encryption requirements for cross-node communication, latency sensitivity, bandwidth requirements, and failure handling for network partitions.

%==============================================================================
\section{Constraints}
%==============================================================================

The deployment style imposes constraints that ensure allocated software elements can execute correctly on their target environmental elements.

\begin{figure}[H]
\centering
\diagram[width=0.95\textwidth]{14-deployment-constraints}
\caption{Deployment constraints: resource satisfaction (matching requirements to capabilities), affinity/anti-affinity (placement rules), and regulatory (compliance requirements).}
\label{fig:deployment-constraints}
\end{figure}

\subsection{Resource Satisfaction Constraints}

The fundamental constraint is that the required properties of software elements must be satisfied by the provided properties of environmental elements. If a component requires 4 GB of memory, it cannot be allocated to a node with only 2 GB available. If a service requires GPU acceleration, it must be placed on a GPU-equipped host.

This constraint applies across all resource dimensions: compute capacity (CPU, memory, storage must meet or exceed requirements), network capability (bandwidth, latency, and connectivity requirements must be satisfiable), platform compatibility (operating system, runtime, and dependencies must be available), and security requirements (isolation, encryption, and compliance must be achievable).

\subsection{Topology Constraints}

While the allocation topology is generally unrestricted, practical deployments often impose additional constraints. Affinity constraints require certain software elements to be co-located for performance (low latency, shared memory) or correctness (distributed consensus requiring network proximity). Anti-affinity constraints require certain software elements to be separated for fault tolerance (spreading across failure domains) or security (isolation of sensitive components). Zone constraints restrict allocation to specific geographic regions, availability zones, or security perimeters.

\subsection{Capacity Constraints}

Environmental elements have finite capacity that bounds the number of software elements they can host. Capacity constraints may be hard (physical resource limits that cannot be exceeded) or soft (policy limits that should not be exceeded under normal operation). Overcommitment policies may allow soft limits to be exceeded temporarily, relying on statistical multiplexing.

\subsection{Regulatory and Compliance Constraints}

External requirements often constrain deployment options. Data residency requirements may mandate that certain data remain within specific jurisdictions. Industry regulations may require specific security controls or isolation levels. Audit requirements may mandate logging, monitoring, or access control capabilities.

\subsection{Cost Constraints}

Budget limitations constrain the environmental elements that can be provisioned. Cost optimization often drives decisions about resource allocation, instance sizing, reserved capacity, and geographic distribution.

%==============================================================================
\section{What the Style is For}
%==============================================================================

The deployment style addresses several critical purposes in the software development and operations lifecycle.

\subsection{Performance Analysis}

Deployment views enable performance engineers to analyze whether the planned allocation meets throughput and latency requirements. By understanding the physical distribution of components, network hops between communicating services, and resource contention on shared infrastructure, architects can identify bottlenecks and optimize placement.

Performance analysis using deployment views considers compute contention (multiple software elements competing for CPU cycles on shared hosts), memory pressure (aggregate memory demands approaching host capacity), network latency (physical distance and network hops between communicating components), I/O bottlenecks (storage and network bandwidth limitations), and resource interference (noisy neighbors affecting performance variability).

\subsection{Availability and Reliability Planning}

Deployment views reveal the fault tolerance characteristics of the system by making failure domains explicit. Architects can analyze single points of failure by identifying components without redundancy across failure domains, failure propagation paths where one component's failure cascades to dependent components, recovery time impact based on migration and restart capabilities, and data durability based on replication topology and consistency mechanisms.

\subsection{Security Architecture}

The physical topology directly affects security posture. Deployment views enable security architects to define network zones and perimeters (separating components by trust level), identify data flow across trust boundaries (determining encryption and authentication requirements), plan network segmentation (firewall rules and security groups), analyze attack surface (entry points and lateral movement paths), and ensure compliance (data residency and isolation requirements).

\subsection{Capacity Planning}

Deployment views provide the foundation for infrastructure capacity planning by documenting current resource utilization to establish baseline metrics, growth projections to estimate future resource needs, scaling strategies for horizontal and vertical scaling approaches, and cost optimization to right-size infrastructure for workload demands.

\subsection{Operations and DevOps}

Deployment views inform operational practices including deployment procedures (what gets deployed where, in what order), monitoring strategy (what to measure on each environmental element), incident response (how to diagnose and remediate issues across distributed components), change management (understanding blast radius of infrastructure changes), and disaster recovery (failover procedures and recovery runbooks).

\subsection{Communication}

Deployment views serve as a communication artifact for diverse stakeholders: operations teams understand what they're responsible for managing, infrastructure teams understand provisioning requirements, security teams understand the attack surface and protection requirements, capacity planners understand resource consumption patterns, and executives understand infrastructure cost drivers.

%==============================================================================
\section{Quality Attributes}
%==============================================================================

Deployment decisions directly affect several quality attributes of the resulting system.

\begin{figure}[H]
\centering
\diagram[width=0.85\textwidth]{12-quality-attributes}
\caption{Quality attributes directly affected by deployment decisions. Each attribute requires specific deployment considerations.}
\label{fig:quality-attributes}
\end{figure}

\subsection{Performance}

Deployment topology determines communication latency, resource availability, and potential for contention. Key performance considerations include co-locating latency-sensitive components to minimize network hops, distributing load across multiple environmental elements to prevent bottlenecks, selecting appropriate instance sizes and types for workload characteristics, and placing components geographically near their users or data sources.

\subsection{Availability}

The mapping of software to hardware determines which failures affect which capabilities. Availability-focused deployment considerations include distributing redundant instances across independent failure domains, avoiding single points of failure in critical paths, providing sufficient capacity for failover scenarios, and enabling rapid detection and recovery from failures.

\subsection{Scalability}

Deployment architecture constrains scaling options. Scalability considerations include designing stateless components that can scale horizontally, using load balancing to distribute work across instances, provisioning infrastructure that can accommodate scaling, and planning for scaling limits and bottlenecks.

\subsection{Security}

Physical topology affects attack surface and defense strategies. Security-relevant deployment considerations include segmenting networks to limit lateral movement, isolating sensitive components in restricted environments, encrypting communication across network boundaries, and placing security controls at trust boundaries.

\subsection{Modifiability}

Deployment architecture affects the ease of making changes. Modifiability considerations include decoupling deployment units to enable independent updates, standardizing deployment patterns to reduce cognitive load, automating deployment processes to enable rapid iteration, and designing for rollback to recover from failed changes.

\subsection{Cost}

Infrastructure represents significant ongoing expense. Cost-focused deployment considerations include right-sizing resources to actual requirements, using reserved capacity for predictable workloads, leveraging spot or preemptible instances for fault-tolerant workloads, and optimizing data transfer to minimize network costs.

%==============================================================================
\section{Notations}
%==============================================================================

Deployment views can be represented using various notations, from informal diagrams to formal modeling languages.

\subsection{Informal Box-and-Line Diagrams}

The most common notation uses boxes to represent both software and environmental elements, with containment showing allocation. Environmental elements are typically shown as three-dimensional boxes or boxes with folded corners to distinguish them from software elements.

Conventions for informal diagrams include environmental elements depicted as nodes with a distinctive visual style, software elements shown inside their hosting environmental elements, network connections between environmental elements shown as lines, labels indicating element names, types, and key properties, and color coding or icons to distinguish element categories.

\subsection{UML Deployment Diagrams}

The Unified Modeling Language provides a standardized notation for deployment views. UML deployment diagrams use nodes (three-dimensional boxes representing environmental elements), artifacts (rectangles with document icons representing deployable software units), associations (lines showing communication paths between nodes), dependencies (dashed arrows showing deployment relationships), and deployment specifications (attached notes with configuration details).

UML stereotypes extend the basic notation to distinguish node types (such as device, execution environment, and container), artifact types (such as executable, library, and configuration), and deployment types (such as deploy, manifest, and specification).

\subsection{Cloud Architecture Diagrams}

Cloud-native systems often use provider-specific iconography in deployment diagrams. AWS architecture diagrams use official AWS icons for services. Azure architecture diagrams use official Azure icons and patterns. Google Cloud architecture diagrams use official GCP icons. Multi-cloud diagrams may use generic icons with provider labels.

Cloud deployment diagrams typically show regions and availability zones as nested containers, managed services as provider-specific icons, networking constructs including VPCs, subnets, and security groups, and connectivity patterns including load balancers, CDNs, and API gateways.

\subsection{Infrastructure as Code}

Modern deployment architectures are often expressed as code rather than diagrams. Terraform configurations declare infrastructure resources and their relationships. Kubernetes manifests describe desired deployment state. CloudFormation or ARM templates define cloud resource stacks. Ansible or Puppet configurations specify desired system state.

These textual representations serve as executable deployment specifications that can be versioned, reviewed, tested, and applied automatically.

\subsection{Formal Architecture Description Languages}

For rigorous analysis, formal ADLs provide precise semantics. AADL (Architecture Analysis and Design Language) supports embedded and real-time system deployment modeling. SysML deployment diagrams extend UML for systems engineering contexts. ArchiMate provides enterprise architecture deployment notation.

%==============================================================================
\section{Common Deployment Patterns}
%==============================================================================

Several recurring patterns address common deployment challenges.

\subsection{Single-Node Deployment}

\begin{figure}[H]
\centering
\diagram[width=0.75\textwidth]{05-single-node-deployment}
\caption{Single-node deployment pattern: all software elements on one environmental element. Simple but limited.}
\label{fig:single-node-deployment}
\end{figure}

All software elements are allocated to a single environmental element. This pattern is appropriate for development environments, small-scale applications with modest requirements, systems with strong consistency requirements that preclude distribution, and cost-constrained scenarios accepting availability trade-offs.

Limitations include no fault tolerance (node failure causes complete outage), limited scalability (bound by single node capacity), and potential for resource contention between components.

\subsection{Load-Balanced Cluster}

\begin{figure}[H]
\centering
\diagram[width=0.85\textwidth]{06-load-balanced-cluster}
\caption{Load-balanced cluster pattern: multiple instances distributed behind a load balancer for scalability and fault tolerance.}
\label{fig:load-balanced-cluster}
\end{figure}

Multiple instances of software elements are distributed across a pool of environmental elements behind a load balancer. This pattern provides horizontal scalability (add nodes to increase capacity), fault tolerance (surviving individual node failures), and flexible load distribution across available resources.

Considerations include state management (stateless preferred; external state stores for stateful), session affinity (sticky sessions may be needed for some applications), health checking (automatic detection and removal of failed nodes), and scaling policies (rules for adding and removing capacity).

\subsection{Primary-Replica Deployment}

\begin{figure}[H]
\centering
\diagram[width=0.9\textwidth]{07-primary-replica-deployment}
\caption{Primary-replica deployment pattern: writes to primary, reads distributed across replicas with asynchronous replication.}
\label{fig:primary-replica-deployment}
\end{figure}

A primary instance handles writes while replica instances handle reads, with state replicated from primary to replicas. This pattern addresses read-heavy workloads (scaling read capacity independently), data durability (multiple copies of data), and disaster recovery (replicas available for promotion).

Considerations include replication lag (potential for stale reads), failover procedures (promoting replica to primary), split-brain prevention (consensus protocols or fencing), and consistency guarantees (eventual versus strong consistency).

\subsection{Microservices Deployment}

\begin{figure}[H]
\centering
\diagram[width=0.9\textwidth]{08-kubernetes-deployment}
\caption{Microservices on Kubernetes: independent services deployed as pods with service abstraction and persistent storage.}
\label{fig:kubernetes-deployment}
\end{figure}

Independent services are deployed as separate units, each owning its allocation decisions. Benefits include independent scaling (each service scales based on its own demands), technology heterogeneity (different services use different platforms), isolated failures (service failures don't directly crash other services), and independent deployment (updating one service without affecting others).

Considerations include service discovery (finding service instances dynamically), distributed tracing (understanding request flow across services), data consistency (managing distributed state), and operational complexity (many more deployment units to manage).

\subsection{Edge Deployment}

Software elements are distributed to computing resources at the network edge, near end users or data sources. This pattern addresses latency requirements (minimizing round-trip time to users), bandwidth optimization (processing data near its source), offline operation (functioning during network disconnection), and data sovereignty (keeping data within geographic boundaries).

Considerations include edge resource constraints (limited compute and storage), synchronization (maintaining consistency with central systems), security (protecting distributed attack surface), and management complexity (many distributed nodes to maintain).

\subsection{Multi-Region Deployment}

\begin{figure}[H]
\centering
\diagram[width=0.95\textwidth]{10-multi-region-deployment}
\caption{Multi-region deployment pattern: software distributed across geographic regions with cross-region replication and latency-based routing.}
\label{fig:multi-region-deployment}
\end{figure}

Software elements are distributed across multiple geographic regions for disaster recovery, latency optimization, or regulatory compliance. Considerations include data replication strategy (synchronous versus asynchronous, conflict resolution), traffic routing (geographic, latency-based, or failover routing), cost implications (cross-region data transfer costs), and operational consistency (maintaining configuration across regions).

\subsection{Hybrid Cloud Deployment}

\begin{figure}[H]
\centering
\diagram[width=0.9\textwidth]{11-hybrid-cloud-deployment}
\caption{Hybrid cloud deployment pattern: software spanning on-premises and public cloud with secure connectivity.}
\label{fig:hybrid-cloud-deployment}
\end{figure}

Software elements span on-premises infrastructure and public cloud resources. This pattern addresses legacy integration (connecting cloud-native and traditional systems), data sensitivity (keeping regulated data on-premises), burst capacity (using cloud for peak demand), and migration path (gradual transition to cloud).

Considerations include network connectivity (secure links between environments), identity federation (unified authentication and authorization), data synchronization (keeping hybrid data consistent), and operational tool integration (unified visibility across environments).

%==============================================================================
\section{Examples}
%==============================================================================

Concrete examples illustrate deployment style concepts.

\subsection{Three-Tier Web Application}

\begin{figure}[H]
\centering
\diagram[width=0.95\textwidth]{09-three-tier-application}
\caption{Three-tier web application deployment with network segmentation: presentation tier in DMZ, application tier in private subnet, data tier in restricted subnet.}
\label{fig:three-tier-application}
\end{figure}

A traditional web application deployment consists of a presentation tier where web server instances run behind a load balancer serving static content and proxying dynamic requests, an application tier where application server instances execute business logic and maintain session state, and a data tier where database servers store persistent data with primary-replica replication.

Allocation decisions include the number of instances per tier (based on load and availability requirements), instance sizing (based on workload characteristics), network segmentation (web tier in DMZ, application tier in private subnet, data tier in restricted subnet), and load balancing strategy (round-robin, least-connections, or application-aware).

\subsection{Microservices on Kubernetes}

A cloud-native application deployed on Kubernetes uses pods as deployable units containing one or more containers. Services abstract pod instances behind stable network endpoints. Ingress exposes services externally with TLS termination. Persistent volumes provide durable storage for stateful workloads. Namespaces isolate workloads for different environments or teams.

Allocation decisions include pod resource requests and limits (guaranteeing and capping resources), replica count (scaling for load and availability), node affinity (placing pods on appropriate nodes), and persistent volume configuration (storage class and access mode).

\subsection{Serverless Event Processing}

An event-driven system on serverless infrastructure uses functions that execute in response to events, managed queues and streams that buffer events between processing stages, managed databases that store state without server management, and API gateways that expose functions as HTTP endpoints.

Allocation decisions include function memory sizing (affecting performance and cost), concurrency limits (controlling parallelism), timeout configuration (bounding execution time), and connection pooling (managing database connections efficiently).

%==============================================================================
\section{Best Practices}
%==============================================================================

Experience suggests several best practices for deployment architecture.

\subsection{Design for Failure}

Assume environmental elements will fail and design accordingly. Eliminate single points of failure in critical paths. Design software elements to tolerate and recover from infrastructure failures. Test failure scenarios regularly using chaos engineering practices. Document failure modes and recovery procedures.

\subsection{Automate Everything}

Manual deployment processes are error-prone and slow. Express infrastructure as code that can be version-controlled and tested. Automate deployment pipelines for consistent, repeatable deployments. Automate scaling based on measurable triggers. Automate recovery procedures where possible.

\subsection{Start Simple}

Deployment complexity has costs in operations, debugging, and understanding. Begin with the simplest deployment that meets requirements. Add complexity only when justified by specific quality attribute needs. Regularly evaluate whether existing complexity is still warranted. Prefer managed services that reduce operational burden.

\subsection{Make Deployment Units Independent}

Tight coupling between deployment units creates coordination overhead. Design deployment units with clear boundaries and interfaces. Enable independent deployment and scaling of units. Avoid shared state between deployment units where possible. Use asynchronous communication to decouple availability.

\subsection{Optimize for Observability}

Understanding system behavior in production is essential. Instrument all software elements for metrics, logs, and traces. Ensure monitoring coverage across all environmental elements. Build dashboards for different operational perspectives. Create runbooks linking alerts to diagnostic procedures.

\subsection{Plan for Evolution}

Deployment architecture must adapt as the system evolves. Design for horizontal scaling from the start, even if not immediately needed. Use abstraction layers that allow infrastructure changes without application changes. Regularly review and update deployment architecture. Maintain documentation that reflects current reality.

%==============================================================================
\section{Common Challenges}
%==============================================================================

Deployment architecture involves navigating several common challenges.

\subsection{State Management}

Distributed state complicates deployment significantly. Challenges include consistency (ensuring all nodes see consistent data), replication (copying state across failure domains), migration (moving state when reallocating software), and partitioning (handling network splits gracefully).

Strategies include designing stateless software elements where possible, externalizing state to managed data services, using established distributed systems patterns like consensus protocols, and accepting eventual consistency where appropriate.

\subsection{Network Complexity}

Distributed systems introduce network concerns. Challenges include latency (communication delays across network hops), bandwidth (limited capacity for data transfer), reliability (handling transient network failures), and security (protecting data in transit).

Strategies include minimizing cross-network communication, using appropriate protocols for network conditions, implementing retry and circuit-breaker patterns, and encrypting all inter-node communication.

\subsection{Configuration Management}

Managing configuration across distributed deployments is challenging. Challenges include consistency (ensuring all instances use correct configuration), secrets (managing sensitive configuration securely), environment parity (maintaining similar configuration across environments), and change management (updating configuration safely).

Strategies include centralizing configuration in configuration management systems, using secret management solutions for sensitive values, parameterizing environment-specific configuration, and testing configuration changes before production deployment.

\subsection{Operational Complexity}

Distributed deployments are harder to operate. Challenges include visibility (understanding system state across many nodes), debugging (tracing issues across distributed components), coordination (managing updates across the fleet), and expertise (requiring specialized skills for distributed systems).

Strategies include investing in observability tooling and practices, training operations teams in distributed systems concepts, automating routine operational tasks, and using managed services to reduce operational scope.

%==============================================================================
\section{Documentation Guidelines}
%==============================================================================

Effective deployment documentation enables stakeholders to understand, analyze, and modify the system's physical architecture.

\subsection{Essential Content}

Deployment documentation should include an element catalog (comprehensive list of all software and environmental elements with their properties), allocation mapping (explicit documentation of which software elements are allocated to which environmental elements), network topology (how environmental elements communicate, including protocols, ports, and security controls), deployment procedures (how to provision infrastructure and deploy software), configuration management (how system configuration is maintained and updated), and monitoring and operations (what is monitored, how alerts are handled, and how incidents are managed).

\subsection{Views for Different Stakeholders}

Different audiences need different views of deployment architecture. Executive overview provides high-level topology showing major system components and their relationships. Operations view provides detailed node inventory with configuration baselines and monitoring endpoints. Security view provides network zones, trust boundaries, and security control placement. Development view provides deployment unit boundaries and inter-service communication paths. Capacity planning view provides resource utilization trends and growth projections.

\subsection{Keeping Documentation Current}

Deployment architecture changes frequently. Strategies for maintaining current documentation include generating diagrams from infrastructure-as-code (single source of truth), automated documentation updates as part of CI/CD pipelines, regular architecture reviews to validate documentation accuracy, and version-controlled documentation alongside system code.

\subsection{Common Pitfalls}

Documentation quality suffers when deployment documentation exhibits excessive detail (including every configuration parameter obscures the important decisions), insufficient context (diagrams without accompanying explanation of rationale), point-in-time snapshots (documentation that is never updated becomes misleading), or abstraction mismatch (documentation at wrong level for intended audience).

%==============================================================================
\section{Relationship to DevOps Practices}
%==============================================================================

Modern deployment practices are deeply intertwined with DevOps culture and tooling.

\subsection{Infrastructure as Code}

Deployment architecture should be expressed in executable, version-controlled infrastructure definitions. Benefits include repeatability (identical environments from same code), auditability (history of all infrastructure changes), testability (validating infrastructure before production), and collaboration (code review for infrastructure changes).

Tools include Terraform (multi-cloud infrastructure provisioning), CloudFormation and ARM templates (cloud-specific infrastructure), Pulumi (infrastructure using general-purpose programming languages), and Ansible, Chef, and Puppet (configuration management).

\subsection{Container Orchestration}

Container platforms provide declarative deployment models. Kubernetes deployments specify desired state for containerized workloads. Helm charts package deployments for reusability. Service meshes manage inter-service communication. Platform abstractions hide infrastructure details from developers.

\subsection{Continuous Deployment}

Deployment architecture must support continuous delivery practices. Blue-green deployments maintain two production environments for zero-downtime switches. Canary deployments gradually shift traffic to new versions. Feature flags enable deployment without activation. Rollback capabilities enable rapid recovery from problems.

\subsection{Observability}

Deployment architecture must enable visibility into system behavior. Distributed tracing tracks requests across service boundaries. Metrics collection aggregates measurements from all nodes. Log aggregation centralizes logs for analysis. Alerting detects anomalies and notifies operators.

%==============================================================================
\section{Conclusion}
%==============================================================================

The deployment style provides essential vocabulary and concepts for documenting how software maps to the computing platform. By explicitly capturing software elements, environmental elements, and the allocation relationships between them, deployment views enable critical analysis of performance, availability, security, and cost.

Effective deployment architecture requires balancing competing concerns, including simplicity versus capability, cost versus redundancy, and agility versus stability. The patterns, practices, and guidelines in this document provide a foundation for making these trade-offs thoughtfully.

As systems increasingly span cloud regions, edge devices, and hybrid environments, the deployment style becomes ever more important for understanding and managing system complexity. Investment in clear, accurate, and current deployment documentation pays dividends throughout the system lifecycle.

%==============================================================================
\section*{References}
%==============================================================================

\begin{itemize}
  \item Clements, P., Bachmann, F., Bass, L., Garlan, D., Ivers, J., Little, R., Merson, P., Nord, R., \& Stafford, J. (2010). \textit{Documenting Software Architectures: Views and Beyond} (2nd ed.). Addison-Wesley Professional.
  \item Bass, L., Weber, I., \& Zhu, L. (2015). \textit{DevOps: A Software Architect's Perspective}. Addison-Wesley Professional.
  \item Burns, B. (2018). \textit{Designing Distributed Systems: Patterns and Paradigms for Scalable, Reliable Services}. O'Reilly Media.
  \item Morris, K. (2016). \textit{Infrastructure as Code: Managing Servers in the Cloud}. O'Reilly Media.
  \item Newman, S. (2021). \textit{Building Microservices: Designing Fine-Grained Systems} (2nd ed.). O'Reilly Media.
\end{itemize}

%==============================================================================
\listoffigures
%==============================================================================

\end{document}
