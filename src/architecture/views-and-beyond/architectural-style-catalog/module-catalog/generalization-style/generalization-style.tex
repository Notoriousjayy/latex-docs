\documentclass[11pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{enumitem}
\usepackage[hidelinks]{hyperref}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{parskip}
\usepackage{graphicx}
% --- CI-safe diagram inclusion ---
% Prefer PNG outputs rendered by the PlantUML workflow (no Inkscape dependency).
\newcommand{\safeincludegraphics}[2][]{%
  \IfFileExists{#2}{%
    \includegraphics[#1]{#2}%
  }{%
    \fbox{\scriptsize\textcolor{red}{Missing image: \detokenize{#2}}}%
  }%
}
\newcommand{\diagram}[2][]{%
  \safeincludegraphics[#1]{png/#2.png}%
}

\usepackage{float}
\usepackage[font=small,labelfont=bf]{caption}

\setlist[itemize]{leftmargin=1.5em}
\setlist[enumerate]{leftmargin=1.5em}
\setlist[description]{leftmargin=2.5em,labelsep=0.8em}

% Section formatting
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

% Header and footer
\pagestyle{fancy}
\setlength{\headheight}{14pt}
\fancyhf{}
\fancyhead[L]{\small Generalization Architectural Style}
\fancyhead[R]{\small Software Architecture Documentation}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

\begin{document}

\title{\textbf{The Generalization Architectural Style}\\[0.5em]
\large A Comprehensive Reference for Inheritance and Type Hierarchies}
\author{}
\date{}
\maketitle

\tableofcontents
\newpage

%==============================================================================
\section{Overview}
%==============================================================================

The generalization style is a module architectural style that employs the \emph{is-a} relation to support extension and evolution of architectures and individual elements. Modules in this style are defined in such a way that they capture commonalities and variations, organizing code into hierarchies where specialized modules inherit from and extend more general modules.

Generalization is one of the fundamental organizing principles in software design, particularly in object-oriented systems. It enables architects to identify abstractions that capture what is common across a family of related modules, while allowing specialized modules to add or modify behavior for specific cases. This approach reduces duplication, promotes code reuse, and creates flexible architectures that can be extended without modifying existing code.

The generalization style produces directed acyclic graphs (or trees in single-inheritance systems) where parent modules define general characteristics and child modules provide specialized implementations. This hierarchical organization enables polymorphism, where code written to work with a general module automatically works with all its specializations.

\begin{figure}[H]
\centering
\diagram[width=0.75\textwidth]{01-generalization-hierarchy}
\caption{Basic generalization hierarchy showing the \emph{is-a} relation. The abstract parent defines a common interface while concrete children provide specialized implementations.}
\label{fig:generalization-hierarchy}
\end{figure}

\subsection{Scope and Applicability}

The generalization style applies to systems that benefit from hierarchical organization of related concepts. This includes object-oriented systems where classes form inheritance hierarchies; type systems where types are organized by subtyping relationships; framework design where extension points are defined through abstract base classes; plugin architectures where common interfaces define extension contracts; domain modeling where business concepts have natural type hierarchies; protocol design where message types form hierarchies; and API design where related operations are grouped under common interfaces.

The style is particularly valuable when multiple modules share common characteristics or behavior, when new variations must be added without changing existing code, when polymorphic behavior is needed, when frameworks must support extension by users, and when domain concepts naturally form hierarchies.

\subsection{Historical Context}

Generalization has deep roots in programming language design and software engineering.

Simula 67 introduced the concepts of classes and inheritance in the 1960s, establishing the foundation for object-oriented programming.

Smalltalk developed in the 1970s refined inheritance as a central organizing principle, with single-rooted hierarchies and message passing.

C++ in the 1980s brought multiple inheritance and abstract classes to mainstream systems programming, along with templates for generic programming.

Java and C\# in the 1990s and 2000s introduced interface inheritance as distinct from implementation inheritance, along with single implementation inheritance to avoid multiple inheritance complexities.

Modern languages continue to evolve generalization mechanisms through traits, mixins, protocols, and type classes that provide flexible alternatives to traditional inheritance.

Understanding this evolution helps architects select appropriate generalization mechanisms for their context and technology stack.

\subsection{Relationship to Other Styles}

The generalization style relates to several other architectural views and styles.

It complements the decomposition style by adding inheritance relationships to the containment hierarchy. Decomposition shows what modules exist; generalization shows how they relate through inheritance.

It interacts with the uses style because inheritance creates implicit uses relationships. A child module uses its parent through inherited members.

It relates to the layered style when layers define abstract interfaces that lower layers implement.

It supports the aspects style when aspects use inheritance to apply cross-cutting behavior.

It connects to component-and-connector views because the generalization hierarchy affects which components can substitute for others at runtime.

The generalization view is often documented alongside decomposition views, showing both containment and inheritance relationships among modules.

\subsection{Inheritance vs. Composition}

A fundamental design consideration is when to use inheritance versus composition.

\begin{figure}[H]
\centering
\diagram[width=0.95\textwidth]{08-inheritance-vs-composition}
\caption{Inheritance versus composition. Inheritance (left) creates tight coupling through the \emph{is-a} relation; composition (right) achieves loose coupling through delegation to an interface.}
\label{fig:inheritance-vs-composition}
\end{figure}

Inheritance (generalization) creates an \emph{is-a} relationship. A child module is a specialized kind of its parent. The child inherits the parent's interface and implementation.

Composition creates a \emph{has-a} relationship. A module contains instances of other modules. The container delegates to contained modules.

The principle ``favor composition over inheritance'' reflects experience that inheritance creates tight coupling and can lead to fragile hierarchies. However, inheritance remains valuable for true \emph{is-a} relationships, polymorphism, and framework extension points.

The generalization style documents inheritance relationships; the uses style documents composition through dependencies.

%==============================================================================
\section{Elements}
%==============================================================================

The generalization style uses modules as its primary elements, with properties that indicate their role in inheritance hierarchies.

\subsection{Modules}

A module in the generalization style represents a code unit that participates in inheritance relationships. Modules may be classes, interfaces, abstract types, or other language constructs that support inheritance.

\subsubsection{Module Types in Generalization}

Modules play different roles in inheritance hierarchies.

\begin{figure}[H]
\centering
\diagram[width=0.95\textwidth]{02-module-types}
\caption{Classification of module types by their role in generalization hierarchies. Each type serves a distinct purpose from pure contracts (interfaces) to complete implementations (concrete modules).}
\label{fig:module-types}
\end{figure}

Concrete modules provide complete implementations that can be instantiated. They may inherit from other modules and may be inherited by other modules.

Abstract modules provide incomplete implementations that cannot be instantiated. They define interfaces and partial implementations that concrete children must complete. A module can have the ``abstract'' property to indicate it does not contain a complete implementation.

Interface modules define contracts without any implementation. They specify what operations a module must provide without specifying how.

Mixin modules provide reusable functionality designed to be combined with other modules through multiple inheritance or composition.

Trait modules provide sets of methods that can be incorporated into classes, similar to mixins but often with conflict resolution mechanisms.

\subsubsection{Essential Properties of Modules}

When documenting modules in the generalization style, architects should capture several property categories.

Abstraction properties indicate the module's completeness. Abstract indicates the module cannot be instantiated. Final or sealed indicates the module cannot be extended. Interface indicates the module defines only contracts.

Inheritance properties describe the module's position in hierarchies. Parent modules list what this module inherits from. Child modules list what inherits from this module. Inheritance type indicates class inheritance, interface inheritance, or implementation inheritance.

Member properties describe inherited and defined members. Inherited members list members received from parents. Defined members list members added by this module. Overridden members list parent members this module redefines. Abstract members list members that children must implement.

Visibility properties describe access to members. Public members are accessible to all. Protected members are accessible to children. Private members are accessible only within the module.

\subsubsection{Abstract Modules}

Abstract modules play a special role in generalization hierarchies.

\paragraph{Purpose of Abstract Modules}

Abstract modules define common interfaces and partial implementations for families of related modules. They capture what is common while leaving variation points for children.

Abstract modules cannot be instantiated directly. They exist only to be inherited by concrete modules that complete their implementation.

\paragraph{Abstract Members}

Abstract modules typically declare abstract members---operations that must be implemented by concrete descendants. Abstract members define the contract without providing implementation.

\paragraph{Template Method Pattern}

Abstract modules often implement the template method pattern, where a concrete algorithm in the parent calls abstract methods that children override. This inverts the usual calling relationship, with parents calling children.

\subsection{Interface Modules}

Interface modules define contracts without implementation.

\subsubsection{Purpose of Interfaces}

Interfaces specify what operations a module must provide without constraining how. Multiple unrelated modules can implement the same interface.

Interfaces enable polymorphism without requiring implementation inheritance. Code written to an interface works with any implementing module.

\subsubsection{Interface vs. Abstract Class}

Interfaces provide no implementation; abstract classes may provide partial implementation.

Interfaces support multiple inheritance in languages that restrict class inheritance. A class can implement many interfaces but extend only one class (in single-inheritance languages).

Interfaces are more flexible but provide less code reuse. Abstract classes can share implementation among descendants.

\subsection{Generalization Hierarchies}

Modules form hierarchies through the generalization relation.

\subsubsection{Single-Rooted Hierarchies}

Some systems define a single root from which all modules descend. Java's Object class and .NET's System.Object are examples. Single-rooted hierarchies ensure all modules share basic capabilities.

\subsubsection{Forest Hierarchies}

Other systems allow multiple independent hierarchies. Modules may have no common ancestor. This provides flexibility but loses universal polymorphism.

\subsubsection{Hierarchy Depth}

Deep hierarchies provide many levels of specialization but can become difficult to understand. Each level adds cognitive load and potential for fragile base class problems.

Shallow hierarchies are simpler but may duplicate code or miss abstraction opportunities.

The appropriate depth depends on the domain and complexity of variations being modeled.

%==============================================================================
\section{Relations}
%==============================================================================

The generalization style has one primary relation: the generalization relation, which is a specialization of the \emph{is-a} relation.

\subsection{Generalization Relation}

The generalization relation indicates that one module is a specialized version of another. The child module \emph{is-a} kind of the parent module.

\subsubsection{Semantics of Generalization}

Generalization has specific semantics that distinguish it from other relations.

Substitutability means a child can be used wherever the parent is expected. This is the Liskov Substitution Principle: programs using a parent module should work correctly with any child module.

Inheritance means the child receives the parent's interface and implementation. The child has all the parent's members plus any it defines or overrides.

Specialization means the child is a more specific version of the parent. Children narrow the concept, adding constraints or behaviors specific to a subset of cases.

\subsubsection{Types of Generalization}

The generalization relation can be further specialized to indicate different inheritance mechanisms.

\begin{figure}[H]
\centering
\diagram[width=0.95\textwidth]{03-relation-types}
\caption{The four primary types of generalization relations: class inheritance, interface inheritance, interface realization, and mixin inclusion. Solid lines denote inheritance; dashed lines denote realization.}
\label{fig:relation-types}
\end{figure}

Class inheritance (extends relationship) inherits both interface and implementation. The child gets the parent's code.

Interface inheritance (extends between interfaces) inherits interface only. One interface extends another with additional operations.

Interface realization (implements relationship) indicates a class fulfills an interface contract. The class provides implementation for the interface's operations.

Mixin inclusion incorporates a mixin's functionality into a class, similar to inheritance but with different semantics in different languages.

\subsubsection{Properties of Generalization}

When documenting generalization relationships, several properties are relevant.

Inheritance type specifies class inheritance, interface inheritance, or interface realization.

Visibility inherited indicates what access level inherited members have in the child.

Virtual versus non-virtual indicates whether methods can be overridden.

Override semantics specifies whether overrides extend or replace parent behavior.

\subsection{Overriding Relation}

Overriding is a relation between a child's member and a parent's member with the same signature.

\subsubsection{Semantics of Overriding}

Overriding replaces or extends parent behavior. When the member is invoked on a child instance, the child's version executes.

Overriding enables specialization by allowing children to customize inherited behavior.

Dynamic dispatch ensures the correct override is called based on the actual runtime type, enabling polymorphism.

\subsubsection{Override Constraints}

Languages impose constraints on overriding.

Signature matching requires the override to match the parent's signature (with possible covariant return types).

Access compatibility typically requires the override to be at least as accessible as the parent member.

Exception compatibility may restrict what exceptions an override can throw.

Final members cannot be overridden. Parents can prevent customization of specific members.

\subsection{Realization Relation}

Realization indicates that a module implements an interface's contract.

\subsubsection{Semantics of Realization}

Realization commits the module to providing implementations for all interface operations.

Unlike class inheritance, realization does not inherit implementation. The realizing module must provide all code.

Multiple interfaces can be realized by one module, enabling the module to fulfill multiple contracts.

\subsubsection{Properties of Realization}

Explicit versus implicit realization distinguishes languages that require declaration (Java's implements) from those that use structural typing (Go's implicit interfaces).

Partial realization in some languages allows abstract classes to partially realize interfaces, leaving some operations abstract.

%==============================================================================
\section{Computational Model}
%==============================================================================

The computational model describes how generalization affects runtime behavior.

\subsection{Inheritance Mechanism}

Inheritance determines what children receive from parents.

\subsubsection{Member Inheritance}

Children inherit parent members according to language rules.

Public members are inherited with public visibility.

Protected members are inherited with protected visibility (accessible to descendants).

Private members are not inherited (or inherited but not accessible).

Static members may or may not be inherited depending on the language.

\subsubsection{Constructor Inheritance}

Constructors have special inheritance semantics.

Constructors are typically not inherited directly. Children define their own constructors.

Child constructors must invoke parent constructors (explicitly or implicitly) to initialize inherited state.

Initialization order proceeds from root ancestor down to the specific child being constructed.

\subsection{Polymorphism}

Polymorphism allows code to work with multiple types through a common interface.

\subsubsection{Subtype Polymorphism}

Subtype polymorphism uses generalization hierarchies. Code written for a parent type works with any descendant type.

The actual behavior depends on the runtime type. A method call on a parent reference invokes the child's override if the actual object is a child instance.

This enables writing general algorithms that work with entire type families.

\subsubsection{Dynamic Dispatch}

Dynamic dispatch is the mechanism that implements polymorphism.

Method lookup finds the appropriate implementation based on the actual runtime type, not the declared type.

Virtual method tables (vtables) are a common implementation, mapping method signatures to implementations for each type.

Performance overhead is minimal---typically one indirect function call.

\subsubsection{Covariance and Contravariance}

Variance rules govern type compatibility in generalization.

Covariance allows a subtype to be used where a supertype is expected. Return types and read-only properties can be covariant.

Contravariance allows a supertype to be used where a subtype is expected. Parameter types can be contravariant.

Invariance requires exact type matching. Mutable collections are typically invariant.

\subsection{Multiple Inheritance}

Multiple inheritance allows a module to inherit from multiple parents.

\subsubsection{Diamond Problem}

When a module inherits from two parents that share a common ancestor, the ``diamond problem'' arises. Which version of the ancestor's members does the child inherit?

\begin{figure}[H]
\centering
\diagram[width=0.70\textwidth]{04-diamond-problem}
\caption{The diamond problem in multiple inheritance. When Duck inherits from both FlyingAnimal and SwimmingAnimal, which share a common Animal ancestor, the resolution of \texttt{move()} becomes ambiguous.}
\label{fig:diamond-problem}
\end{figure}

Languages address this through various mechanisms including virtual inheritance (C++), explicit disambiguation, linearization algorithms, or prohibiting multiple implementation inheritance.

\subsubsection{Interface Multiple Inheritance}

Most modern languages allow multiple interface inheritance while restricting implementation inheritance.

A class can implement multiple interfaces because interfaces provide no implementation to conflict.

This provides polymorphism benefits without diamond problem complexity.

\subsubsection{Mixin and Trait Composition}

Mixins and traits provide alternatives to multiple inheritance.

Mixins are composed into classes, providing implementation without the full semantics of inheritance.

Traits include conflict resolution mechanisms when the same method appears in multiple traits.

Composition order may affect which implementation is used.

%==============================================================================
\section{Constraints}
%==============================================================================

The generalization style imposes constraints that ensure valid hierarchies.

\subsection{Acyclicity Constraint}

Cycles in the generalization relation are not allowed; that is, a child module cannot be a generalization of one or more of its ancestor modules in a view.

\subsubsection{Rationale}

Cycles would create logical contradictions. If A inherits from B and B inherits from A, each would need to be more specialized than the other, which is impossible.

Cycles would also create infinite regress in member lookup and object construction.

\subsubsection{Enforcement}

Language compilers enforce acyclicity, rejecting circular inheritance declarations.

The constraint applies to the transitive closure of generalization. A cannot inherit from B if B already inherits (directly or indirectly) from A.

\subsection{Multiple Inheritance Constraint}

A module can have multiple parents, although multiple inheritance is often considered a dangerous design approach.

\subsubsection{Rationale for Caution}

Multiple inheritance introduces complexity through the diamond problem, potential for conflicting member definitions, increased coupling to multiple hierarchies, and difficulty understanding behavior with multiple parents.

\subsubsection{Language Restrictions}

Many languages restrict multiple inheritance.

Java, C\#, and similar languages allow multiple interface inheritance but single implementation inheritance.

C++ allows full multiple inheritance with virtual inheritance to address diamond problems.

Some languages like Rust use traits instead of traditional inheritance.

\subsubsection{When Multiple Inheritance is Appropriate}

Multiple inheritance can be appropriate when a concept genuinely belongs to multiple type families, when mixins provide orthogonal functionality, when interfaces capture different aspects of a module's capabilities, or when the diamond problem does not apply (no common ancestor).

\subsection{Substitutability Constraint}

Children should be substitutable for parents (Liskov Substitution Principle).

\subsubsection{Behavioral Subtyping}

A child module should honor the parent's contract. Children may strengthen postconditions but not weaken them. Children may weaken preconditions but not strengthen them. Children must maintain invariants.

Violating substitutability leads to surprising behavior when child instances are used through parent references.

\subsubsection{Signature Compatibility}

Override signatures must be compatible with parent signatures.

Return types may be covariant (more specific) in most languages.

Parameter types may be contravariant (more general) in some languages, though many require exact matching.

Exception specifications must be compatible (typically no new checked exceptions).

\subsection{Abstract Member Implementation Constraint}

Concrete children of abstract parents must implement all abstract members.

\subsubsection{Rationale}

Abstract members define contracts that the hierarchy promises to fulfill. Concrete classes that can be instantiated must provide complete implementations.

\subsubsection{Enforcement}

Languages enforce this constraint at compile time, requiring concrete classes to implement all inherited abstract members.

Abstract children may leave some abstract members unimplemented for their own children to implement.

%==============================================================================
\section{What the Style is For}
%==============================================================================

The generalization style supports several essential purposes in software architecture.

\subsection{Expressing Inheritance in Object-Oriented Designs}

The primary purpose is expressing inheritance in object-oriented designs.

\subsubsection{Class Hierarchies}

Generalization views document the inheritance relationships among classes. They show which classes extend which, what abstract classes exist, and how interfaces are implemented.

This documentation is essential for understanding how object-oriented systems are structured and how polymorphism is used.

\subsubsection{Framework Extension Points}

Frameworks define extension points through abstract classes and interfaces. Generalization views show these extension points and how applications extend the framework.

\subsubsection{Design Pattern Support}

Many design patterns rely on inheritance. Template Method uses abstract methods in base classes. Strategy uses interface hierarchies. State uses class hierarchies for states. Generalization views document these pattern implementations.

\subsection{Incrementally Describing Evolution and Extension}

Generalization supports incrementally describing evolution and extension.

\subsubsection{Adding New Variations}

New specialized modules can be added as children without modifying existing parents. This is the Open-Closed Principle: open for extension, closed for modification.

Generalization views show where new variations can be added and what they must implement.

\subsubsection{Evolution Planning}

Generalization hierarchies reveal evolution paths. Abstract classes suggest where variation is expected. Final classes indicate where extension is not intended.

\subsubsection{Version Compatibility}

Understanding generalization helps manage compatibility. Adding methods to interfaces affects all implementers. Adding abstract methods to classes affects all descendants.

\subsection{Capturing Commonalities with Variations as Children}

The style supports capturing commonalities, with variations as children.

\subsubsection{Factoring Common Code}

Shared behavior moves to parent modules. Children inherit the common behavior and need not reimplement it.

This reduces duplication and ensures consistency across related modules.

\subsubsection{Defining Variation Points}

Abstract methods in parents define where children vary. Each child provides its own implementation of the variation points.

This clearly documents where variation is expected and what interface variations must satisfy.

\subsubsection{Family Modeling}

Generalization models families of related concepts. All variations are clearly identified as members of the family through their inheritance relationship.

\subsection{Supporting Reuse}

Generalization is a powerful mechanism for supporting reuse.

\subsubsection{Implementation Reuse}

Children reuse parent implementation without copying code. Changes to parent implementation automatically apply to all descendants.

This provides significant code reuse, especially when many children share substantial behavior.

\subsubsection{Interface Reuse}

Interfaces defined by parents are reused by all descendants. Code written to parent interfaces works with all descendants.

This provides design-level reuse, enabling polymorphic algorithms.

\subsubsection{Framework Reuse}

Frameworks define abstract and concrete classes that applications inherit. Applications reuse framework code by extending framework classes.

Generalization is fundamental to framework-based reuse.

%==============================================================================
\section{Notations}
%==============================================================================

Generalization hierarchies can be represented using various notations.

\subsection{UML Class Diagrams}

UML provides standard notation for generalization.

\subsubsection{Class Notation}

Classes are rectangles with compartments for name, attributes, and operations.

Abstract classes have italicized names or use the $\ll$abstract$\gg$ stereotype.

Interfaces use the $\ll$interface$\gg$ stereotype or a circle (lollipop) notation.

\subsubsection{Generalization Notation}

Generalization is shown as a solid line with a hollow triangle arrowhead pointing to the parent.

Multiple children may share a single arrow through a shared generalization set.

\subsubsection{Realization Notation}

Interface realization is shown as a dashed line with a hollow triangle arrowhead.

Alternatively, the lollipop (provided interface) and socket (required interface) notation may be used.

\subsection{Tree Diagrams}

Inheritance hierarchies can be shown as trees.

Parent modules are above children. Lines connect parents to children. The root is at the top; leaves are at the bottom.

Tree diagrams emphasize the hierarchical structure but may not show all UML details.

\subsection{Textual Notations}

Text can describe generalization relationships.

\subsubsection{Code Notation}

Programming language syntax expresses generalization. Java uses ``extends'' and ``implements.'' C++ uses ``:'' with public/protected/private inheritance. C\# uses ``:'' for both class and interface inheritance.

\subsubsection{Structured Prose}

Each module can be described with its parents and children listed. A consistent format documents the hierarchy textually.

\subsection{Tabular Notations}

Tables can systematically document generalization.

Module catalog tables list modules with their parents, abstraction level, and inheritance type.

Override tables show which methods each child overrides.

Implementation tables show which modules implement which interfaces.

%==============================================================================
\section{Quality Attributes}
%==============================================================================

Generalization decisions significantly affect system quality attributes.

\subsection{Modifiability}

Generalization has complex effects on modifiability.

\subsubsection{Positive Effects}

Adding new variations requires only adding new children, not modifying existing code.

Shared behavior in parents means changes apply uniformly to all descendants.

Polymorphic code works with new variations without modification.

\subsubsection{Negative Effects}

Fragile base class problem means changes to parents can break children.

Deep hierarchies make it difficult to understand what a class inherits and from where.

Inheritance creates tight coupling between parent and child.

\subsubsection{Design Guidelines}

Favor shallow hierarchies. Design parents for extension (document extension contracts). Use composition when inheritance coupling is problematic.

\subsection{Reusability}

Generalization strongly affects reusability.

\subsubsection{Implementation Reuse}

Parents provide implementation reused by all descendants.

Well-designed hierarchies maximize shared code.

Abstract classes capture reusable algorithms with variation points.

\subsubsection{Interface Reuse}

Interfaces define reusable contracts implemented by multiple modules.

Polymorphic code is reusable across all implementations.

\subsubsection{Reuse Limitations}

Inheritance reuse requires accepting the entire parent interface.

Tightly coupled hierarchies are difficult to reuse in new contexts.

\subsection{Understandability}

Generalization affects how easily systems can be understood.

\subsubsection{Positive Effects}

Hierarchies organize related modules together.

Common behavior is documented once in parents.

Type relationships clarify module purpose.

\subsubsection{Negative Effects}

Deep hierarchies scatter understanding across many levels.

Multiple inheritance creates complex resolution to understand.

Inherited behavior is implicit and may be overlooked.

\subsubsection{Design Guidelines}

Limit hierarchy depth. Document inherited behavior explicitly. Avoid multiple implementation inheritance.

\subsection{Testability}

Generalization affects testing strategies.

\subsubsection{Testing Inheritance}

Parent tests should pass for all children (substitutability).

Children need tests for added and overridden behavior.

Abstract classes require concrete test doubles for testing.

\subsubsection{Test Reuse}

Parent test cases can be reused for children.

Interface contract tests apply to all implementations.

\subsubsection{Testing Challenges}

Deep hierarchies create large test surfaces.

Inherited behavior may be tested redundantly.

Mocking becomes complex with deep hierarchies.

\subsection{Performance}

Generalization has modest performance implications.

\subsubsection{Runtime Overhead}

Dynamic dispatch adds one indirection (vtable lookup).

This overhead is negligible for most applications.

Very performance-sensitive code may avoid virtual calls.

\subsubsection{Memory Overhead}

Objects carry type information (vtable pointers).

Deep hierarchies don't add per-object overhead beyond vtable pointer.

Vtables themselves consume static memory proportional to hierarchy size.

%==============================================================================
\section{Common Generalization Patterns}
%==============================================================================

Several recurring patterns use generalization effectively.

\begin{figure}[H]
\centering
\diagram[width=0.95\textwidth]{05-generalization-patterns}
\caption{Three common generalization patterns: Template Method uses abstract steps in a parent algorithm; Strategy uses an interface hierarchy for interchangeable algorithms; Abstract Factory uses interface realization for product-family creation.}
\label{fig:generalization-patterns}
\end{figure}

\subsection{Template Method Pattern}

An abstract parent defines an algorithm skeleton with abstract steps.

The parent implements the algorithm structure.

Abstract methods define variation points.

Children provide step implementations.

This pattern inverts control: parents call children.

\subsection{Strategy Pattern}

An interface defines an algorithm contract.

Multiple implementations provide different algorithms.

Clients program to the interface, not implementations.

Algorithms can be swapped without client changes.

\subsection{Abstract Factory Pattern}

An abstract factory interface defines creation methods.

Concrete factories implement creation for specific product families.

Clients use factories through the abstract interface.

New product families require new factory implementations.

\subsection{State Pattern}

An abstract state class defines state-dependent operations.

Concrete states implement behavior for each state.

Context delegates to current state.

State transitions change the current state object.

\subsection{Composite Pattern}

A component interface defines operations for both leaves and composites.

Leaf classes implement operations directly.

Composite classes delegate operations to children.

Clients treat leaves and composites uniformly.

\subsection{Decorator Pattern}

A component interface defines the decorated operation.

Concrete components provide basic implementation.

Decorators wrap components, adding behavior before or after delegating.

Multiple decorators can be stacked.

\subsection{Adapter Pattern}

A target interface defines what clients expect.

An adapter implements the target interface.

The adapter translates calls to an adaptee with different interface.

Clients work with adapters through the target interface.

\subsection{Marker Interface Pattern}

An empty interface marks modules with some characteristic.

Modules implement the marker to indicate the characteristic.

Code tests for the marker interface to vary behavior.

Examples include Java's Serializable and Cloneable.

%==============================================================================
\section{Design Principles}
%==============================================================================

Several design principles guide effective use of generalization.

\subsection{Liskov Substitution Principle}

Children must be substitutable for parents.

\begin{figure}[H]
\centering
\diagram[width=0.75\textwidth]{06-liskov-substitution}
\caption{The Liskov Substitution Principle illustrated. The correct approach (left) uses a shared Shape interface; the broken approach (right) forces Square to extend Rectangle, violating the parent's contract.}
\label{fig:liskov-substitution}
\end{figure}

Programs using parent references should work correctly with child instances.

Children may add behavior but must not violate parent contracts.

Violations lead to unexpected behavior and fragile code.

\subsection{Open-Closed Principle}

Modules should be open for extension, closed for modification.

Generalization enables adding behavior through new children rather than modifying parents.

Well-designed parents anticipate extension and provide appropriate extension points.

\subsection{Interface Segregation Principle}

Clients should not depend on interfaces they don't use.

Large interfaces should be split into smaller, focused interfaces.

Modules implement only the interfaces they need.

This prevents forcing unnecessary implementation on modules.

\subsection{Dependency Inversion Principle}

Depend on abstractions, not concretions.

High-level modules should define interfaces that low-level modules implement.

This inverts the traditional dependency direction.

Generalization enables this through abstract parents and interfaces.

\subsection{Favor Composition Over Inheritance}

Use inheritance only for true \emph{is-a} relationships.

Prefer composition when behavior can be delegated rather than inherited.

Composition provides more flexibility with less coupling.

Inheritance creates tight coupling that is difficult to break.

\subsection{Design for Inheritance or Prohibit It}

Classes should be explicitly designed for inheritance or marked final.

Designing for inheritance requires documenting self-use and extension contracts.

Undocumented inheritance is fragile and error-prone.

Final classes prevent fragile base class problems.

%==============================================================================
\section{Examples}
%==============================================================================

Concrete examples illustrate generalization concepts.

\subsection{Collections Framework}

Collection frameworks illustrate classic generalization hierarchies.

\begin{figure}[H]
\centering
\diagram[width=0.70\textwidth]{07-collections-hierarchy}
\caption{Java Collections Framework hierarchy. Interfaces (purple) define contracts, abstract classes (green) provide partial implementations, and concrete classes (blue) deliver complete implementations.}
\label{fig:collections-hierarchy}
\end{figure}

The root interface (Collection or Iterable) defines minimal operations.

Subinterfaces (List, Set, Queue) add specialized operations.

Abstract classes (AbstractList, AbstractSet) provide partial implementations.

Concrete classes (ArrayList, HashSet) provide complete implementations.

This hierarchy balances interface flexibility with implementation reuse.

\subsection{GUI Widget Hierarchy}

GUI frameworks use deep generalization hierarchies.

A root widget or component class defines basic capabilities.

Container classes add child management.

Specific widgets (Button, TextField, Label) add specialized behavior.

Framework users extend widgets to create custom components.

\subsection{Exception Hierarchy}

Exception hierarchies organize error types.

A root exception class defines basic exception capabilities.

Categories (RuntimeException, IOException) group related exceptions.

Specific exceptions provide precise error identification.

Handlers can catch at any level of specificity.

\subsection{Domain Entity Hierarchy}

Business domains often have natural type hierarchies.

A base entity class defines common properties (ID, timestamps).

Domain entities (Customer, Product, Order) extend with domain attributes.

Specialized entities (PreferredCustomer, DigitalProduct) add variations.

This models the domain while sharing common infrastructure.

\subsection{Plugin Architecture}

Plugin architectures use interfaces and abstract classes for extension.

An interface or abstract class defines the plugin contract.

Each plugin implements the contract.

The host discovers and loads plugins polymorphically.

New plugins are added without modifying the host.

%==============================================================================
\section{Best Practices}
%==============================================================================

Experience suggests several best practices for generalization.

\subsection{Favor Shallow Hierarchies}

Deep hierarchies create complexity.

Limit inheritance depth to three or four levels.

Extract interfaces rather than adding hierarchy levels.

Use composition to add behavior without deepening hierarchies.

\subsection{Design Abstract Classes Carefully}

Abstract classes define contracts for descendants.

Document which methods subclasses should override.

Document self-use (which methods call which other methods).

Make template method patterns explicit.

\subsection{Prefer Interface Inheritance}

Interface inheritance provides polymorphism without implementation coupling.

Define behavior contracts as interfaces.

Use abstract classes only when substantial implementation sharing is needed.

Multiple interface inheritance is safer than multiple implementation inheritance.

\subsection{Follow Substitutability}

Ensure children can substitute for parents.

Children should not throw unexpected exceptions.

Children should maintain parent invariants.

Test with parent types to verify substitutability.

\subsection{Document Extension Contracts}

Classes designed for extension need explicit documentation.

Specify which methods are safe to override.

Specify the expected behavior of overrides.

Document how inherited methods interact.

\subsection{Use Final Appropriately}

Final prevents inheritance where it would be fragile.

Mark classes final when not designed for extension.

Mark methods final when overriding would break invariants.

Prefer final as the default, opening for extension deliberately.

\subsection{Avoid Type Checking}

Excessive type checking suggests missing polymorphism.

Replace type checks with polymorphic methods.

Add methods to interfaces rather than checking interface type.

If type checking is needed, it may indicate a design problem.

%==============================================================================
\section{Common Challenges}
%==============================================================================

Generalization presents several common challenges.

\subsection{Fragile Base Class Problem}

Changes to base classes can break derived classes.

Derived classes may depend on implementation details of base classes.

Base class changes may violate assumptions of derived classes.

Strategies include documenting extension contracts, using composition instead of inheritance, and thorough regression testing.

\subsection{Inappropriate Inheritance}

Not every commonality warrants inheritance.

Using inheritance for code reuse without true \emph{is-a} relationship creates problems.

Violations of substitutability indicate inappropriate inheritance.

Strategies include favoring composition, using interfaces for polymorphism, and reserving inheritance for true type relationships.

\subsection{Deep Hierarchy Complexity}

Deep hierarchies become difficult to understand.

Behavior is scattered across many levels.

Changes may have unexpected effects.

Strategies include limiting hierarchy depth, using composition to flatten structures, and extracting interfaces.

\subsection{Multiple Inheritance Complexity}

Multiple inheritance creates complexity and potential ambiguity.

Diamond problem complicates member resolution.

Understanding behavior requires analyzing all parent paths.

Strategies include avoiding multiple implementation inheritance, using interfaces for multiple type membership, and using mixins or traits with explicit resolution.

\subsection{Inheritance vs. Composition Decisions}

Choosing between inheritance and composition is often difficult.

Both can achieve similar goals.

Inheritance provides easier implementation but tighter coupling.

Strategies include defaulting to composition, using inheritance for stable \emph{is-a} relationships, and refactoring from inheritance to composition when coupling becomes problematic.

\subsection{Interface Evolution}

Adding methods to interfaces breaks all implementers.

Large interfaces are difficult to implement correctly.

Strategies include interface segregation, default methods (where supported), and version tolerance through abstract adapter classes.

%==============================================================================
\section{Conclusion}
%==============================================================================

The generalization style provides powerful mechanisms for organizing modules into hierarchies that capture commonalities and support variation. Through inheritance and polymorphism, generalization enables code reuse, flexible extension, and modeling of type relationships.

Effective use of generalization requires understanding its trade-offs. Inheritance creates tight coupling and risks fragile hierarchies, but properly designed hierarchies enable elegant extension and powerful polymorphism. The principles and patterns described in this document provide guidance for creating robust, maintainable generalization structures.

The generalization view complements decomposition and uses views, adding inheritance relationships to the module structure. Together, these views provide a comprehensive picture of how modules are organized and related.

Understanding generalization equips architects to design effective inheritance hierarchies, choose appropriately between inheritance and composition, and create systems that support evolution and reuse through well-designed type structures.

%==============================================================================
\section*{References}
%==============================================================================

\begin{itemize}
  \item Clements, P., Bachmann, F., Bass, L., Garlan, D., Ivers, J., Little, R., Merson, P., Nord, R., \& Stafford, J. (2010). \textit{Documenting Software Architectures: Views and Beyond} (2nd ed.). Addison-Wesley Professional.
  \item Gamma, E., Helm, R., Johnson, R., \& Vlissides, J. (1994). \textit{Design Patterns: Elements of Reusable Object-Oriented Software}. Addison-Wesley Professional.
  \item Martin, R. C. (2017). \textit{Clean Architecture: A Craftsman's Guide to Software Structure and Design}. Prentice Hall.
  \item Liskov, B. H., \& Wing, J. M. (1994). A behavioral notion of subtyping. \textit{ACM Transactions on Programming Languages and Systems}, 16(6), 1811--1841.
  \item Bloch, J. (2018). \textit{Effective Java} (3rd ed.). Addison-Wesley Professional.
  \item Meyer, B. (1997). \textit{Object-Oriented Software Construction} (2nd ed.). Prentice Hall.
\end{itemize}

%==============================================================================
\listoffigures
%==============================================================================

\end{document}