\documentclass[11pt,letterpaper]{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[margin=1in,headheight=14pt]{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{float}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tcolorbox}
\usepackage{multicol}

% Colors
\definecolor{codebackground}{RGB}{248,248,248}
\definecolor{codeborder}{RGB}{200,200,200}
\definecolor{codecomment}{RGB}{106,153,85}
\definecolor{codekeyword}{RGB}{86,156,214}
\definecolor{codestring}{RGB}{206,145,120}
\definecolor{codenumber}{RGB}{181,206,168}
\definecolor{codepreproc}{RGB}{155,89,182}
\definecolor{headerblue}{RGB}{0,82,147}
\definecolor{sectionblue}{RGB}{41,128,185}
\definecolor{noteyellow}{RGB}{255,243,205}
\definecolor{noteborder}{RGB}{255,193,7}
\definecolor{warningred}{RGB}{248,215,218}
\definecolor{warningborder}{RGB}{220,53,69}
\definecolor{tipgreen}{RGB}{212,237,218}
\definecolor{tipborder}{RGB}{40,167,69}

% Listings
\lstdefinestyle{cstyle}{
    language=C,
    basicstyle=\ttfamily\footnotesize,
    backgroundcolor=\color{codebackground},
    frame=single,
    rulecolor=\color{codeborder},
    keywordstyle=\color{codekeyword}\bfseries,
    commentstyle=\color{codecomment}\itshape,
    stringstyle=\color{codestring},
    numberstyle=\tiny\color{codenumber},
    numbers=left,
    numbersep=8pt,
    breaklines=true,
    breakatwhitespace=true,
    showstringspaces=false,
    tabsize=4,
    captionpos=b,
    xleftmargin=15pt,
    framexleftmargin=15pt,
    morekeywords={uint32_t,uint64_t,int32_t,int64_t,size_t,uint8_t,int8_t,
                  uint16_t,int16_t,bool,true,false,NULL,inline,restrict,
                  ph_world,ph_body_id,ph_shape_id,ph_vec3,ph_quat,ph_transform,
                  ph_body_desc,ph_shape_desc,ph_world_desc,ph_mat44,ph_aabb,
                  SDL_Window,SDL_GLContext,SDL_Event,GLuint,GLint,GLfloat,
                  game_state_t,entity_t,mesh_id,shader_id,texture_id},
    morecomment=[l][\color{codepreproc}]{\#},
}

\lstdefinestyle{glslstyle}{
    language=C,
    basicstyle=\ttfamily\footnotesize,
    backgroundcolor=\color{codebackground},
    frame=single,
    rulecolor=\color{codeborder},
    keywordstyle=\color{codekeyword}\bfseries,
    commentstyle=\color{codecomment}\itshape,
    stringstyle=\color{codestring},
    numbers=left,
    numbersep=8pt,
    breaklines=true,
    showstringspaces=false,
    tabsize=4,
    xleftmargin=15pt,
    framexleftmargin=15pt,
    morekeywords={vec2,vec3,vec4,mat3,mat4,sampler2D,uniform,in,out,
                  layout,location,precision,highp,mediump,lowp},
}

\lstdefinestyle{cmakestyle}{
    language=bash,
    basicstyle=\ttfamily\footnotesize,
    backgroundcolor=\color{codebackground},
    frame=single,
    rulecolor=\color{codeborder},
    keywordstyle=\color{codekeyword}\bfseries,
    commentstyle=\color{codecomment}\itshape,
    numbers=left,
    numbersep=8pt,
    breaklines=true,
    showstringspaces=false,
    tabsize=2,
    xleftmargin=15pt,
    framexleftmargin=15pt,
    morekeywords={cmake_minimum_required,project,set,option,add_library,
                  add_executable,target_include_directories,target_compile_features,
                  target_compile_definitions,target_link_libraries,install,
                  if,endif,else,elseif,find_package,include,message,
                  STATIC,SHARED,PUBLIC,PRIVATE,INTERFACE,FetchContent_Declare,
                  FetchContent_MakeAvailable,GIT_REPOSITORY,GIT_TAG},
}

\lstdefinestyle{bashstyle}{
    language=bash,
    basicstyle=\ttfamily\footnotesize,
    backgroundcolor=\color{codebackground},
    frame=single,
    rulecolor=\color{codeborder},
    keywordstyle=\color{codekeyword}\bfseries,
    commentstyle=\color{codecomment}\itshape,
    numbers=left,
    numbersep=8pt,
    breaklines=true,
    showstringspaces=false,
    tabsize=2,
    xleftmargin=15pt,
    framexleftmargin=15pt,
}

\lstset{style=cstyle}

% Tcolorbox
\tcbuselibrary{skins,breakable}

\newtcolorbox{notebox}[1][Note]{
    enhanced,breakable,colback=noteyellow,colframe=noteborder,
    fonttitle=\bfseries,title=#1,left=8pt,right=8pt,top=6pt,bottom=6pt,
}

\newtcolorbox{warningbox}[1][Warning]{
    enhanced,breakable,colback=warningred,colframe=warningborder,
    fonttitle=\bfseries,title=#1,left=8pt,right=8pt,top=6pt,bottom=6pt,
}

\newtcolorbox{tipbox}[1][Tip]{
    enhanced,breakable,colback=tipgreen,colframe=tipborder,
    fonttitle=\bfseries,title=#1,left=8pt,right=8pt,top=6pt,bottom=6pt,
}

\newtcolorbox{definitionbox}[1][Definition]{
    enhanced,breakable,colback=white,colframe=sectionblue,
    fonttitle=\bfseries,title=#1,left=8pt,right=8pt,top=6pt,bottom=6pt,
}

% Headers
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{\thepage}
\fancyfoot[C]{\small Cross-Platform Physics Engine with SDL3/OpenGL}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% Title formatting
\titleformat{\chapter}[display]
    {\normalfont\huge\bfseries\color{headerblue}}
    {\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titleformat{\section}
    {\normalfont\Large\bfseries\color{sectionblue}}
    {\thesection}{1em}{}
\titleformat{\subsection}
    {\normalfont\large\bfseries\color{sectionblue!80}}
    {\thesubsection}{1em}{}

% Hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=sectionblue,
    urlcolor=sectionblue,
    pdftitle={Cross-Platform Physics Engine with SDL3/OpenGL},
}

\title{
    \vspace{-2cm}
    {\Huge\bfseries\color{headerblue} Cross-Platform Physics Engine}\\[0.3cm]
    {\LARGE\color{sectionblue} with SDL3 and OpenGL Integration}\\[0.8cm]
    {\large Complete Guide to Building a Portable Physics Engine in C\\
    with Native and WebAssembly Deployment}\\[1.5cm]
    {\normalsize Version 2.0}
}

\author{Technical Architecture Documentation}
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty}

\newpage
\tableofcontents
\newpage

% ============================================================================
% CHAPTER 1: INTRODUCTION
% ============================================================================
\chapter{Introduction and Architecture Overview}

\section{Document Purpose}

This guide provides a complete blueprint for building a highly portable physics engine in C that compiles to native code (desktop, mobile, consoles) and WebAssembly (browsers). The engine integrates with SDL3 for platform abstraction and OpenGL for hardware-accelerated rendering.

\section{Target Platforms}

\begin{table}[H]
\centering
\caption{Platform Support Matrix}
\begin{tabular}{lllll}
\toprule
\textbf{Platform} & \textbf{Architecture} & \textbf{Graphics} & \textbf{Toolchain} & \textbf{Output} \\
\midrule
Windows & x86\_64, ARM64 & OpenGL 3.3+ & MSVC/Clang & .exe \\
macOS & ARM64, x86\_64 & OpenGL 4.1 & Clang & .app \\
Linux & x86\_64 & OpenGL 3.3+ & GCC/Clang & ELF \\
iOS & ARM64 & OpenGL ES 3.0 & Xcode & .ipa \\
Android & ARM64 & OpenGL ES 3.0 & NDK & .apk \\
Web & WASM32 & WebGL 2.0 & Emscripten & .wasm \\
\bottomrule
\end{tabular}
\end{table}

\section{System Architecture}

\begin{lstlisting}[caption={Layered Architecture Overview}]
+----------------------------------------------------------+
|                    APPLICATION LAYER                      |
|         Game Logic, Entities, Scenes, UI                 |
+----------------------------------------------------------+
                            |
+----------------------------------------------------------+
|                   INTEGRATION LAYER                       |
|     Entity-Body Mapping, Event Routing, Transform Sync   |
+----------------------------------------------------------+
            |                               |
+------------------------+    +-----------------------------+
|    PHYSICS ENGINE      |    |      RENDERING ENGINE       |
|  Dynamics, Collision,  |    |   SDL3 + OpenGL, Shaders,  |
|  Queries, Constraints  |    |   Meshes, Debug Draw       |
+------------------------+    +-----------------------------+
            |                               |
+----------------------------------------------------------+
|              PLATFORM ABSTRACTION (SDL3)                  |
|       Window, Input, Audio, Threading, File I/O          |
+----------------------------------------------------------+
                            |
+----------------------------------------------------------+
|           Native OS / WebAssembly / Console SDK          |
+----------------------------------------------------------+
\end{lstlisting}

\section{Design Principles}

\begin{definitionbox}[Core Design Principles]
\begin{enumerate}[leftmargin=*]
    \item \textbf{Zero Dependencies:} Physics core requires only C standard library
    \item \textbf{Stable C ABI:} Opaque handles and POD structures for binary compatibility
    \item \textbf{Deterministic Simulation:} Fixed timestep with reproducible results
    \item \textbf{Platform Agnostic:} No OS calls in core; all platform interaction via hooks
    \item \textbf{Memory Control:} User-provided allocators for all memory operations
\end{enumerate}
\end{definitionbox}

% ============================================================================
% CHAPTER 2: PROJECT STRUCTURE
% ============================================================================
\chapter{Project Structure and Build System}

\section{Repository Layout}

\begin{lstlisting}[style=bashstyle,caption={Directory Structure}]
physics-game/
|-- CMakeLists.txt              # Root build configuration
|-- physics/                    # Physics engine library
|   |-- CMakeLists.txt
|   |-- include/physics/
|   |   |-- physics.h           # Main public API
|   |   |-- physics_types.h     # Type definitions
|   |   `-- physics_math.h      # Math utilities
|   `-- src/
|       |-- physics_world.c
|       |-- physics_body.c
|       |-- physics_collision.c
|       `-- physics_solver.c
|-- engine/                     # SDL3/OpenGL engine layer
|   |-- CMakeLists.txt
|   |-- include/engine/
|   |   |-- platform.h          # Platform abstraction
|   |   |-- renderer.h          # OpenGL rendering
|   |   `-- debug_draw.h        # Physics visualization
|   `-- src/
|       |-- platform_sdl3.c
|       |-- renderer_gl.c
|       `-- debug_draw.c
|-- game/                       # Game application
|   |-- CMakeLists.txt
|   |-- src/
|   |   |-- main.c
|   |   |-- game.c
|   |   `-- physics_integration.c
|   |-- assets/
|   |   `-- shaders/
|   `-- web/
|       `-- index.html
`-- cmake/
    |-- CompilerWarnings.cmake
    `-- EmscriptenHelpers.cmake
\end{lstlisting}

\section{Root CMake Configuration}

\begin{lstlisting}[style=cmakestyle,caption={Root CMakeLists.txt}]
cmake_minimum_required(VERSION 3.20)

project(PhysicsGame VERSION 1.0.0 LANGUAGES C)

# Options
option(BUILD_SHARED_LIBS "Build shared libraries" OFF)
option(ENABLE_SIMD "Enable SIMD optimizations" ON)

# C Standard
set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)

# Platform detection
if(EMSCRIPTEN)
    set(PLATFORM_WEB TRUE)
    message(STATUS "Building for Web (Emscripten)")
elseif(WIN32)
    set(PLATFORM_WINDOWS TRUE)
elseif(APPLE)
    set(PLATFORM_APPLE TRUE)
else()
    set(PLATFORM_LINUX TRUE)
endif()

# Find SDL3 (or fetch it)
if(NOT EMSCRIPTEN)
    find_package(SDL3 QUIET)
    if(NOT SDL3_FOUND)
        include(FetchContent)
        FetchContent_Declare(SDL3
            GIT_REPOSITORY https://github.com/libsdl-org/SDL.git
            GIT_TAG main
            GIT_SHALLOW TRUE
        )
        set(SDL_SHARED OFF CACHE BOOL "" FORCE)
        set(SDL_STATIC ON CACHE BOOL "" FORCE)
        FetchContent_MakeAvailable(SDL3)
    endif()
endif()

# Add subdirectories
add_subdirectory(physics)
add_subdirectory(engine)
add_subdirectory(game)
\end{lstlisting}

\section{Physics Library CMake}

\begin{lstlisting}[style=cmakestyle,caption={physics/CMakeLists.txt}]
set(PHYSICS_SOURCES
    src/physics_world.c
    src/physics_body.c
    src/physics_shape.c
    src/physics_collision.c
    src/physics_solver.c
    src/physics_broadphase.c
    src/physics_query.c
    src/physics_math.c
)

add_library(physics_engine STATIC ${PHYSICS_SOURCES})

target_include_directories(physics_engine PUBLIC
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:include>
)

target_compile_features(physics_engine PUBLIC c_std_11)

# Platform-specific settings
if(EMSCRIPTEN)
    target_compile_definitions(physics_engine PRIVATE
        PH_PLATFORM_WEB=1
        PH_NO_THREADING=1
    )
endif()

# Disable fast-math for determinism
if(NOT MSVC)
    target_compile_options(physics_engine PRIVATE
        -fno-fast-math
        -ffp-contract=off
    )
else()
    target_compile_options(physics_engine PRIVATE /fp:precise)
endif()

add_library(Physics::Engine ALIAS physics_engine)
\end{lstlisting}

\section{Game Application CMake}

\begin{lstlisting}[style=cmakestyle,caption={game/CMakeLists.txt}]
set(GAME_SOURCES
    src/main.c
    src/game.c
    src/physics_integration.c
)

add_executable(physics_game ${GAME_SOURCES})

target_link_libraries(physics_game PRIVATE
    Physics::Engine
    Engine::Core
)

if(EMSCRIPTEN)
    set(EM_FLAGS
        "-s USE_SDL=3"
        "-s MIN_WEBGL_VERSION=2"
        "-s MAX_WEBGL_VERSION=2"
        "-s WASM=1"
        "-s ALLOW_MEMORY_GROWTH=1"
        "-s NO_EXIT_RUNTIME=1"
        "--preload-file ${CMAKE_CURRENT_SOURCE_DIR}/assets@/assets"
    )
    
    if(CMAKE_BUILD_TYPE STREQUAL "Release")
        list(APPEND EM_FLAGS "-O3" "--closure 1")
    else()
        list(APPEND EM_FLAGS "-g" "-s ASSERTIONS=2")
    endif()
    
    string(REPLACE ";" " " EM_FLAGS_STR "${EM_FLAGS}")
    set_target_properties(physics_game PROPERTIES
        SUFFIX ".html"
        LINK_FLAGS "${EM_FLAGS_STR}"
    )
else()
    # Copy assets for native builds
    add_custom_command(TARGET physics_game POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_directory
            "${CMAKE_CURRENT_SOURCE_DIR}/assets"
            "$<TARGET_FILE_DIR:physics_game>/assets"
    )
endif()
\end{lstlisting}

% ============================================================================
% CHAPTER 3: PHYSICS ENGINE CORE
% ============================================================================
\chapter{Physics Engine Core Implementation}

\section{Configuration and Types}

\begin{lstlisting}[caption={physics/include/physics/physics\_types.h}]
#ifndef PHYSICS_TYPES_H
#define PHYSICS_TYPES_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

/* DLL Export/Import */
#if defined(_WIN32) && defined(PH_BUILDING_DLL)
    #define PH_API __declspec(dllexport)
#elif defined(_WIN32) && defined(PH_USING_DLL)
    #define PH_API __declspec(dllimport)
#else
    #define PH_API
#endif

/* Configuration */
#define PH_MAX_BODIES   4096
#define PH_MAX_SHAPES   8192
#define PH_MAX_CONTACTS 16384
#define PH_PI           3.14159265358979323846f
#define PH_EPSILON      1e-6f

/* ================================================================
 * MATHEMATICAL TYPES
 * ================================================================ */

typedef struct ph_vec3 {
    float x, y, z;
} ph_vec3;

typedef struct ph_quat {
    float x, y, z, w;
} ph_quat;

typedef struct ph_transform {
    ph_vec3 position;
    ph_quat rotation;
} ph_transform;

typedef struct ph_mat44 {
    float m[4][4];
} ph_mat44;

typedef struct ph_aabb {
    ph_vec3 min;
    ph_vec3 max;
} ph_aabb;

/* ================================================================
 * HANDLE TYPES
 * ================================================================ */

typedef uint32_t ph_body_id;
typedef uint32_t ph_shape_id;

#define PH_INVALID_BODY  ((ph_body_id)0)
#define PH_INVALID_SHAPE ((ph_shape_id)0)

/* ================================================================
 * HOST CONFIGURATION
 * ================================================================ */

typedef void* (*ph_alloc_fn)(void* user, size_t size, size_t align);
typedef void  (*ph_free_fn)(void* user, void* ptr);
typedef void  (*ph_log_fn)(void* user, int level, const char* msg);

typedef struct ph_host_config {
    void*       user_context;
    ph_alloc_fn alloc;
    ph_free_fn  free;
    ph_log_fn   log;
} ph_host_config;

/* ================================================================
 * BODY TYPES
 * ================================================================ */

typedef enum ph_body_type {
    PH_BODY_STATIC    = 0,
    PH_BODY_KINEMATIC = 1,
    PH_BODY_DYNAMIC   = 2
} ph_body_type;

typedef struct ph_body_desc {
    ph_body_type type;
    ph_transform initial_pose;
    ph_vec3      linear_velocity;
    ph_vec3      angular_velocity;
    float        mass;
    float        linear_damping;
    float        angular_damping;
    float        gravity_scale;
    bool         allow_sleep;
    uint32_t     user_data;
} ph_body_desc;

/* ================================================================
 * SHAPE TYPES
 * ================================================================ */

typedef enum ph_shape_type {
    PH_SHAPE_SPHERE  = 0,
    PH_SHAPE_BOX     = 1,
    PH_SHAPE_CAPSULE = 2,
    PH_SHAPE_PLANE   = 3
} ph_shape_type;

typedef struct ph_material {
    float friction;
    float restitution;
    float density;
} ph_material;

typedef struct ph_collision_filter {
    uint32_t category;
    uint32_t mask;
} ph_collision_filter;

typedef struct ph_shape_desc {
    ph_shape_type type;
    union {
        struct { float radius; } sphere;
        struct { ph_vec3 half_extents; } box;
        struct { float radius; float half_height; } capsule;
        struct { ph_vec3 normal; float distance; } plane;
    } geometry;
    ph_transform        local_pose;
    ph_material         material;
    ph_collision_filter filter;
    bool                is_sensor;
} ph_shape_desc;

/* ================================================================
 * WORLD CONFIGURATION
 * ================================================================ */

typedef struct ph_world_desc {
    ph_vec3  gravity;
    int32_t  velocity_iterations;
    int32_t  position_iterations;
    float    contact_slop;
    float    baumgarte;
    bool     enable_sleeping;
} ph_world_desc;

/* ================================================================
 * QUERY TYPES
 * ================================================================ */

typedef struct ph_raycast_hit {
    ph_body_id  body;
    ph_shape_id shape;
    float       distance;
    ph_vec3     point;
    ph_vec3     normal;
} ph_raycast_hit;

typedef struct ph_query_filter {
    uint32_t category_mask;
    uint32_t collision_mask;
    bool     include_sensors;
} ph_query_filter;

/* ================================================================
 * CONTACT CALLBACKS
 * ================================================================ */

typedef enum ph_contact_event {
    PH_CONTACT_BEGIN   = 0,
    PH_CONTACT_PERSIST = 1,
    PH_CONTACT_END     = 2
} ph_contact_event;

typedef struct ph_contact_data {
    ph_body_id       body_a;
    ph_body_id       body_b;
    ph_contact_event event;
    ph_vec3          point;
    ph_vec3          normal;
    float            penetration;
} ph_contact_data;

typedef void (*ph_contact_callback)(void* user, const ph_contact_data* data);

typedef struct ph_contact_listener {
    void*               user_context;
    ph_contact_callback on_begin;
    ph_contact_callback on_persist;
    ph_contact_callback on_end;
} ph_contact_listener;

#ifdef __cplusplus
}
#endif

#endif /* PHYSICS_TYPES_H */
\end{lstlisting}

\section{Main Physics API}

\begin{lstlisting}[caption={physics/include/physics/physics.h}]
#ifndef PHYSICS_H
#define PHYSICS_H

#include "physics_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/* Opaque world type */
typedef struct ph_world ph_world;

/* ================================================================
 * DEFAULT CONFIGURATIONS
 * ================================================================ */

PH_API ph_host_config  ph_default_host_config(void);
PH_API ph_world_desc   ph_default_world_desc(void);
PH_API ph_body_desc    ph_default_body_desc(void);
PH_API ph_shape_desc   ph_default_shape_desc(ph_shape_type type);
PH_API ph_query_filter ph_default_query_filter(void);

/* ================================================================
 * WORLD MANAGEMENT
 * ================================================================ */

PH_API ph_world* ph_world_create(const ph_world_desc* desc,
                                  const ph_host_config* host);
PH_API void      ph_world_destroy(ph_world* world);
PH_API void      ph_world_step(ph_world* world, float dt, int32_t substeps);
PH_API void      ph_world_set_gravity(ph_world* world, ph_vec3 gravity);
PH_API ph_vec3   ph_world_get_gravity(const ph_world* world);
PH_API uint32_t  ph_world_get_body_count(const ph_world* world);
PH_API void      ph_world_set_contact_listener(ph_world* world,
                                                const ph_contact_listener* l);

/* ================================================================
 * BODY MANAGEMENT
 * ================================================================ */

PH_API ph_body_id   ph_body_create(ph_world* w, const ph_body_desc* desc);
PH_API void         ph_body_destroy(ph_world* w, ph_body_id body);
PH_API bool         ph_body_is_valid(const ph_world* w, ph_body_id body);

PH_API ph_transform ph_body_get_transform(const ph_world* w, ph_body_id body);
PH_API void         ph_body_set_transform(ph_world* w, ph_body_id body,
                                           const ph_transform* t);
PH_API ph_vec3      ph_body_get_position(const ph_world* w, ph_body_id body);
PH_API void         ph_body_set_position(ph_world* w, ph_body_id body, ph_vec3 p);
PH_API ph_quat      ph_body_get_rotation(const ph_world* w, ph_body_id body);
PH_API void         ph_body_set_rotation(ph_world* w, ph_body_id body, ph_quat r);

PH_API ph_vec3 ph_body_get_linear_velocity(const ph_world* w, ph_body_id body);
PH_API void    ph_body_set_linear_velocity(ph_world* w, ph_body_id body, ph_vec3 v);
PH_API ph_vec3 ph_body_get_angular_velocity(const ph_world* w, ph_body_id body);
PH_API void    ph_body_set_angular_velocity(ph_world* w, ph_body_id body, ph_vec3 v);

PH_API void ph_body_apply_force(ph_world* w, ph_body_id body, ph_vec3 force);
PH_API void ph_body_apply_impulse(ph_world* w, ph_body_id body, ph_vec3 impulse);
PH_API void ph_body_apply_torque(ph_world* w, ph_body_id body, ph_vec3 torque);

PH_API uint32_t ph_body_get_user_data(const ph_world* w, ph_body_id body);
PH_API void     ph_body_set_user_data(ph_world* w, ph_body_id body, uint32_t data);
PH_API bool     ph_body_is_sleeping(const ph_world* w, ph_body_id body);
PH_API void     ph_body_wake(ph_world* w, ph_body_id body);

/* ================================================================
 * SHAPE MANAGEMENT
 * ================================================================ */

PH_API ph_shape_id ph_shape_create(ph_world* w, const ph_shape_desc* desc);
PH_API void        ph_shape_destroy(ph_world* w, ph_shape_id shape);
PH_API void        ph_body_attach_shape(ph_world* w, ph_body_id body,
                                         ph_shape_id shape);
PH_API void        ph_body_detach_shape(ph_world* w, ph_body_id body,
                                         ph_shape_id shape);

/* ================================================================
 * SPATIAL QUERIES
 * ================================================================ */

PH_API bool ph_world_raycast(const ph_world* w, ph_vec3 origin, ph_vec3 dir,
                              float max_dist, const ph_query_filter* filter,
                              ph_raycast_hit* out_hit);

PH_API int32_t ph_world_raycast_all(const ph_world* w, ph_vec3 origin, 
                                     ph_vec3 dir, float max_dist,
                                     const ph_query_filter* filter,
                                     ph_raycast_hit* out_hits, int32_t max_hits);

/* ================================================================
 * BATCH OPERATIONS
 * ================================================================ */

PH_API void ph_world_get_body_transforms(const ph_world* w,
                                          const ph_body_id* body_ids,
                                          int32_t count,
                                          ph_transform* out_transforms);

PH_API int32_t ph_world_get_all_bodies(const ph_world* w,
                                        ph_body_id* out_bodies,
                                        int32_t max_bodies);

#ifdef __cplusplus
}
#endif

#endif /* PHYSICS_H */
\end{lstlisting}

\section{World Implementation}

\begin{lstlisting}[caption={physics/src/physics\_world.c - Core World Implementation}]
#include "physics/physics.h"
#include <stdlib.h>
#include <string.h>
#include <math.h>

/* ================================================================
 * INTERNAL STRUCTURES
 * ================================================================ */

typedef struct body_internal {
    ph_transform transform;
    ph_vec3      linear_velocity;
    ph_vec3      angular_velocity;
    ph_vec3      force_accumulator;
    ph_vec3      torque_accumulator;
    float        mass;
    float        inv_mass;
    float        linear_damping;
    float        angular_damping;
    float        gravity_scale;
    ph_body_type type;
    uint16_t     generation;
    uint16_t     flags;
    uint32_t     user_data;
    ph_shape_id  first_shape;
    float        sleep_time;
} body_internal;

typedef struct shape_internal {
    ph_shape_type       type;
    ph_transform        local_pose;
    ph_material         material;
    ph_collision_filter filter;
    ph_aabb             local_bounds;
    ph_body_id          body;
    uint16_t            generation;
    bool                is_sensor;
    union {
        struct { float radius; } sphere;
        struct { ph_vec3 half_extents; } box;
        struct { float radius; float half_height; } capsule;
        struct { ph_vec3 normal; float distance; } plane;
    } geometry;
} shape_internal;

typedef struct contact_internal {
    ph_body_id body_a;
    ph_body_id body_b;
    ph_vec3    point;
    ph_vec3    normal;
    float      penetration;
    float      normal_impulse;
    float      tangent_impulse[2];
    bool       persisted;
} contact_internal;

struct ph_world {
    /* Host services */
    ph_host_config host;
    
    /* Configuration */
    ph_vec3  gravity;
    int32_t  velocity_iterations;
    int32_t  position_iterations;
    float    contact_slop;
    float    baumgarte;
    bool     enable_sleeping;
    
    /* Bodies */
    body_internal* bodies;
    uint16_t*      body_free_list;
    uint32_t       body_count;
    uint32_t       body_capacity;
    uint32_t       body_free_count;
    
    /* Shapes */
    shape_internal* shapes;
    uint16_t*       shape_free_list;
    uint32_t        shape_count;
    uint32_t        shape_capacity;
    uint32_t        shape_free_count;
    
    /* Contacts */
    contact_internal* contacts;
    uint32_t          contact_count;
    uint32_t          contact_capacity;
    
    /* Contact listener */
    ph_contact_listener contact_listener;
};

/* ================================================================
 * MEMORY HELPERS
 * ================================================================ */

static void* world_alloc(ph_world* w, size_t size, size_t align) {
    if (w->host.alloc) {
        return w->host.alloc(w->host.user_context, size, align);
    }
    return malloc(size);
}

static void world_free(ph_world* w, void* ptr) {
    if (w->host.free) {
        w->host.free(w->host.user_context, ptr);
    } else {
        free(ptr);
    }
}

/* ================================================================
 * DEFAULT CONFIGURATIONS
 * ================================================================ */

ph_host_config ph_default_host_config(void) {
    return (ph_host_config){
        .user_context = NULL,
        .alloc = NULL,
        .free = NULL,
        .log = NULL
    };
}

ph_world_desc ph_default_world_desc(void) {
    return (ph_world_desc){
        .gravity = { 0.0f, -9.81f, 0.0f },
        .velocity_iterations = 8,
        .position_iterations = 3,
        .contact_slop = 0.005f,
        .baumgarte = 0.2f,
        .enable_sleeping = true
    };
}

ph_body_desc ph_default_body_desc(void) {
    return (ph_body_desc){
        .type = PH_BODY_DYNAMIC,
        .initial_pose = {
            .position = { 0, 0, 0 },
            .rotation = { 0, 0, 0, 1 }
        },
        .linear_velocity = { 0, 0, 0 },
        .angular_velocity = { 0, 0, 0 },
        .mass = 1.0f,
        .linear_damping = 0.01f,
        .angular_damping = 0.01f,
        .gravity_scale = 1.0f,
        .allow_sleep = true,
        .user_data = 0
    };
}

ph_shape_desc ph_default_shape_desc(ph_shape_type type) {
    ph_shape_desc desc = {0};
    desc.type = type;
    desc.local_pose.rotation = (ph_quat){ 0, 0, 0, 1 };
    desc.material.friction = 0.5f;
    desc.material.restitution = 0.3f;
    desc.material.density = 1000.0f;
    desc.filter.category = 0x0001;
    desc.filter.mask = 0xFFFF;
    
    switch (type) {
        case PH_SHAPE_SPHERE:
            desc.geometry.sphere.radius = 0.5f;
            break;
        case PH_SHAPE_BOX:
            desc.geometry.box.half_extents = (ph_vec3){ 0.5f, 0.5f, 0.5f };
            break;
        case PH_SHAPE_CAPSULE:
            desc.geometry.capsule.radius = 0.5f;
            desc.geometry.capsule.half_height = 0.5f;
            break;
        case PH_SHAPE_PLANE:
            desc.geometry.plane.normal = (ph_vec3){ 0, 1, 0 };
            desc.geometry.plane.distance = 0.0f;
            break;
    }
    
    return desc;
}

ph_query_filter ph_default_query_filter(void) {
    return (ph_query_filter){
        .category_mask = 0xFFFF,
        .collision_mask = 0xFFFF,
        .include_sensors = false
    };
}

/* ================================================================
 * WORLD LIFECYCLE
 * ================================================================ */

ph_world* ph_world_create(const ph_world_desc* desc,
                          const ph_host_config* host) {
    ph_world* w = malloc(sizeof(ph_world));
    if (!w) return NULL;
    
    memset(w, 0, sizeof(ph_world));
    
    if (host) {
        w->host = *host;
    }
    
    /* Copy configuration */
    w->gravity = desc->gravity;
    w->velocity_iterations = desc->velocity_iterations;
    w->position_iterations = desc->position_iterations;
    w->contact_slop = desc->contact_slop;
    w->baumgarte = desc->baumgarte;
    w->enable_sleeping = desc->enable_sleeping;
    
    /* Allocate bodies */
    w->body_capacity = PH_MAX_BODIES;
    w->bodies = world_alloc(w, w->body_capacity * sizeof(body_internal), 16);
    w->body_free_list = world_alloc(w, w->body_capacity * sizeof(uint16_t), 4);
    memset(w->bodies, 0, w->body_capacity * sizeof(body_internal));
    
    /* Initialize free list (skip index 0 for invalid handle) */
    for (uint32_t i = 1; i < w->body_capacity; i++) {
        w->body_free_list[w->body_free_count++] = (uint16_t)i;
    }
    
    /* Allocate shapes */
    w->shape_capacity = PH_MAX_SHAPES;
    w->shapes = world_alloc(w, w->shape_capacity * sizeof(shape_internal), 16);
    w->shape_free_list = world_alloc(w, w->shape_capacity * sizeof(uint16_t), 4);
    memset(w->shapes, 0, w->shape_capacity * sizeof(shape_internal));
    
    for (uint32_t i = 1; i < w->shape_capacity; i++) {
        w->shape_free_list[w->shape_free_count++] = (uint16_t)i;
    }
    
    /* Allocate contacts */
    w->contact_capacity = PH_MAX_CONTACTS;
    w->contacts = world_alloc(w, w->contact_capacity * sizeof(contact_internal), 16);
    
    return w;
}

void ph_world_destroy(ph_world* w) {
    if (!w) return;
    
    world_free(w, w->bodies);
    world_free(w, w->body_free_list);
    world_free(w, w->shapes);
    world_free(w, w->shape_free_list);
    world_free(w, w->contacts);
    
    free(w);
}

/* ================================================================
 * SIMULATION STEP
 * ================================================================ */

/* Vector math helpers */
static inline ph_vec3 vec3_add(ph_vec3 a, ph_vec3 b) {
    return (ph_vec3){ a.x + b.x, a.y + b.y, a.z + b.z };
}

static inline ph_vec3 vec3_scale(ph_vec3 v, float s) {
    return (ph_vec3){ v.x * s, v.y * s, v.z * s };
}

static inline float vec3_length_sq(ph_vec3 v) {
    return v.x * v.x + v.y * v.y + v.z * v.z;
}

void ph_world_step(ph_world* w, float dt, int32_t substeps) {
    if (!w || dt <= 0.0f || substeps <= 0) return;
    
    float sub_dt = dt / (float)substeps;
    
    for (int32_t sub = 0; sub < substeps; sub++) {
        /* 1. Apply gravity and integrate velocities */
        for (uint32_t i = 1; i < w->body_capacity; i++) {
            body_internal* body = &w->bodies[i];
            if (body->generation == 0) continue;  /* Inactive slot */
            if (body->type != PH_BODY_DYNAMIC) continue;
            if (body->flags & 0x01) continue;  /* Sleeping */
            
            /* Apply gravity */
            ph_vec3 gravity_force = vec3_scale(w->gravity, 
                                               body->mass * body->gravity_scale);
            body->force_accumulator = vec3_add(body->force_accumulator, 
                                               gravity_force);
            
            /* Integrate velocity: v += (F/m) * dt */
            ph_vec3 acceleration = vec3_scale(body->force_accumulator, 
                                              body->inv_mass);
            body->linear_velocity = vec3_add(body->linear_velocity,
                                             vec3_scale(acceleration, sub_dt));
            
            /* Apply damping */
            float linear_damping = 1.0f - body->linear_damping * sub_dt;
            if (linear_damping < 0.0f) linear_damping = 0.0f;
            body->linear_velocity = vec3_scale(body->linear_velocity, 
                                               linear_damping);
            
            /* Clear accumulators */
            body->force_accumulator = (ph_vec3){ 0, 0, 0 };
            body->torque_accumulator = (ph_vec3){ 0, 0, 0 };
        }
        
        /* 2. Broadphase collision detection */
        /* TODO: Implement spatial hashing or BVH */
        
        /* 3. Narrowphase collision detection */
        /* TODO: Implement GJK/SAT collision detection */
        
        /* 4. Solve velocity constraints */
        for (int32_t iter = 0; iter < w->velocity_iterations; iter++) {
            /* TODO: Solve contact constraints */
        }
        
        /* 5. Integrate positions */
        for (uint32_t i = 1; i < w->body_capacity; i++) {
            body_internal* body = &w->bodies[i];
            if (body->generation == 0) continue;
            if (body->type == PH_BODY_STATIC) continue;
            if (body->flags & 0x01) continue;  /* Sleeping */
            
            /* p += v * dt */
            body->transform.position = vec3_add(body->transform.position,
                vec3_scale(body->linear_velocity, sub_dt));
            
            /* TODO: Integrate rotation using angular velocity */
        }
        
        /* 6. Solve position constraints */
        for (int32_t iter = 0; iter < w->position_iterations; iter++) {
            /* TODO: Solve position errors */
        }
        
        /* 7. Update sleeping */
        if (w->enable_sleeping) {
            for (uint32_t i = 1; i < w->body_capacity; i++) {
                body_internal* body = &w->bodies[i];
                if (body->generation == 0) continue;
                if (body->type != PH_BODY_DYNAMIC) continue;
                
                float speed_sq = vec3_length_sq(body->linear_velocity);
                if (speed_sq < 0.01f * 0.01f) {
                    body->sleep_time += sub_dt;
                    if (body->sleep_time > 0.5f) {
                        body->flags |= 0x01;  /* Set sleeping flag */
                    }
                } else {
                    body->sleep_time = 0.0f;
                    body->flags &= ~0x01;  /* Clear sleeping flag */
                }
            }
        }
    }
}

void ph_world_set_gravity(ph_world* w, ph_vec3 gravity) {
    if (w) w->gravity = gravity;
}

ph_vec3 ph_world_get_gravity(const ph_world* w) {
    return w ? w->gravity : (ph_vec3){ 0, 0, 0 };
}

uint32_t ph_world_get_body_count(const ph_world* w) {
    return w ? w->body_count : 0;
}

void ph_world_set_contact_listener(ph_world* w, const ph_contact_listener* l) {
    if (w && l) {
        w->contact_listener = *l;
    }
}
\end{lstlisting}

% ============================================================================
% CHAPTER 4: SDL3 PLATFORM LAYER
% ============================================================================
\chapter{SDL3 Platform Layer}

\section{Platform Header}

\begin{lstlisting}[caption={engine/include/engine/platform.h}]
#ifndef ENGINE_PLATFORM_H
#define ENGINE_PLATFORM_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Platform configuration */
typedef struct platform_config {
    const char* window_title;
    int32_t     window_width;
    int32_t     window_height;
    bool        fullscreen;
    bool        vsync;
    bool        resizable;
} platform_config;

/* Default configuration */
platform_config platform_default_config(void);

/* Lifecycle */
bool   platform_init(const platform_config* config);
void   platform_shutdown(void);
bool   platform_pump_events(void);
void   platform_swap_buffers(void);

/* Timing */
double platform_get_time(void);
float  platform_get_delta_time(void);

/* Window */
void platform_get_window_size(int32_t* w, int32_t* h);
void platform_get_framebuffer_size(int32_t* w, int32_t* h);
bool platform_has_focus(void);

/* Input - Keyboard */
typedef enum key_code {
    KEY_UNKNOWN = 0,
    KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H,
    KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P,
    KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X,
    KEY_Y, KEY_Z,
    KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9,
    KEY_SPACE, KEY_ENTER, KEY_ESCAPE, KEY_BACKSPACE, KEY_TAB,
    KEY_LEFT, KEY_RIGHT, KEY_UP, KEY_DOWN,
    KEY_LEFT_SHIFT, KEY_RIGHT_SHIFT, KEY_LEFT_CTRL, KEY_RIGHT_CTRL,
    KEY_COUNT
} key_code;

bool input_key_down(key_code key);
bool input_key_pressed(key_code key);
bool input_key_released(key_code key);

/* Input - Mouse */
typedef enum mouse_button {
    MOUSE_LEFT = 0, MOUSE_MIDDLE = 1, MOUSE_RIGHT = 2,
    MOUSE_BUTTON_COUNT
} mouse_button;

bool  input_mouse_down(mouse_button button);
bool  input_mouse_pressed(mouse_button button);
void  input_get_mouse_position(float* x, float* y);
void  input_get_mouse_delta(float* dx, float* dy);
float input_get_mouse_wheel(void);
void  input_set_mouse_captured(bool captured);

/* File I/O */
void*       platform_read_file(const char* path, size_t* out_size);
bool        platform_write_file(const char* path, const void* data, size_t size);
const char* platform_get_base_path(void);

#ifdef __cplusplus
}
#endif

#endif /* ENGINE_PLATFORM_H */
\end{lstlisting}

\section{SDL3 Implementation}

\begin{lstlisting}[caption={engine/src/platform\_sdl3.c - SDL3 Implementation}]
#include "engine/platform.h"
#include <SDL3/SDL.h>
#include <SDL3/SDL_opengl.h>
#include <string.h>
#include <stdlib.h>

#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#endif

/* Static state */
static struct {
    SDL_Window*   window;
    SDL_GLContext gl_context;
    
    uint64_t perf_frequency;
    uint64_t last_frame_time;
    float    delta_time;
    double   total_time;
    
    uint8_t keys_current[KEY_COUNT];
    uint8_t keys_previous[KEY_COUNT];
    uint8_t mouse_current[MOUSE_BUTTON_COUNT];
    uint8_t mouse_previous[MOUSE_BUTTON_COUNT];
    float   mouse_x, mouse_y;
    float   mouse_dx, mouse_dy;
    float   mouse_wheel;
    
    int32_t window_width, window_height;
    int32_t fb_width, fb_height;
    bool    has_focus;
    bool    quit_requested;
} g_platform = {0};

/* Scancode mapping */
static key_code sdl_to_key(SDL_Scancode sc) {
    if (sc >= SDL_SCANCODE_A && sc <= SDL_SCANCODE_Z) {
        return KEY_A + (sc - SDL_SCANCODE_A);
    }
    if (sc >= SDL_SCANCODE_1 && sc <= SDL_SCANCODE_9) {
        return KEY_1 + (sc - SDL_SCANCODE_1);
    }
    if (sc == SDL_SCANCODE_0) return KEY_0;
    
    switch (sc) {
        case SDL_SCANCODE_SPACE:  return KEY_SPACE;
        case SDL_SCANCODE_RETURN: return KEY_ENTER;
        case SDL_SCANCODE_ESCAPE: return KEY_ESCAPE;
        case SDL_SCANCODE_LEFT:   return KEY_LEFT;
        case SDL_SCANCODE_RIGHT:  return KEY_RIGHT;
        case SDL_SCANCODE_UP:     return KEY_UP;
        case SDL_SCANCODE_DOWN:   return KEY_DOWN;
        case SDL_SCANCODE_LSHIFT: return KEY_LEFT_SHIFT;
        case SDL_SCANCODE_RSHIFT: return KEY_RIGHT_SHIFT;
        case SDL_SCANCODE_LCTRL:  return KEY_LEFT_CTRL;
        case SDL_SCANCODE_RCTRL:  return KEY_RIGHT_CTRL;
        default: return KEY_UNKNOWN;
    }
}

platform_config platform_default_config(void) {
    return (platform_config){
        .window_title = "Physics Demo",
        .window_width = 1280,
        .window_height = 720,
        .fullscreen = false,
        .vsync = true,
        .resizable = true
    };
}

bool platform_init(const platform_config* config) {
    if (!SDL_Init(SDL_INIT_VIDEO)) {
        SDL_Log("SDL_Init failed: %s", SDL_GetError());
        return false;
    }
    
    /* OpenGL attributes */
#ifdef __EMSCRIPTEN__
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, 
                        SDL_GL_CONTEXT_PROFILE_ES);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
#else
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, 
                        SDL_GL_CONTEXT_PROFILE_CORE);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
#endif
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
    
    /* Create window */
    SDL_WindowFlags flags = SDL_WINDOW_OPENGL;
    if (config->resizable) flags |= SDL_WINDOW_RESIZABLE;
    if (config->fullscreen) flags |= SDL_WINDOW_FULLSCREEN;
    
    g_platform.window = SDL_CreateWindow(
        config->window_title,
        config->window_width,
        config->window_height,
        flags
    );
    
    if (!g_platform.window) {
        SDL_Log("Window creation failed: %s", SDL_GetError());
        SDL_Quit();
        return false;
    }
    
    /* Create GL context */
    g_platform.gl_context = SDL_GL_CreateContext(g_platform.window);
    if (!g_platform.gl_context) {
        SDL_Log("GL context creation failed: %s", SDL_GetError());
        SDL_DestroyWindow(g_platform.window);
        SDL_Quit();
        return false;
    }
    
    SDL_GL_SetSwapInterval(config->vsync ? 1 : 0);
    
    /* Get sizes */
    SDL_GetWindowSize(g_platform.window, 
                      &g_platform.window_width, 
                      &g_platform.window_height);
    SDL_GetWindowSizeInPixels(g_platform.window,
                              &g_platform.fb_width,
                              &g_platform.fb_height);
    
    /* Initialize timing */
    g_platform.perf_frequency = SDL_GetPerformanceFrequency();
    g_platform.last_frame_time = SDL_GetPerformanceCounter();
    g_platform.delta_time = 1.0f / 60.0f;
    g_platform.has_focus = true;
    
    SDL_Log("Platform initialized: %dx%d", 
            g_platform.window_width, g_platform.window_height);
    
    return true;
}

void platform_shutdown(void) {
    if (g_platform.gl_context) {
        SDL_GL_DestroyContext(g_platform.gl_context);
    }
    if (g_platform.window) {
        SDL_DestroyWindow(g_platform.window);
    }
    SDL_Quit();
    memset(&g_platform, 0, sizeof(g_platform));
}

bool platform_pump_events(void) {
    /* Update timing */
    uint64_t now = SDL_GetPerformanceCounter();
    g_platform.delta_time = (float)(now - g_platform.last_frame_time) 
                           / (float)g_platform.perf_frequency;
    g_platform.last_frame_time = now;
    g_platform.total_time += g_platform.delta_time;
    
    if (g_platform.delta_time > 0.25f) {
        g_platform.delta_time = 0.25f;
    }
    
    /* Store previous input */
    memcpy(g_platform.keys_previous, g_platform.keys_current, KEY_COUNT);
    memcpy(g_platform.mouse_previous, g_platform.mouse_current, MOUSE_BUTTON_COUNT);
    g_platform.mouse_dx = g_platform.mouse_dy = 0.0f;
    g_platform.mouse_wheel = 0.0f;
    
    /* Process events */
    SDL_Event event;
    while (SDL_PollEvent(&event)) {
        switch (event.type) {
            case SDL_EVENT_QUIT:
                g_platform.quit_requested = true;
                break;
                
            case SDL_EVENT_WINDOW_RESIZED:
                SDL_GetWindowSize(g_platform.window,
                                  &g_platform.window_width,
                                  &g_platform.window_height);
                SDL_GetWindowSizeInPixels(g_platform.window,
                                          &g_platform.fb_width,
                                          &g_platform.fb_height);
                break;
                
            case SDL_EVENT_KEY_DOWN:
                if (!event.key.repeat) {
                    key_code k = sdl_to_key(event.key.scancode);
                    if (k != KEY_UNKNOWN) g_platform.keys_current[k] = 1;
                }
                break;
                
            case SDL_EVENT_KEY_UP: {
                key_code k = sdl_to_key(event.key.scancode);
                if (k != KEY_UNKNOWN) g_platform.keys_current[k] = 0;
                break;
            }
            
            case SDL_EVENT_MOUSE_BUTTON_DOWN:
                if (event.button.button <= MOUSE_BUTTON_COUNT) {
                    g_platform.mouse_current[event.button.button - 1] = 1;
                }
                break;
                
            case SDL_EVENT_MOUSE_BUTTON_UP:
                if (event.button.button <= MOUSE_BUTTON_COUNT) {
                    g_platform.mouse_current[event.button.button - 1] = 0;
                }
                break;
                
            case SDL_EVENT_MOUSE_MOTION:
                g_platform.mouse_x = event.motion.x;
                g_platform.mouse_y = event.motion.y;
                g_platform.mouse_dx += event.motion.xrel;
                g_platform.mouse_dy += event.motion.yrel;
                break;
                
            case SDL_EVENT_MOUSE_WHEEL:
                g_platform.mouse_wheel += event.wheel.y;
                break;
        }
    }
    
    return !g_platform.quit_requested;
}

void platform_swap_buffers(void) {
    SDL_GL_SwapWindow(g_platform.window);
}

double platform_get_time(void) { return g_platform.total_time; }
float platform_get_delta_time(void) { return g_platform.delta_time; }

void platform_get_window_size(int32_t* w, int32_t* h) {
    if (w) *w = g_platform.window_width;
    if (h) *h = g_platform.window_height;
}

void platform_get_framebuffer_size(int32_t* w, int32_t* h) {
    if (w) *w = g_platform.fb_width;
    if (h) *h = g_platform.fb_height;
}

bool platform_has_focus(void) { return g_platform.has_focus; }

/* Input functions */
bool input_key_down(key_code k) { 
    return k < KEY_COUNT && g_platform.keys_current[k]; 
}
bool input_key_pressed(key_code k) {
    return k < KEY_COUNT && g_platform.keys_current[k] && 
           !g_platform.keys_previous[k];
}
bool input_key_released(key_code k) {
    return k < KEY_COUNT && !g_platform.keys_current[k] && 
           g_platform.keys_previous[k];
}

bool input_mouse_down(mouse_button b) {
    return b < MOUSE_BUTTON_COUNT && g_platform.mouse_current[b];
}
bool input_mouse_pressed(mouse_button b) {
    return b < MOUSE_BUTTON_COUNT && g_platform.mouse_current[b] &&
           !g_platform.mouse_previous[b];
}

void input_get_mouse_position(float* x, float* y) {
    if (x) *x = g_platform.mouse_x;
    if (y) *y = g_platform.mouse_y;
}
void input_get_mouse_delta(float* dx, float* dy) {
    if (dx) *dx = g_platform.mouse_dx;
    if (dy) *dy = g_platform.mouse_dy;
}
float input_get_mouse_wheel(void) { return g_platform.mouse_wheel; }

void input_set_mouse_captured(bool captured) {
    SDL_SetWindowRelativeMouseMode(g_platform.window, captured);
}

/* File I/O */
void* platform_read_file(const char* path, size_t* out_size) {
    SDL_IOStream* io = SDL_IOFromFile(path, "rb");
    if (!io) return NULL;
    
    Sint64 size = SDL_GetIOSize(io);
    if (size < 0) { SDL_CloseIO(io); return NULL; }
    
    void* data = malloc((size_t)size + 1);
    if (!data) { SDL_CloseIO(io); return NULL; }
    
    SDL_ReadIO(io, data, (size_t)size);
    SDL_CloseIO(io);
    
    ((char*)data)[size] = '\0';
    if (out_size) *out_size = (size_t)size;
    return data;
}

bool platform_write_file(const char* path, const void* data, size_t size) {
    SDL_IOStream* io = SDL_IOFromFile(path, "wb");
    if (!io) return false;
    size_t written = SDL_WriteIO(io, data, size);
    SDL_CloseIO(io);
    return written == size;
}

const char* platform_get_base_path(void) {
    static const char* base = NULL;
    if (!base) base = SDL_GetBasePath();
    return base ? base : "./";
}
\end{lstlisting}

% ============================================================================
% CHAPTER 5: GAME INTEGRATION
% ============================================================================
\chapter{Game Integration Example}

\section{Main Entry Point}

\begin{lstlisting}[caption={game/src/main.c - Application Entry Point}]
#include "engine/platform.h"
#include "engine/renderer.h"
#include "physics/physics.h"
#include "game.h"

#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#endif

static game_state_t* g_game = NULL;

void main_loop(void) {
    if (!platform_pump_events()) {
#ifdef __EMSCRIPTEN__
        emscripten_cancel_main_loop();
#endif
        return;
    }
    
    game_update(g_game);
    game_render(g_game);
    
    platform_swap_buffers();
}

int main(int argc, char* argv[]) {
    (void)argc; (void)argv;
    
    /* Initialize platform */
    platform_config config = platform_default_config();
    config.window_title = "Physics Demo";
    
    if (!platform_init(&config)) {
        return 1;
    }
    
    /* Initialize renderer */
    if (!renderer_init()) {
        platform_shutdown();
        return 1;
    }
    
    /* Create game state */
    g_game = game_create();
    if (!g_game) {
        renderer_shutdown();
        platform_shutdown();
        return 1;
    }
    
    /* Main loop */
#ifdef __EMSCRIPTEN__
    emscripten_set_main_loop(main_loop, 0, 1);
#else
    while (platform_pump_events()) {
        game_update(g_game);
        game_render(g_game);
        platform_swap_buffers();
    }
#endif
    
    /* Cleanup */
    game_destroy(g_game);
    renderer_shutdown();
    platform_shutdown();
    
    return 0;
}
\end{lstlisting}

\section{Game State Management}

\begin{lstlisting}[caption={game/src/game.c - Game State and Physics Integration}]
#include "game.h"
#include "engine/platform.h"
#include "engine/renderer.h"
#include "physics/physics.h"
#include <stdlib.h>
#include <math.h>

#define MAX_ENTITIES 256
#define FIXED_TIMESTEP (1.0f / 60.0f)

typedef struct entity {
    ph_body_id body;
    ph_shape_id shape;
    mesh_id mesh;
    uint32_t color;
    bool active;
} entity_t;

struct game_state {
    ph_world* physics_world;
    entity_t  entities[MAX_ENTITIES];
    uint32_t  entity_count;
    
    shader_id basic_shader;
    mesh_id   cube_mesh;
    mesh_id   sphere_mesh;
    mesh_id   ground_mesh;
    
    /* Camera */
    ph_vec3 camera_pos;
    float   camera_pitch;
    float   camera_yaw;
    
    /* Fixed timestep accumulator */
    float time_accumulator;
};

/* ================================================================
 * PHYSICS CALLBACKS
 * ================================================================ */

static void on_contact_begin(void* user, const ph_contact_data* data) {
    game_state_t* game = (game_state_t*)user;
    /* Handle collision start - play sound, spawn particles, etc. */
    (void)game;
    (void)data;
}

/* ================================================================
 * ENTITY MANAGEMENT
 * ================================================================ */

static uint32_t create_entity(game_state_t* game, ph_body_type type,
                              ph_vec3 position, ph_shape_type shape_type,
                              float size, uint32_t color) {
    if (game->entity_count >= MAX_ENTITIES) return UINT32_MAX;
    
    uint32_t idx = game->entity_count++;
    entity_t* e = &game->entities[idx];
    
    /* Create physics body */
    ph_body_desc body_desc = ph_default_body_desc();
    body_desc.type = type;
    body_desc.initial_pose.position = position;
    body_desc.mass = (type == PH_BODY_DYNAMIC) ? 1.0f : 0.0f;
    body_desc.user_data = idx;
    
    e->body = ph_body_create(game->physics_world, &body_desc);
    
    /* Create physics shape */
    ph_shape_desc shape_desc = ph_default_shape_desc(shape_type);
    if (shape_type == PH_SHAPE_SPHERE) {
        shape_desc.geometry.sphere.radius = size;
        e->mesh = game->sphere_mesh;
    } else {
        shape_desc.geometry.box.half_extents = (ph_vec3){ size, size, size };
        e->mesh = game->cube_mesh;
    }
    
    e->shape = ph_shape_create(game->physics_world, &shape_desc);
    ph_body_attach_shape(game->physics_world, e->body, e->shape);
    
    e->color = color;
    e->active = true;
    
    return idx;
}

/* ================================================================
 * GAME LIFECYCLE
 * ================================================================ */

game_state_t* game_create(void) {
    game_state_t* game = calloc(1, sizeof(game_state_t));
    if (!game) return NULL;
    
    /* Create physics world */
    ph_world_desc world_desc = ph_default_world_desc();
    ph_host_config host = ph_default_host_config();
    
    game->physics_world = ph_world_create(&world_desc, &host);
    if (!game->physics_world) {
        free(game);
        return NULL;
    }
    
    /* Set up contact listener */
    ph_contact_listener listener = {
        .user_context = game,
        .on_begin = on_contact_begin,
        .on_persist = NULL,
        .on_end = NULL
    };
    ph_world_set_contact_listener(game->physics_world, &listener);
    
    /* Load shader */
    game->basic_shader = shader_load("assets/shaders/basic.vert",
                                     "assets/shaders/basic.frag");
    
    /* Create primitive meshes */
    game->cube_mesh = mesh_create_cube(1.0f);
    game->sphere_mesh = mesh_create_sphere(1.0f, 16, 16);
    game->ground_mesh = mesh_create_plane(50.0f, 50.0f, 1);
    
    /* Initialize camera */
    game->camera_pos = (ph_vec3){ 0.0f, 5.0f, 15.0f };
    game->camera_pitch = -0.3f;
    game->camera_yaw = 0.0f;
    
    /* Create ground */
    create_entity(game, PH_BODY_STATIC, 
                  (ph_vec3){ 0, -1, 0 },
                  PH_SHAPE_BOX, 25.0f, 0x808080FF);
    
    /* Create some dynamic objects */
    for (int i = 0; i < 20; i++) {
        float x = ((float)(i % 5) - 2.0f) * 2.0f;
        float y = 5.0f + (float)(i / 5) * 2.0f;
        float z = ((float)rand() / RAND_MAX - 0.5f) * 2.0f;
        
        uint32_t color = 0xFF0000FF + (i * 0x102030);
        
        create_entity(game, PH_BODY_DYNAMIC,
                      (ph_vec3){ x, y, z },
                      (i % 2) ? PH_SHAPE_SPHERE : PH_SHAPE_BOX,
                      0.5f, color);
    }
    
    return game;
}

void game_destroy(game_state_t* game) {
    if (!game) return;
    
    shader_destroy(game->basic_shader);
    mesh_destroy(game->cube_mesh);
    mesh_destroy(game->sphere_mesh);
    mesh_destroy(game->ground_mesh);
    ph_world_destroy(game->physics_world);
    
    free(game);
}

/* ================================================================
 * GAME UPDATE
 * ================================================================ */

void game_update(game_state_t* game) {
    float dt = platform_get_delta_time();
    
    /* Camera controls */
    float move_speed = 10.0f * dt;
    float look_speed = 2.0f * dt;
    
    /* Mouse look */
    if (input_mouse_down(MOUSE_RIGHT)) {
        float dx, dy;
        input_get_mouse_delta(&dx, &dy);
        game->camera_yaw -= dx * 0.003f;
        game->camera_pitch -= dy * 0.003f;
        
        /* Clamp pitch */
        if (game->camera_pitch > 1.5f) game->camera_pitch = 1.5f;
        if (game->camera_pitch < -1.5f) game->camera_pitch = -1.5f;
    }
    
    /* Calculate camera direction */
    float cy = cosf(game->camera_yaw);
    float sy = sinf(game->camera_yaw);
    float cp = cosf(game->camera_pitch);
    float sp = sinf(game->camera_pitch);
    
    ph_vec3 forward = { sy * cp, sp, -cy * cp };
    ph_vec3 right = { cy, 0, sy };
    
    /* WASD movement */
    if (input_key_down(KEY_W)) {
        game->camera_pos.x += forward.x * move_speed;
        game->camera_pos.y += forward.y * move_speed;
        game->camera_pos.z += forward.z * move_speed;
    }
    if (input_key_down(KEY_S)) {
        game->camera_pos.x -= forward.x * move_speed;
        game->camera_pos.y -= forward.y * move_speed;
        game->camera_pos.z -= forward.z * move_speed;
    }
    if (input_key_down(KEY_A)) {
        game->camera_pos.x -= right.x * move_speed;
        game->camera_pos.z -= right.z * move_speed;
    }
    if (input_key_down(KEY_D)) {
        game->camera_pos.x += right.x * move_speed;
        game->camera_pos.z += right.z * move_speed;
    }
    
    /* Spawn objects with SPACE */
    if (input_key_pressed(KEY_SPACE)) {
        ph_vec3 spawn_pos = game->camera_pos;
        spawn_pos.x += forward.x * 3.0f;
        spawn_pos.y += forward.y * 3.0f;
        spawn_pos.z += forward.z * 3.0f;
        
        uint32_t idx = create_entity(game, PH_BODY_DYNAMIC, spawn_pos,
                                     PH_SHAPE_SPHERE, 0.5f, 0x00FF00FF);
        
        if (idx != UINT32_MAX) {
            /* Apply initial velocity in camera direction */
            ph_vec3 velocity = {
                forward.x * 20.0f,
                forward.y * 20.0f,
                forward.z * 20.0f
            };
            ph_body_set_linear_velocity(game->physics_world,
                                        game->entities[idx].body,
                                        velocity);
        }
    }
    
    /* Fixed timestep physics */
    game->time_accumulator += dt;
    
    while (game->time_accumulator >= FIXED_TIMESTEP) {
        ph_world_step(game->physics_world, FIXED_TIMESTEP, 1);
        game->time_accumulator -= FIXED_TIMESTEP;
    }
}

/* ================================================================
 * GAME RENDER
 * ================================================================ */

void game_render(game_state_t* game) {
    int32_t fb_width, fb_height;
    platform_get_framebuffer_size(&fb_width, &fb_height);
    
    /* Set up render state */
    render_state state = {0};
    
    /* View matrix */
    ph_vec3 target = {
        game->camera_pos.x + sinf(game->camera_yaw) * cosf(game->camera_pitch),
        game->camera_pos.y + sinf(game->camera_pitch),
        game->camera_pos.z - cosf(game->camera_yaw) * cosf(game->camera_pitch)
    };
    state.view_matrix = ph_mat44_look_at(game->camera_pos, target, PH_VEC3_UP);
    
    /* Projection matrix */
    float aspect = (float)fb_width / (float)fb_height;
    state.projection_matrix = ph_mat44_perspective(60.0f * PH_DEG_TO_RAD,
                                                   aspect, 0.1f, 1000.0f);
    
    /* Lighting */
    state.camera_position = game->camera_pos;
    state.light_direction = (ph_vec3){ 0.5f, -1.0f, 0.3f };
    state.light_color = (ph_vec3){ 1.0f, 0.98f, 0.95f };
    state.ambient_color = (ph_vec3){ 0.2f, 0.25f, 0.3f };
    
    /* Begin frame */
    renderer_begin_frame(&state);
    renderer_set_viewport(0, 0, fb_width, fb_height);
    renderer_set_clear_color(0.1f, 0.12f, 0.15f, 1.0f);
    renderer_clear(true, true, false);
    
    /* Render entities */
    shader_bind(game->basic_shader);
    
    for (uint32_t i = 0; i < game->entity_count; i++) {
        entity_t* e = &game->entities[i];
        if (!e->active) continue;
        
        ph_transform transform = ph_body_get_transform(game->physics_world,
                                                       e->body);
        
        /* Convert color to floats */
        float r = ((e->color >> 24) & 0xFF) / 255.0f;
        float g = ((e->color >> 16) & 0xFF) / 255.0f;
        float b = ((e->color >>  8) & 0xFF) / 255.0f;
        float a = ((e->color >>  0) & 0xFF) / 255.0f;
        
        shader_set_vec4(game->basic_shader, "u_base_color", r, g, b, a);
        
        renderer_draw_mesh(e->mesh, game->basic_shader, &transform, NULL);
    }
    
    shader_unbind();
    renderer_end_frame();
}
\end{lstlisting}

% ============================================================================
% CHAPTER 6: WEBASSEMBLY DEPLOYMENT
% ============================================================================
\chapter{WebAssembly Deployment}

\section{Emscripten Build Script}

\begin{lstlisting}[style=bashstyle,caption={scripts/build\_web.sh}]
#!/bin/bash
set -e

BUILD_DIR="build-web"
OUTPUT_DIR="dist/web"

# Ensure Emscripten is available
if ! command -v emcc &> /dev/null; then
    echo "Emscripten not found. Please install and source emsdk_env.sh"
    exit 1
fi

# Create build directory
mkdir -p "$BUILD_DIR"
cd "$BUILD_DIR"

# Configure with Emscripten
emcmake cmake .. \
    -DCMAKE_BUILD_TYPE=Release \
    -DBUILD_SHARED_LIBS=OFF

# Build
cmake --build . --parallel

# Copy outputs
cd ..
mkdir -p "$OUTPUT_DIR"
cp "$BUILD_DIR/game/physics_game.html" "$OUTPUT_DIR/index.html"
cp "$BUILD_DIR/game/physics_game.js" "$OUTPUT_DIR/"
cp "$BUILD_DIR/game/physics_game.wasm" "$OUTPUT_DIR/"
cp "$BUILD_DIR/game/physics_game.data" "$OUTPUT_DIR/" 2>/dev/null || true

echo "Build complete: $OUTPUT_DIR"
\end{lstlisting}

\section{HTML Shell Template}

\begin{lstlisting}[caption={game/web/shell.html}]
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: system-ui, sans-serif;
        }
        #canvas {
            max-width: 100%;
            max-height: 100vh;
        }
        #loading {
            position: absolute;
            color: white;
            font-size: 1.5rem;
        }
    </style>
</head>
<body>
    <div id="loading">Loading...</div>
    <canvas id="canvas" oncontextmenu="event.preventDefault()"></canvas>
    
    <script>
        var Module = {
            canvas: document.getElementById('canvas'),
            onRuntimeInitialized: function() {
                document.getElementById('loading').style.display = 'none';
            }
        };
    </script>
    {{{ SCRIPT }}}
</body>
</html>
\end{lstlisting}

% ============================================================================
% CHAPTER 7: BUILD COMMANDS
% ============================================================================
\chapter{Build Commands Reference}

\section{Native Desktop Builds}

\begin{lstlisting}[style=bashstyle,caption={Native Build Commands}]
# Linux/macOS Debug
cmake -B build -DCMAKE_BUILD_TYPE=Debug
cmake --build build

# Linux/macOS Release
cmake -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build

# Windows with Visual Studio
cmake -B build -G "Visual Studio 17 2022"
cmake --build build --config Release

# Run
./build/game/physics_game
\end{lstlisting}

\section{WebAssembly Build}

\begin{lstlisting}[style=bashstyle,caption={WebAssembly Build Commands}]
# Activate Emscripten
source /path/to/emsdk/emsdk_env.sh

# Configure
emcmake cmake -B build-web -DCMAKE_BUILD_TYPE=Release

# Build
cmake --build build-web

# Serve locally (Python 3)
cd build-web/game
python3 -m http.server 8080
# Open http://localhost:8080/physics_game.html
\end{lstlisting}

\section{Mobile Builds}

\begin{lstlisting}[style=bashstyle,caption={iOS Build}]
# iOS (requires Xcode)
cmake -B build-ios \
    -G Xcode \
    -DCMAKE_SYSTEM_NAME=iOS \
    -DCMAKE_OSX_ARCHITECTURES=arm64 \
    -DCMAKE_OSX_DEPLOYMENT_TARGET=14.0

cmake --build build-ios --config Release -- -sdk iphoneos
\end{lstlisting}

\begin{lstlisting}[style=bashstyle,caption={Android Build}]
# Android (requires NDK)
cmake -B build-android \
    -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \
    -DANDROID_ABI=arm64-v8a \
    -DANDROID_PLATFORM=android-24

cmake --build build-android
\end{lstlisting}

% ============================================================================
% APPENDIX
% ============================================================================
\appendix

\chapter{API Quick Reference}

\begin{table}[H]
\centering
\caption{Physics API Quick Reference}
\begin{tabularx}{\textwidth}{lX}
\toprule
\textbf{Function} & \textbf{Description} \\
\midrule
\texttt{ph\_world\_create} & Create physics world \\
\texttt{ph\_world\_destroy} & Destroy physics world \\
\texttt{ph\_world\_step} & Advance simulation \\
\texttt{ph\_body\_create} & Create rigid body \\
\texttt{ph\_body\_destroy} & Destroy rigid body \\
\texttt{ph\_body\_get\_transform} & Get body transform \\
\texttt{ph\_body\_set\_transform} & Set body transform (teleport) \\
\texttt{ph\_body\_apply\_force} & Apply force at center of mass \\
\texttt{ph\_body\_apply\_impulse} & Apply instant velocity change \\
\texttt{ph\_shape\_create} & Create collision shape \\
\texttt{ph\_body\_attach\_shape} & Attach shape to body \\
\texttt{ph\_world\_raycast} & Cast ray, get closest hit \\
\bottomrule
\end{tabularx}
\end{table}

\begin{table}[H]
\centering
\caption{Platform API Quick Reference}
\begin{tabularx}{\textwidth}{lX}
\toprule
\textbf{Function} & \textbf{Description} \\
\midrule
\texttt{platform\_init} & Initialize SDL3/OpenGL \\
\texttt{platform\_shutdown} & Clean up resources \\
\texttt{platform\_pump\_events} & Process input events \\
\texttt{platform\_swap\_buffers} & Present frame \\
\texttt{platform\_get\_delta\_time} & Get frame delta time \\
\texttt{input\_key\_down} & Check if key is held \\
\texttt{input\_key\_pressed} & Check if key was just pressed \\
\texttt{input\_mouse\_down} & Check mouse button state \\
\texttt{input\_get\_mouse\_delta} & Get mouse movement \\
\bottomrule
\end{tabularx}
\end{table}

\end{document}
