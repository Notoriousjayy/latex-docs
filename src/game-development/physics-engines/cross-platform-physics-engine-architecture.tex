\documentclass[11pt,letterpaper]{report}

% ============================================================================
% PACKAGES
% ============================================================================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tcolorbox}
\usepackage{etoolbox}
\usepackage{multicol}

% ============================================================================
% COLOR DEFINITIONS
% ============================================================================
\definecolor{codebackground}{RGB}{248,248,248}
\definecolor{codeborder}{RGB}{200,200,200}
\definecolor{codecomment}{RGB}{106,153,85}
\definecolor{codekeyword}{RGB}{86,156,214}
\definecolor{codestring}{RGB}{206,145,120}
\definecolor{codenumber}{RGB}{181,206,168}
\definecolor{codepreproc}{RGB}{155,89,182}
\definecolor{headerblue}{RGB}{0,82,147}
\definecolor{sectionblue}{RGB}{41,128,185}
\definecolor{noteyellow}{RGB}{255,243,205}
\definecolor{noteborder}{RGB}{255,193,7}
\definecolor{warningred}{RGB}{248,215,218}
\definecolor{warningborder}{RGB}{220,53,69}
\definecolor{tipgreen}{RGB}{212,237,218}
\definecolor{tipborder}{RGB}{40,167,69}

% ============================================================================
% LISTINGS CONFIGURATION
% ============================================================================
\lstdefinestyle{cstyle}{
    language=C,
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{codebackground},
    frame=single,
    rulecolor=\color{codeborder},
    keywordstyle=\color{codekeyword}\bfseries,
    commentstyle=\color{codecomment}\itshape,
    stringstyle=\color{codestring},
    numberstyle=\tiny\color{codenumber},
    numbers=left,
    numbersep=8pt,
    breaklines=true,
    breakatwhitespace=true,
    showstringspaces=false,
    tabsize=4,
    captionpos=b,
    xleftmargin=15pt,
    framexleftmargin=15pt,
    morekeywords={uint32_t,uint64_t,int32_t,int64_t,size_t,uint8_t,int8_t,
                  bool,true,false,NULL,ph_world_t,ph_body_id,ph_shape_id,
                  ph_vec3,ph_quat,ph_transform,ph_body_desc,ph_shape_desc,
                  ph_world_desc,ph_host_t,ph_alloc_fn,ph_free_fn,ph_log_fn,
                  ph_body_type,ph_shape_type,ph_raycast_hit,ph_contact_pair,
                  ph_contact_listener,alignas,alignof,static_assert},
    morecomment=[l][\color{codepreproc}]{\#},
}

\lstdefinestyle{cmakestyle}{
    language=bash,
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{codebackground},
    frame=single,
    rulecolor=\color{codeborder},
    keywordstyle=\color{codekeyword}\bfseries,
    commentstyle=\color{codecomment}\itshape,
    stringstyle=\color{codestring},
    numbers=left,
    numbersep=8pt,
    breaklines=true,
    showstringspaces=false,
    tabsize=2,
    xleftmargin=15pt,
    framexleftmargin=15pt,
    morekeywords={cmake_minimum_required,project,set,option,add_library,
                  add_executable,target_include_directories,target_compile_features,
                  target_compile_definitions,target_link_libraries,install,
                  if,endif,else,elseif,find_package,include,message,
                  STATIC,SHARED,PUBLIC,PRIVATE,INTERFACE,VERSION,LANGUAGES},
}

\lstdefinestyle{jsstyle}{
    language=Java,
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{codebackground},
    frame=single,
    rulecolor=\color{codeborder},
    keywordstyle=\color{codekeyword}\bfseries,
    commentstyle=\color{codecomment}\itshape,
    stringstyle=\color{codestring},
    numbers=left,
    numbersep=8pt,
    breaklines=true,
    showstringspaces=false,
    tabsize=2,
    xleftmargin=15pt,
    framexleftmargin=15pt,
    morekeywords={const,let,var,function,async,await,export,import,from,
                  class,extends,static,new,this,return,if,else,for,while,
                  try,catch,throw,typeof,instanceof,Float32Array,Uint32Array,
                  ArrayBuffer,WebAssembly,Module,Promise},
}

\lstdefinestyle{bashstyle}{
    language=bash,
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{codebackground},
    frame=single,
    rulecolor=\color{codeborder},
    keywordstyle=\color{codekeyword}\bfseries,
    commentstyle=\color{codecomment}\itshape,
    stringstyle=\color{codestring},
    numbers=left,
    numbersep=8pt,
    breaklines=true,
    showstringspaces=false,
    tabsize=2,
    xleftmargin=15pt,
    framexleftmargin=15pt,
}

\lstset{style=cstyle}

% ============================================================================
% TCOLORBOX ENVIRONMENTS
% ============================================================================
\tcbuselibrary{skins,breakable}

\newtcolorbox{notebox}[1][Note]{
    enhanced,
    breakable,
    colback=noteyellow,
    colframe=noteborder,
    fonttitle=\bfseries,
    title=#1,
    left=10pt,
    right=10pt,
    top=8pt,
    bottom=8pt,
}

\newtcolorbox{warningbox}[1][Warning]{
    enhanced,
    breakable,
    colback=warningred,
    colframe=warningborder,
    fonttitle=\bfseries,
    title=#1,
    left=10pt,
    right=10pt,
    top=8pt,
    bottom=8pt,
}

\newtcolorbox{tipbox}[1][Tip]{
    enhanced,
    breakable,
    colback=tipgreen,
    colframe=tipborder,
    fonttitle=\bfseries,
    title=#1,
    left=10pt,
    right=10pt,
    top=8pt,
    bottom=8pt,
}

\newtcolorbox{definitionbox}[1][Definition]{
    enhanced,
    breakable,
    colback=white,
    colframe=sectionblue,
    fonttitle=\bfseries,
    title=#1,
    left=10pt,
    right=10pt,
    top=8pt,
    bottom=8pt,
}

% ============================================================================
% HEADER/FOOTER CONFIGURATION
% ============================================================================
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{\thepage}
\fancyfoot[C]{\small Cross-Platform Physics Engine Architecture}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% ============================================================================
% TITLE FORMATTING
% ============================================================================
\titleformat{\chapter}[display]
    {\normalfont\huge\bfseries\color{headerblue}}
    {\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titleformat{\section}
    {\normalfont\Large\bfseries\color{sectionblue}}
    {\thesection}{1em}{}
\titleformat{\subsection}
    {\normalfont\large\bfseries\color{sectionblue!80}}
    {\thesubsection}{1em}{}
\titleformat{\subsubsection}
    {\normalfont\normalsize\bfseries\color{sectionblue!60}}
    {\thesubsubsection}{1em}{}

% ============================================================================
% HYPERREF CONFIGURATION
% ============================================================================
\hypersetup{
    colorlinks=true,
    linkcolor=sectionblue,
    urlcolor=sectionblue,
    citecolor=sectionblue,
    pdftitle={Cross-Platform Physics Engine Architecture},
    pdfauthor={Technical Documentation},
    pdfsubject={Game Physics, WASM, Cross-Platform Development},
    pdfkeywords={physics engine, WASM, C, game development, cross-platform},
}

% ============================================================================
% DOCUMENT INFORMATION
% ============================================================================
\title{
    \vspace{-2cm}
    {\Huge\bfseries\color{headerblue} Cross-Platform Physics Engine}\\[0.5cm]
    {\LARGE\color{sectionblue} Architecture and Implementation Guide}\\[1cm]
    {\large A Comprehensive Blueprint for Building a Reusable Physics Engine\\
    in C with WebAssembly Support}\\[2cm]
    {\normalsize Version 1.0}
}

\author{Technical Architecture Documentation}
\date{\today}

% ============================================================================
% DOCUMENT BEGIN
% ============================================================================
\begin{document}

\maketitle
\thispagestyle{empty}

\newpage
\tableofcontents

\newpage

% ============================================================================
% CHAPTER 1: INTRODUCTION AND OVERVIEW
% ============================================================================
\chapter{Introduction and Overview}

\section{Document Purpose}

This document provides a comprehensive architectural blueprint for designing and implementing a cross-platform physics engine that can be deployed across mobile applications (iOS and Android), web browsers (via WebAssembly), and gaming consoles. The engine is implemented in portable C with a stable C ABI, ensuring maximum compatibility across diverse platforms and toolchains.

The architecture described herein emphasizes clean module boundaries, minimal platform dependencies, and a disciplined API design that separates simulation concerns from game-specific logic.

\section{Target Platforms}

The physics engine targets three primary deployment environments:

\begin{table}[H]
\centering
\caption{Target Platform Matrix}
\begin{tabular}{llll}
\toprule
\textbf{Platform} & \textbf{Architecture} & \textbf{Toolchain} & \textbf{Output Format} \\
\midrule
iOS & ARM64 & Clang/LLVM & XCFramework \\
Android & ARM64-v8a, x86\_64 & NDK Clang & AAR + .so \\
Browser & WASM32 & Emscripten & .wasm + .js \\
Consoles & Vendor-specific & Vendor SDK & Static library \\
Desktop & x86\_64, ARM64 & GCC/Clang/MSVC & Static/Shared library \\
\bottomrule
\end{tabular}
\end{table}

\section{Design Goals and Non-Goals}

\subsection{Primary Design Goals}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Portability:} Single codebase compiles across all target platforms without modification
    \item \textbf{Stability:} C ABI ensures long-term binary compatibility
    \item \textbf{Reusability:} Engine-agnostic design allows integration with any game engine or framework
    \item \textbf{Predictability:} Deterministic simulation behavior with configurable precision
    \item \textbf{Performance:} Efficient memory layout and optional SIMD/threading support
    \item \textbf{Simplicity:} Minimal external dependencies and clear API contracts
\end{enumerate}

\subsection{Explicit Non-Goals}

The following components are intentionally excluded from the physics core:

\begin{itemize}[leftmargin=*]
    \item Rendering, debug UI frameworks, or editor tooling
    \item Input handling, camera systems, or animation
    \item Game entity systems, scripting engines, or ECS frameworks
    \item Asset pipelines, serialization formats, or scene management
    \item Networking or multiplayer synchronization logic
\end{itemize}

\begin{notebox}[Design Philosophy]
This separation prevents the physics engine from becoming ``your whole game.'' The core handles only what is universally applicable to physics simulation, while game-specific concerns live in adapter layers.
\end{notebox}

\section{Architectural Overview}

The engine follows a three-ring architecture that cleanly separates concerns:

\begin{definitionbox}[Three-Ring Architecture]
\begin{enumerate}
    \item \textbf{Physics Core:} The portable simulation library (this document's primary focus)
    \item \textbf{Platform Abstraction Layer (PAL):} Minimal host services interface
    \item \textbf{Integration Layer:} Per-project adapters connecting the core to game engines
\end{enumerate}
\end{definitionbox}

% ============================================================================
% CHAPTER 2: MODULE BOUNDARIES AND ARCHITECTURE
% ============================================================================
\chapter{Module Boundaries and Architecture}

\section{Physics Core Responsibilities}

The physics core is a self-contained simulation library with the following responsibilities:

\subsection{Dynamics Subsystem}

\begin{itemize}[leftmargin=*]
    \item Rigid body state management (position, orientation, velocities)
    \item Force and torque accumulation
    \item Numerical integration (semi-implicit Euler, Verlet, or similar)
    \item Constraint satisfaction (joints, contacts)
    \item Sleeping and island management
\end{itemize}

\subsection{Collision Subsystem}

\begin{itemize}[leftmargin=*]
    \item Broadphase acceleration structures (spatial hashing, BVH, sweep-and-prune)
    \item Narrowphase collision detection (GJK, SAT, specialized algorithms)
    \item Contact manifold generation
    \item Continuous collision detection (CCD) for fast-moving objects
\end{itemize}

\subsection{Query Subsystem}

\begin{itemize}[leftmargin=*]
    \item Ray casting with filtering
    \item Shape overlap tests
    \item Sweep/shape cast queries
    \item Point containment tests
\end{itemize}

\subsection{Configuration Subsystem}

\begin{itemize}[leftmargin=*]
    \item Solver iteration counts
    \item Sleeping thresholds
    \item Continuous collision toggles
    \item Determinism controls
\end{itemize}

\section{What the Core Does NOT Know}

The physics core intentionally has no knowledge of:

\begin{table}[H]
\centering
\caption{Responsibilities Outside the Physics Core}
\begin{tabularx}{\textwidth}{lX}
\toprule
\textbf{Concept} & \textbf{Reason for Exclusion} \\
\midrule
Entity IDs & Game-specific identifier systems vary widely \\
Game Objects & No universal definition; ECS vs. OOP vs. component models \\
Scenes/Prefabs & Asset and serialization concerns \\
Tags/Teams & Game semantics, not physics \\
Damage Rules & Gameplay logic \\
Animation State & Typically separate subsystem \\
Rendering & Completely orthogonal to simulation \\
\bottomrule
\end{tabularx}
\end{table}

\section{Platform Abstraction Layer (PAL)}

The PAL provides a minimal interface for host services that the core may need. This layer is kept intentionally thin.

\subsection{Required PAL Services}

\begin{lstlisting}[caption={PAL Memory Interface}]
/* Memory allocation hooks - REQUIRED */
typedef void* (*ph_alloc_fn)(void* user_context, 
                              size_t size, 
                              size_t alignment);
typedef void  (*ph_free_fn)(void* user_context, 
                             void* ptr);
\end{lstlisting}

\subsection{Optional PAL Services}

\begin{lstlisting}[caption={PAL Optional Services}]
/* Logging callback - OPTIONAL */
typedef void (*ph_log_fn)(void* user_context, 
                          int severity,
                          const char* message);

/* Assert callback - OPTIONAL */
typedef void (*ph_assert_fn)(void* user_context,
                             const char* condition,
                             const char* file,
                             int line);

/* Profiling markers - OPTIONAL */
typedef void (*ph_profile_begin_fn)(void* user_context, 
                                     const char* name);
typedef void (*ph_profile_end_fn)(void* user_context, 
                                   const char* name);
\end{lstlisting}

\begin{warningbox}[Critical Design Rule]
The physics core \textbf{never} calls platform APIs directly. All external interactions go through PAL hooks. This ensures the same code compiles under Emscripten, console SDKs, and mobile toolchains without modification.
\end{warningbox}

\section{Integration Layer Pattern}

Each project consuming the physics engine implements a thin integration layer:

\subsection{Transform Synchronization}

\begin{lstlisting}[caption={Transform Sync Adapter Example}]
/* Game engine's transform type */
typedef struct game_transform {
    vec3_t position;      /* Game engine's vec3 */
    quat_t rotation;      /* Game engine's quaternion */
    vec3_t scale;         /* Physics ignores scale */
} game_transform_t;

/* Convert game transform to physics transform */
static inline ph_transform game_to_physics(
    const game_transform_t* game
) {
    ph_transform phys;
    phys.p = (ph_vec3){ game->position.x, 
                        game->position.y, 
                        game->position.z };
    phys.q = (ph_quat){ game->rotation.x, 
                        game->rotation.y, 
                        game->rotation.z, 
                        game->rotation.w };
    return phys;
}

/* Convert physics transform to game transform */
static inline game_transform_t physics_to_game(
    const ph_transform* phys
) {
    game_transform_t game;
    game.position = (vec3_t){ phys->p.x, 
                              phys->p.y, 
                              phys->p.z };
    game.rotation = (quat_t){ phys->q.x, 
                              phys->q.y, 
                              phys->q.z, 
                              phys->q.w };
    game.scale = (vec3_t){ 1.0f, 1.0f, 1.0f };
    return game;
}
\end{lstlisting}

\subsection{Entity-Body Mapping}

\begin{lstlisting}[caption={Entity to Body Mapping}]
#include <stdint.h>

#define MAX_PHYSICS_BODIES 4096

typedef struct entity_body_map {
    /* Game entity ID -> Physics body ID */
    ph_body_id body_for_entity[MAX_PHYSICS_BODIES];
    
    /* Physics body ID -> Game entity ID (reverse lookup) */
    uint32_t entity_for_body[MAX_PHYSICS_BODIES];
    
    /* Active mapping count */
    uint32_t count;
} entity_body_map_t;

/* Register a new mapping */
void map_entity_to_body(entity_body_map_t* map,
                        uint32_t entity_id,
                        ph_body_id body_id) {
    /* Validate indices */
    if (entity_id >= MAX_PHYSICS_BODIES) return;
    
    uint32_t body_index = body_id & 0xFFFF; /* Extract index */
    if (body_index >= MAX_PHYSICS_BODIES) return;
    
    map->body_for_entity[entity_id] = body_id;
    map->entity_for_body[body_index] = entity_id;
    map->count++;
}

/* Lookup body for entity */
ph_body_id get_body_for_entity(const entity_body_map_t* map,
                                uint32_t entity_id) {
    if (entity_id >= MAX_PHYSICS_BODIES) {
        return PH_INVALID_BODY;
    }
    return map->body_for_entity[entity_id];
}

/* Lookup entity for body (useful in callbacks) */
uint32_t get_entity_for_body(const entity_body_map_t* map,
                              ph_body_id body_id) {
    uint32_t body_index = body_id & 0xFFFF;
    if (body_index >= MAX_PHYSICS_BODIES) {
        return UINT32_MAX; /* Invalid entity */
    }
    return map->entity_for_body[body_index];
}
\end{lstlisting}

\subsection{Contact Event Routing}

\begin{lstlisting}[caption={Contact Event Router}]
/* Forward declaration of game-specific handler */
void game_on_collision(uint32_t entity_a, 
                       uint32_t entity_b,
                       const ph_contact_info* info);

/* Physics contact callback implementation */
void physics_contact_callback(void* user_data,
                              const ph_contact_pair* pair) {
    entity_body_map_t* map = (entity_body_map_t*)user_data;
    
    /* Translate body IDs to entity IDs */
    uint32_t entity_a = get_entity_for_body(map, pair->body_a);
    uint32_t entity_b = get_entity_for_body(map, pair->body_b);
    
    /* Skip if either body is unmapped */
    if (entity_a == UINT32_MAX || entity_b == UINT32_MAX) {
        return;
    }
    
    /* Create game-friendly contact info */
    ph_contact_info info = {
        .point = pair->contact_point,
        .normal = pair->contact_normal,
        .penetration = pair->penetration_depth,
        .impulse = pair->applied_impulse
    };
    
    /* Route to game logic */
    game_on_collision(entity_a, entity_b, &info);
}
\end{lstlisting}

% ============================================================================
% CHAPTER 3: PUBLIC API DESIGN
% ============================================================================
\chapter{Public API Design}

\section{API Design Principles}

The public API follows these principles to ensure stability and portability:

\begin{enumerate}[leftmargin=*]
    \item \textbf{Opaque Handles:} Internal structures are never exposed; consumers interact via handles
    \item \textbf{POD Descriptors:} All input/output data uses plain-old-data structures
    \item \textbf{C ABI:} All public functions use C linkage for maximum compatibility
    \item \textbf{Explicit Ownership:} Memory ownership is always clear and documented
    \item \textbf{Error Handling:} Errors are communicated via return values, never exceptions
\end{enumerate}

\section{Core Type Definitions}

\subsection{Mathematical Types}

\begin{lstlisting}[caption={Mathematical Type Definitions}]
#pragma once

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ================================================================
 * MATHEMATICAL PRIMITIVES
 * ================================================================ */

/**
 * @brief 3D vector with single-precision floats.
 * 
 * Memory layout is guaranteed to be 12 bytes with no padding.
 */
typedef struct ph_vec3 {
    float x;
    float y;
    float z;
} ph_vec3;

/**
 * @brief Quaternion for rotations.
 * 
 * Convention: (x, y, z, w) where w is the scalar component.
 * Stored as 16 bytes with no padding.
 */
typedef struct ph_quat {
    float x;
    float y;
    float z;
    float w;
} ph_quat;

/**
 * @brief Rigid transform (position + rotation).
 * 
 * No scale component - physics operates in uniform coordinate space.
 */
typedef struct ph_transform {
    ph_vec3 position;
    ph_quat rotation;
} ph_transform;

/**
 * @brief 3x3 matrix for inertia tensors.
 * 
 * Row-major storage: m[row][col]
 */
typedef struct ph_mat33 {
    float m[3][3];
} ph_mat33;

/**
 * @brief Axis-aligned bounding box.
 */
typedef struct ph_aabb {
    ph_vec3 min;
    ph_vec3 max;
} ph_aabb;

/* ================================================================
 * MATHEMATICAL CONSTANTS
 * ================================================================ */

#define PH_PI           3.14159265358979323846f
#define PH_EPSILON      1e-6f
#define PH_DEG_TO_RAD   (PH_PI / 180.0f)
#define PH_RAD_TO_DEG   (180.0f / PH_PI)

/* ================================================================
 * IDENTITY CONSTANTS
 * ================================================================ */

static const ph_vec3 PH_VEC3_ZERO     = { 0.0f, 0.0f, 0.0f };
static const ph_vec3 PH_VEC3_ONE      = { 1.0f, 1.0f, 1.0f };
static const ph_vec3 PH_VEC3_UP       = { 0.0f, 1.0f, 0.0f };
static const ph_vec3 PH_VEC3_FORWARD  = { 0.0f, 0.0f, 1.0f };
static const ph_vec3 PH_VEC3_RIGHT    = { 1.0f, 0.0f, 0.0f };

static const ph_quat PH_QUAT_IDENTITY = { 0.0f, 0.0f, 0.0f, 1.0f };

static const ph_transform PH_TRANSFORM_IDENTITY = {
    { 0.0f, 0.0f, 0.0f },  /* position */
    { 0.0f, 0.0f, 0.0f, 1.0f }  /* rotation */
};

#ifdef __cplusplus
}
#endif
\end{lstlisting}

\subsection{Handle Types}

\begin{lstlisting}[caption={Handle Type Definitions}]
/* ================================================================
 * HANDLE TYPES
 * ================================================================
 * 
 * Handles are opaque identifiers that reference internal objects.
 * They consist of an index and a generation counter to detect
 * use-after-free errors.
 * 
 * Layout: [16-bit generation][16-bit index]
 * 
 * This allows up to 65,535 simultaneous bodies/shapes and
 * 65,535 generations before wrap-around.
 */

typedef uint32_t ph_body_id;
typedef uint32_t ph_shape_id;
typedef uint32_t ph_joint_id;

#define PH_INVALID_BODY   ((ph_body_id)0)
#define PH_INVALID_SHAPE  ((ph_shape_id)0)
#define PH_INVALID_JOINT  ((ph_joint_id)0)

/* Handle manipulation macros */
#define PH_HANDLE_INDEX(h)      ((uint16_t)((h) & 0xFFFF))
#define PH_HANDLE_GENERATION(h) ((uint16_t)(((h) >> 16) & 0xFFFF))
#define PH_MAKE_HANDLE(gen, idx) \
    ((uint32_t)(((uint32_t)(gen) << 16) | ((uint32_t)(idx) & 0xFFFF)))

/**
 * @brief Check if a handle is valid (non-zero).
 * 
 * Note: This only checks the handle value itself, not whether
 * the referenced object still exists in the world.
 */
static inline bool ph_handle_valid(uint32_t handle) {
    return handle != 0;
}
\end{lstlisting}

\section{Host Configuration}

\begin{lstlisting}[caption={Host Configuration Structure}]
/* ================================================================
 * HOST SERVICES CONFIGURATION
 * ================================================================ */

/**
 * @brief Memory allocation function signature.
 * 
 * @param user_context   User-provided context pointer
 * @param size           Allocation size in bytes
 * @param alignment      Required alignment (power of 2)
 * @return               Pointer to allocated memory, or NULL on failure
 */
typedef void* (*ph_alloc_fn)(void* user_context, 
                              size_t size, 
                              size_t alignment);

/**
 * @brief Memory deallocation function signature.
 * 
 * @param user_context   User-provided context pointer
 * @param ptr            Pointer to free (may be NULL)
 */
typedef void (*ph_free_fn)(void* user_context, void* ptr);

/**
 * @brief Logging severity levels.
 */
typedef enum ph_log_severity {
    PH_LOG_DEBUG   = 0,
    PH_LOG_INFO    = 1,
    PH_LOG_WARNING = 2,
    PH_LOG_ERROR   = 3
} ph_log_severity;

/**
 * @brief Logging function signature.
 * 
 * @param user_context   User-provided context pointer
 * @param severity       Message severity level
 * @param message        Null-terminated message string
 */
typedef void (*ph_log_fn)(void* user_context, 
                          ph_log_severity severity,
                          const char* message);

/**
 * @brief Host services configuration.
 * 
 * Passed to ph_world_create() to configure host integration.
 * The user_context pointer is passed to all callbacks.
 */
typedef struct ph_host_config {
    void*       user_context;   /**< Passed to all callbacks */
    ph_alloc_fn alloc;          /**< Required: memory allocator */
    ph_free_fn  free;           /**< Required: memory deallocator */
    ph_log_fn   log;            /**< Optional: logging (may be NULL) */
} ph_host_config;

/**
 * @brief Default host configuration using standard library.
 * 
 * Returns a host config that uses malloc/free for memory
 * and prints logs to stderr.
 */
ph_host_config ph_default_host_config(void);
\end{lstlisting}

\section{Body and Shape Descriptors}

\begin{lstlisting}[caption={Body and Shape Descriptor Types}]
/* ================================================================
 * BODY CONFIGURATION
 * ================================================================ */

/**
 * @brief Body motion type.
 */
typedef enum ph_body_type {
    /** Static bodies never move, have infinite mass */
    PH_BODY_STATIC    = 0,
    
    /** Dynamic bodies respond to forces and collisions */
    PH_BODY_DYNAMIC   = 1,
    
    /** Kinematic bodies move via direct control, not forces */
    PH_BODY_KINEMATIC = 2
} ph_body_type;

/**
 * @brief Body creation descriptor.
 * 
 * All fields have sensible defaults when zero-initialized.
 */
typedef struct ph_body_desc {
    ph_body_type type;              /**< Motion type (default: STATIC) */
    ph_transform initial_pose;      /**< Initial world pose */
    ph_vec3      linear_velocity;   /**< Initial linear velocity */
    ph_vec3      angular_velocity;  /**< Initial angular velocity */
    float        mass;              /**< Mass in kg (dynamic only) */
    ph_mat33     inertia_tensor;    /**< Local inertia (0 = auto) */
    float        linear_damping;    /**< Linear drag [0..1] */
    float        angular_damping;   /**< Angular drag [0..1] */
    float        gravity_scale;     /**< Gravity multiplier (default: 1) */
    bool         allow_sleep;       /**< Enable sleeping (default: true) */
    bool         start_awake;       /**< Start in awake state */
    bool         continuous;        /**< Enable CCD */
    uint32_t     user_data;         /**< User-defined identifier */
} ph_body_desc;

/**
 * @brief Initialize a body descriptor with default values.
 */
static inline ph_body_desc ph_body_desc_default(void) {
    ph_body_desc desc = {0};
    desc.type = PH_BODY_DYNAMIC;
    desc.initial_pose = PH_TRANSFORM_IDENTITY;
    desc.mass = 1.0f;
    desc.linear_damping = 0.01f;
    desc.angular_damping = 0.01f;
    desc.gravity_scale = 1.0f;
    desc.allow_sleep = true;
    desc.start_awake = true;
    return desc;
}

/* ================================================================
 * SHAPE CONFIGURATION
 * ================================================================ */

/**
 * @brief Collision shape type.
 */
typedef enum ph_shape_type {
    PH_SHAPE_SPHERE   = 0,  /**< Sphere shape */
    PH_SHAPE_BOX      = 1,  /**< Axis-aligned box */
    PH_SHAPE_CAPSULE  = 2,  /**< Capsule (cylinder + hemispheres) */
    PH_SHAPE_CYLINDER = 3,  /**< Cylinder */
    PH_SHAPE_CONVEX   = 4,  /**< Convex hull */
    PH_SHAPE_MESH     = 5   /**< Triangle mesh (static only) */
} ph_shape_type;

/**
 * @brief Sphere shape parameters.
 */
typedef struct ph_sphere_params {
    float radius;
} ph_sphere_params;

/**
 * @brief Box shape parameters.
 */
typedef struct ph_box_params {
    ph_vec3 half_extents;  /**< Half-size on each axis */
} ph_box_params;

/**
 * @brief Capsule shape parameters.
 */
typedef struct ph_capsule_params {
    float radius;  /**< Radius of the capsule */
    float height;  /**< Height of the cylindrical section */
} ph_capsule_params;

/**
 * @brief Convex hull parameters.
 * 
 * The physics engine will compute the convex hull from the
 * provided vertices. Ownership of vertex data remains with
 * the caller during creation; the engine copies what it needs.
 */
typedef struct ph_convex_params {
    const ph_vec3* vertices;     /**< Vertex array */
    uint32_t       vertex_count; /**< Number of vertices */
} ph_convex_params;

/**
 * @brief Shape creation descriptor.
 */
typedef struct ph_shape_desc {
    ph_shape_type type;
    
    union {
        ph_sphere_params  sphere;
        ph_box_params     box;
        ph_capsule_params capsule;
        ph_convex_params  convex;
    } params;
    
    ph_transform  local_pose;       /**< Offset from body origin */
    float         density;          /**< Mass density (kg/m^3) */
    float         friction;         /**< Coulomb friction [0..1+] */
    float         restitution;      /**< Bounciness [0..1] */
    uint32_t      collision_group;  /**< Collision filter group */
    uint32_t      collision_mask;   /**< Collision filter mask */
    bool          is_sensor;        /**< Sensor (no collision response) */
} ph_shape_desc;

/**
 * @brief Initialize a shape descriptor with default values.
 */
static inline ph_shape_desc ph_shape_desc_default(void) {
    ph_shape_desc desc = {0};
    desc.type = PH_SHAPE_SPHERE;
    desc.params.sphere.radius = 0.5f;
    desc.local_pose = PH_TRANSFORM_IDENTITY;
    desc.density = 1000.0f;  /* ~water density */
    desc.friction = 0.5f;
    desc.restitution = 0.3f;
    desc.collision_group = 0x0001;
    desc.collision_mask = 0xFFFF;
    return desc;
}
\end{lstlisting}

\section{World Configuration and Creation}

\begin{lstlisting}[caption={World Configuration}]
/* ================================================================
 * WORLD CONFIGURATION
 * ================================================================ */

/**
 * @brief World simulation parameters.
 */
typedef struct ph_world_desc {
    ph_vec3  gravity;              /**< Gravity vector (m/s^2) */
    int32_t  solver_iterations;    /**< Velocity solver iterations */
    int32_t  position_iterations;  /**< Position solver iterations */
    float    slop;                 /**< Penetration slop tolerance */
    float    baumgarte;            /**< Position correction factor */
    float    sleep_threshold;      /**< Linear velocity sleep limit */
    float    sleep_time;           /**< Time before sleep activation */
    bool     enable_sleeping;      /**< Global sleep enable */
    bool     enable_ccd;           /**< Global CCD enable */
    uint32_t max_bodies;           /**< Pre-allocate body capacity */
    uint32_t max_shapes;           /**< Pre-allocate shape capacity */
} ph_world_desc;

/**
 * @brief Initialize a world descriptor with default values.
 */
static inline ph_world_desc ph_world_desc_default(void) {
    ph_world_desc desc = {0};
    desc.gravity = (ph_vec3){ 0.0f, -9.81f, 0.0f };
    desc.solver_iterations = 8;
    desc.position_iterations = 3;
    desc.slop = 0.005f;
    desc.baumgarte = 0.2f;
    desc.sleep_threshold = 0.05f;
    desc.sleep_time = 0.5f;
    desc.enable_sleeping = true;
    desc.enable_ccd = false;
    desc.max_bodies = 1024;
    desc.max_shapes = 2048;
    return desc;
}

/* ================================================================
 * WORLD OPAQUE TYPE
 * ================================================================ */

/**
 * @brief Opaque physics world handle.
 * 
 * All simulation state is encapsulated within this structure.
 * Multiple worlds can exist simultaneously and operate independently.
 */
typedef struct ph_world ph_world;
\end{lstlisting}

\section{Core API Functions}

\begin{lstlisting}[caption={World Lifecycle Functions}]
/* ================================================================
 * WORLD LIFECYCLE
 * ================================================================ */

/**
 * @brief Create a new physics world.
 * 
 * @param desc   World configuration parameters
 * @param host   Host services configuration
 * @return       New world instance, or NULL on failure
 */
ph_world* ph_world_create(const ph_world_desc* desc,
                          const ph_host_config* host);

/**
 * @brief Destroy a physics world and free all resources.
 * 
 * All bodies, shapes, and joints are invalidated.
 * 
 * @param world  World to destroy (may be NULL)
 */
void ph_world_destroy(ph_world* world);

/**
 * @brief Step the simulation forward.
 * 
 * @param world     World to simulate
 * @param dt        Fixed timestep in seconds (e.g., 1/60)
 * @param substeps  Number of substeps (default: 1)
 * 
 * @note For deterministic results, always use the same dt value.
 *       Substeps improve stability for fast objects.
 */
void ph_world_step(ph_world* world, float dt, int32_t substeps);
\end{lstlisting}

\begin{lstlisting}[caption={Body Management Functions}]
/* ================================================================
 * BODY MANAGEMENT
 * ================================================================ */

/**
 * @brief Create a new rigid body.
 * 
 * @param world  Target world
 * @param desc   Body configuration
 * @return       Body handle, or PH_INVALID_BODY on failure
 */
ph_body_id ph_body_create(ph_world* world, const ph_body_desc* desc);

/**
 * @brief Destroy a rigid body.
 * 
 * All attached shapes are also destroyed.
 * 
 * @param world  World containing the body
 * @param body   Body to destroy
 */
void ph_body_destroy(ph_world* world, ph_body_id body);

/**
 * @brief Attach a shape to a body.
 * 
 * @param world       World containing both objects
 * @param body        Target body
 * @param shape       Shape to attach
 * @param local_pose  Shape offset relative to body origin
 */
void ph_body_attach_shape(ph_world* world,
                          ph_body_id body,
                          ph_shape_id shape,
                          const ph_transform* local_pose);

/**
 * @brief Get body world-space transform.
 */
ph_transform ph_body_get_pose(const ph_world* world, ph_body_id body);

/**
 * @brief Set body world-space transform.
 * 
 * @note Teleports the body; does not update velocity.
 */
void ph_body_set_pose(ph_world* world, 
                      ph_body_id body, 
                      const ph_transform* pose);

/**
 * @brief Get body linear velocity.
 */
ph_vec3 ph_body_get_linear_velocity(const ph_world* world, 
                                     ph_body_id body);

/**
 * @brief Set body linear velocity.
 */
void ph_body_set_linear_velocity(ph_world* world, 
                                  ph_body_id body, 
                                  ph_vec3 velocity);

/**
 * @brief Get body angular velocity.
 */
ph_vec3 ph_body_get_angular_velocity(const ph_world* world, 
                                      ph_body_id body);

/**
 * @brief Set body angular velocity.
 */
void ph_body_set_angular_velocity(ph_world* world, 
                                   ph_body_id body, 
                                   ph_vec3 velocity);

/**
 * @brief Apply a force at the body's center of mass.
 * 
 * Forces accumulate until the next simulation step.
 */
void ph_body_apply_force(ph_world* world, 
                          ph_body_id body, 
                          ph_vec3 force);

/**
 * @brief Apply a force at a world-space point.
 * 
 * This may induce torque if the point is not at the center of mass.
 */
void ph_body_apply_force_at_point(ph_world* world,
                                   ph_body_id body,
                                   ph_vec3 force,
                                   ph_vec3 point);

/**
 * @brief Apply an instantaneous impulse at the center of mass.
 */
void ph_body_apply_impulse(ph_world* world, 
                            ph_body_id body, 
                            ph_vec3 impulse);

/**
 * @brief Apply torque (rotational force).
 */
void ph_body_apply_torque(ph_world* world, 
                           ph_body_id body, 
                           ph_vec3 torque);

/**
 * @brief Get user data associated with a body.
 */
uint32_t ph_body_get_user_data(const ph_world* world, ph_body_id body);

/**
 * @brief Set user data associated with a body.
 */
void ph_body_set_user_data(ph_world* world, 
                            ph_body_id body, 
                            uint32_t user_data);

/**
 * @brief Check if a body is currently sleeping.
 */
bool ph_body_is_sleeping(const ph_world* world, ph_body_id body);

/**
 * @brief Wake a sleeping body.
 */
void ph_body_wake(ph_world* world, ph_body_id body);

/**
 * @brief Put a body to sleep immediately.
 */
void ph_body_sleep(ph_world* world, ph_body_id body);
\end{lstlisting}

\section{Shape Management}

\begin{lstlisting}[caption={Shape Management Functions}]
/* ================================================================
 * SHAPE MANAGEMENT
 * ================================================================ */

/**
 * @brief Create a collision shape.
 * 
 * Shapes can be shared between multiple bodies to save memory.
 * 
 * @param world  Target world
 * @param desc   Shape configuration
 * @return       Shape handle, or PH_INVALID_SHAPE on failure
 */
ph_shape_id ph_shape_create(ph_world* world, const ph_shape_desc* desc);

/**
 * @brief Destroy a collision shape.
 * 
 * @warning Shape must not be attached to any body.
 */
void ph_shape_destroy(ph_world* world, ph_shape_id shape);

/**
 * @brief Get the AABB of a shape in local space.
 */
ph_aabb ph_shape_get_local_bounds(const ph_world* world, 
                                   ph_shape_id shape);

/**
 * @brief Update shape collision filter.
 */
void ph_shape_set_filter(ph_world* world,
                          ph_shape_id shape,
                          uint32_t group,
                          uint32_t mask);

/**
 * @brief Update shape material properties.
 */
void ph_shape_set_material(ph_world* world,
                            ph_shape_id shape,
                            float friction,
                            float restitution);
\end{lstlisting}

\section{Query API}

\begin{lstlisting}[caption={Spatial Query Types and Functions}]
/* ================================================================
 * SPATIAL QUERIES
 * ================================================================ */

/**
 * @brief Ray cast hit result.
 */
typedef struct ph_raycast_hit {
    ph_body_id body;      /**< Hit body */
    ph_shape_id shape;    /**< Hit shape */
    float      distance;  /**< Distance along ray [0..max_distance] */
    ph_vec3    point;     /**< World-space hit point */
    ph_vec3    normal;    /**< Surface normal at hit point */
} ph_raycast_hit;

/**
 * @brief Query filter parameters.
 */
typedef struct ph_query_filter {
    uint32_t collision_group;  /**< Group bits to test against */
    uint32_t collision_mask;   /**< Mask bits to test against */
    bool     include_sensors;  /**< Include sensor shapes */
} ph_query_filter;

/**
 * @brief Default query filter (all objects).
 */
static inline ph_query_filter ph_query_filter_default(void) {
    ph_query_filter filter;
    filter.collision_group = 0xFFFF;
    filter.collision_mask = 0xFFFF;
    filter.include_sensors = false;
    return filter;
}

/**
 * @brief Cast a ray and return the closest hit.
 * 
 * @param world        World to query
 * @param origin       Ray origin in world space
 * @param direction    Ray direction (should be normalized)
 * @param max_distance Maximum ray distance
 * @param filter       Collision filter
 * @param out_hit      Output hit result (if return is true)
 * @return             True if a hit occurred
 */
bool ph_world_raycast(const ph_world* world,
                      ph_vec3 origin,
                      ph_vec3 direction,
                      float max_distance,
                      const ph_query_filter* filter,
                      ph_raycast_hit* out_hit);

/**
 * @brief Cast a ray and return all hits.
 * 
 * @param world        World to query
 * @param origin       Ray origin in world space
 * @param direction    Ray direction (should be normalized)
 * @param max_distance Maximum ray distance
 * @param filter       Collision filter
 * @param out_hits     Output hit array
 * @param max_hits     Maximum hits to return
 * @return             Number of hits found
 */
int32_t ph_world_raycast_all(const ph_world* world,
                             ph_vec3 origin,
                             ph_vec3 direction,
                             float max_distance,
                             const ph_query_filter* filter,
                             ph_raycast_hit* out_hits,
                             int32_t max_hits);

/**
 * @brief Overlap result.
 */
typedef struct ph_overlap_result {
    ph_body_id body;
    ph_shape_id shape;
} ph_overlap_result;

/**
 * @brief Test for shapes overlapping a sphere.
 * 
 * @param world       World to query
 * @param center      Sphere center in world space
 * @param radius      Sphere radius
 * @param filter      Collision filter
 * @param out_results Output result array
 * @param max_results Maximum results to return
 * @return            Number of overlapping shapes
 */
int32_t ph_world_overlap_sphere(const ph_world* world,
                                ph_vec3 center,
                                float radius,
                                const ph_query_filter* filter,
                                ph_overlap_result* out_results,
                                int32_t max_results);

/**
 * @brief Test for shapes overlapping a box.
 * 
 * @param world        World to query
 * @param center       Box center in world space
 * @param half_extents Box half-extents
 * @param rotation     Box orientation
 * @param filter       Collision filter
 * @param out_results  Output result array
 * @param max_results  Maximum results to return
 * @return             Number of overlapping shapes
 */
int32_t ph_world_overlap_box(const ph_world* world,
                             ph_vec3 center,
                             ph_vec3 half_extents,
                             ph_quat rotation,
                             const ph_query_filter* filter,
                             ph_overlap_result* out_results,
                             int32_t max_results);
\end{lstlisting}

\section{Contact Callback System}

\begin{lstlisting}[caption={Contact Callback System}]
/* ================================================================
 * CONTACT CALLBACKS
 * ================================================================ */

/**
 * @brief Contact event type.
 */
typedef enum ph_contact_event {
    PH_CONTACT_BEGIN   = 0,  /**< New contact pair formed */
    PH_CONTACT_PERSIST = 1,  /**< Existing contact continues */
    PH_CONTACT_END     = 2   /**< Contact pair separated */
} ph_contact_event;

/**
 * @brief Contact pair information.
 */
typedef struct ph_contact_pair {
    ph_body_id      body_a;
    ph_body_id      body_b;
    ph_shape_id     shape_a;
    ph_shape_id     shape_b;
    ph_contact_event event;
    ph_vec3         contact_point;
    ph_vec3         contact_normal;
    float           penetration;
    float           impulse_normal;
    float           impulse_tangent;
} ph_contact_pair;

/**
 * @brief Contact callback function signature.
 * 
 * @param user_context  User-provided context
 * @param pair          Contact pair information
 */
typedef void (*ph_contact_callback)(void* user_context,
                                     const ph_contact_pair* pair);

/**
 * @brief Contact listener configuration.
 */
typedef struct ph_contact_listener {
    void*               user_context;
    ph_contact_callback on_contact_begin;
    ph_contact_callback on_contact_persist;
    ph_contact_callback on_contact_end;
} ph_contact_listener;

/**
 * @brief Set the world's contact listener.
 * 
 * Only one listener can be active at a time.
 * Pass NULL to disable contact callbacks.
 */
void ph_world_set_contact_listener(ph_world* world,
                                    const ph_contact_listener* listener);
\end{lstlisting}

% ============================================================================
% CHAPTER 4: MEMORY AND THREADING
% ============================================================================
\chapter{Memory, Threading, and Performance}

\section{Memory Management Strategy}

\subsection{Allocator Hooks}

The physics engine never calls \texttt{malloc}/\texttt{free} directly. All memory goes through the host-provided allocator:

\begin{lstlisting}[caption={Custom Allocator Implementation Example}]
/* Example: Pool allocator for physics */
typedef struct pool_allocator {
    uint8_t* memory;
    size_t   capacity;
    size_t   used;
    size_t   high_water_mark;
} pool_allocator_t;

void* pool_alloc(void* user, size_t size, size_t align) {
    pool_allocator_t* pool = (pool_allocator_t*)user;
    
    /* Align the current position */
    size_t aligned_used = (pool->used + align - 1) & ~(align - 1);
    
    if (aligned_used + size > pool->capacity) {
        /* Out of memory */
        return NULL;
    }
    
    void* ptr = pool->memory + aligned_used;
    pool->used = aligned_used + size;
    
    /* Track high water mark for profiling */
    if (pool->used > pool->high_water_mark) {
        pool->high_water_mark = pool->used;
    }
    
    return ptr;
}

void pool_free(void* user, void* ptr) {
    /* Pool allocators typically don't free individual blocks */
    /* This is fine for frame-based allocation patterns */
    (void)user;
    (void)ptr;
}

/* Usage */
pool_allocator_t physics_pool;
physics_pool.memory = mmap_large_block(16 * 1024 * 1024);
physics_pool.capacity = 16 * 1024 * 1024;
physics_pool.used = 0;

ph_host_config host = {
    .user_context = &physics_pool,
    .alloc = pool_alloc,
    .free = pool_free,
    .log = NULL
};

ph_world* world = ph_world_create(&world_desc, &host);
\end{lstlisting}

\subsection{Handle Tables and Generational Indices}

Bodies and shapes are stored in arrays indexed by handle. Generational counters prevent use-after-free bugs:

\begin{lstlisting}[caption={Generational Handle Table}]
#define MAX_BODIES 4096

typedef struct body_slot {
    uint16_t generation;  /* Incremented on destroy */
    uint16_t flags;       /* Active, sleeping, etc. */
    /* Body data follows... */
} body_slot_t;

typedef struct body_table {
    body_slot_t slots[MAX_BODIES];
    uint16_t    free_list[MAX_BODIES];
    uint16_t    free_count;
    uint16_t    active_count;
} body_table_t;

/* Validate a handle before use */
static inline bool validate_body_handle(
    const body_table_t* table,
    ph_body_id handle
) {
    uint16_t index = PH_HANDLE_INDEX(handle);
    uint16_t generation = PH_HANDLE_GENERATION(handle);
    
    if (index >= MAX_BODIES) {
        return false;
    }
    
    return table->slots[index].generation == generation;
}

/* Allocate a new body slot */
ph_body_id body_table_alloc(body_table_t* table) {
    if (table->free_count == 0) {
        return PH_INVALID_BODY;
    }
    
    uint16_t index = table->free_list[--table->free_count];
    uint16_t generation = table->slots[index].generation;
    
    table->active_count++;
    
    return PH_MAKE_HANDLE(generation, index);
}

/* Free a body slot */
void body_table_free(body_table_t* table, ph_body_id handle) {
    uint16_t index = PH_HANDLE_INDEX(handle);
    
    /* Increment generation to invalidate existing handles */
    table->slots[index].generation++;
    
    /* Add to free list */
    table->free_list[table->free_count++] = index;
    table->active_count--;
}
\end{lstlisting}

\section{Threading Model}

\subsection{Single-Threaded Baseline}

The default configuration is single-threaded for maximum portability:

\begin{lstlisting}[caption={Single-Threaded Step Implementation}]
void ph_world_step(ph_world* world, float dt, int32_t substeps) {
    float sub_dt = dt / (float)substeps;
    
    for (int32_t i = 0; i < substeps; i++) {
        /* 1. Apply forces and integrate velocities */
        integrate_velocities(world, sub_dt);
        
        /* 2. Broadphase collision detection */
        update_broadphase(world);
        
        /* 3. Narrowphase collision detection */
        generate_contacts(world);
        
        /* 4. Solve velocity constraints */
        for (int32_t iter = 0; iter < world->solver_iterations; iter++) {
            solve_velocity_constraints(world);
        }
        
        /* 5. Integrate positions */
        integrate_positions(world, sub_dt);
        
        /* 6. Solve position constraints */
        for (int32_t iter = 0; iter < world->position_iterations; iter++) {
            solve_position_constraints(world);
        }
        
        /* 7. Update sleeping */
        update_sleeping(world, sub_dt);
        
        /* 8. Fire contact callbacks */
        dispatch_contact_events(world);
    }
}
\end{lstlisting}

\subsection{Optional Parallel Stepping}

When enabled via compile flag, parallelism is contained within \texttt{ph\_world\_step}:

\begin{lstlisting}[caption={Parallel Step Configuration}]
/* Build with: -DPH_ENABLE_THREADING=1 */

#ifdef PH_ENABLE_THREADING

typedef struct ph_thread_config {
    int32_t worker_count;    /* 0 = auto-detect */
    void* (*thread_alloc)(size_t stack_size);
    void  (*thread_free)(void* thread);
} ph_thread_config;

/**
 * @brief Enable parallel stepping.
 * 
 * @param world   World to configure
 * @param config  Threading configuration
 * @return        True if threading was enabled
 * 
 * @note This must be called before the first ph_world_step().
 */
bool ph_world_enable_threading(ph_world* world,
                                const ph_thread_config* config);

#endif /* PH_ENABLE_THREADING */
\end{lstlisting}

\begin{warningbox}[Threading Documentation]
Thread-safety rules must be clearly documented:
\begin{itemize}
    \item Body/shape creation and destruction: only when not stepping
    \item State queries during step: undefined behavior
    \item Multiple worlds: fully independent, can step in parallel
\end{itemize}
\end{warningbox}

\section{Performance Considerations}

\subsection{Data Layout for Cache Efficiency}

\begin{lstlisting}[caption={Structure-of-Arrays Body Storage}]
/* SoA layout for better cache utilization during integration */
typedef struct body_soa {
    /* Position components */
    float* px;
    float* py;
    float* pz;
    
    /* Rotation components (quaternion) */
    float* qx;
    float* qy;
    float* qz;
    float* qw;
    
    /* Linear velocity */
    float* vx;
    float* vy;
    float* vz;
    
    /* Angular velocity */
    float* wx;
    float* wy;
    float* wz;
    
    /* Inverse mass (0 for static) */
    float* inv_mass;
    
    /* Flags (packed) */
    uint32_t* flags;
    
    /* Allocation count */
    uint32_t capacity;
    uint32_t count;
} body_soa_t;

/* Integrate all velocities in one pass */
void integrate_velocities_soa(body_soa_t* bodies, 
                              ph_vec3 gravity,
                              float dt) {
    const float gx = gravity.x * dt;
    const float gy = gravity.y * dt;
    const float gz = gravity.z * dt;
    
    for (uint32_t i = 0; i < bodies->count; i++) {
        float inv_m = bodies->inv_mass[i];
        
        /* Apply gravity (only affects dynamic bodies) */
        bodies->vx[i] += gx * (inv_m > 0.0f ? 1.0f : 0.0f);
        bodies->vy[i] += gy * (inv_m > 0.0f ? 1.0f : 0.0f);
        bodies->vz[i] += gz * (inv_m > 0.0f ? 1.0f : 0.0f);
    }
}
\end{lstlisting}

\subsection{SIMD Acceleration (Optional)}

\begin{lstlisting}[caption={SIMD Integration Example}]
#ifdef PH_ENABLE_SIMD

#include <immintrin.h>  /* AVX */

void integrate_velocities_simd(body_soa_t* bodies,
                               ph_vec3 gravity,
                               float dt) {
    __m256 gx = _mm256_set1_ps(gravity.x * dt);
    __m256 gy = _mm256_set1_ps(gravity.y * dt);
    __m256 gz = _mm256_set1_ps(gravity.z * dt);
    __m256 zero = _mm256_setzero_ps();
    
    uint32_t simd_count = bodies->count & ~7u;  /* Round down to 8 */
    
    for (uint32_t i = 0; i < simd_count; i += 8) {
        /* Load inverse masses */
        __m256 inv_m = _mm256_loadu_ps(&bodies->inv_mass[i]);
        
        /* Create mask: 1.0 if dynamic, 0.0 if static */
        __m256 mask = _mm256_cmp_ps(inv_m, zero, _CMP_GT_OS);
        __m256 factor = _mm256_and_ps(mask, _mm256_set1_ps(1.0f));
        
        /* Load velocities */
        __m256 vx = _mm256_loadu_ps(&bodies->vx[i]);
        __m256 vy = _mm256_loadu_ps(&bodies->vy[i]);
        __m256 vz = _mm256_loadu_ps(&bodies->vz[i]);
        
        /* Apply gravity */
        vx = _mm256_fmadd_ps(gx, factor, vx);
        vy = _mm256_fmadd_ps(gy, factor, vy);
        vz = _mm256_fmadd_ps(gz, factor, vz);
        
        /* Store velocities */
        _mm256_storeu_ps(&bodies->vx[i], vx);
        _mm256_storeu_ps(&bodies->vy[i], vy);
        _mm256_storeu_ps(&bodies->vz[i], vz);
    }
    
    /* Handle remainder with scalar code */
    for (uint32_t i = simd_count; i < bodies->count; i++) {
        /* ... scalar fallback ... */
    }
}

#endif /* PH_ENABLE_SIMD */
\end{lstlisting}

% ============================================================================
% CHAPTER 5: PLATFORM-SPECIFIC IMPLEMENTATION
% ============================================================================
\chapter{Platform-Specific Implementation}

\section{WebAssembly (Browser) Target}

\subsection{WASM Build Configuration}

\begin{lstlisting}[style=cmakestyle,caption={Emscripten CMake Configuration}]
# CMakeLists.txt - WASM target
if(EMSCRIPTEN)
    set(CMAKE_EXECUTABLE_SUFFIX ".js")
    
    # Core WASM settings
    set(WASM_FLAGS
        "-s WASM=1"
        "-s MODULARIZE=1"
        "-s EXPORT_NAME='PhysicsModule'"
        "-s EXPORTED_RUNTIME_METHODS=['ccall','cwrap','getValue','setValue']"
        "-s ALLOW_MEMORY_GROWTH=1"
        "-s INITIAL_MEMORY=16777216"  # 16MB
        "-s MAXIMUM_MEMORY=268435456" # 256MB
        "-s NO_EXIT_RUNTIME=1"
        "-s STRICT=1"
    )
    
    # Disable features not available in WASM
    target_compile_definitions(physics_core PRIVATE
        PH_NO_THREADING=1
        PH_NO_SIMD=1  # Unless targeting WASM SIMD
    )
    
    # Export all public API functions
    set(EXPORTED_FUNCTIONS
        "_ph_world_create"
        "_ph_world_destroy"
        "_ph_world_step"
        "_ph_body_create"
        "_ph_body_destroy"
        "_ph_body_get_pose"
        "_ph_body_set_pose"
        "_ph_shape_create"
        "_ph_world_raycast"
        # ... add all public functions
    )
    
    list(JOIN EXPORTED_FUNCTIONS "," EXPORTS_STR)
    list(APPEND WASM_FLAGS "-s EXPORTED_FUNCTIONS=[${EXPORTS_STR}]")
    
    string(REPLACE ";" " " WASM_FLAGS_STR "${WASM_FLAGS}")
    set_target_properties(physics_core PROPERTIES
        LINK_FLAGS "${WASM_FLAGS_STR}"
    )
endif()
\end{lstlisting}

\subsection{JavaScript Wrapper}

\begin{lstlisting}[style=jsstyle,caption={JavaScript/TypeScript Wrapper}]
// physics-wrapper.ts

export interface Vec3 {
    x: number;
    y: number;
    z: number;
}

export interface Transform {
    position: Vec3;
    rotation: { x: number; y: number; z: number; w: number };
}

export interface BodyDesc {
    type: 'static' | 'dynamic' | 'kinematic';
    position?: Vec3;
    mass?: number;
    linearDamping?: number;
    angularDamping?: number;
}

export class PhysicsWorld {
    private module: any;
    private worldPtr: number;
    private bodyPoseBuffer: Float32Array;
    private bodyPosePtr: number;
    
    private constructor(module: any, worldPtr: number) {
        this.module = module;
        this.worldPtr = worldPtr;
        
        // Pre-allocate pose buffer for efficient batch reads
        const maxBodies = 1024;
        const floatsPerPose = 7; // pos(3) + quat(4)
        this.bodyPosePtr = module._malloc(
            maxBodies * floatsPerPose * 4
        );
        this.bodyPoseBuffer = new Float32Array(
            module.HEAPF32.buffer,
            this.bodyPosePtr,
            maxBodies * floatsPerPose
        );
    }
    
    static async create(gravity: Vec3 = { x: 0, y: -9.81, z: 0 }): Promise<PhysicsWorld> {
        const module = await PhysicsModule();
        
        // Allocate world descriptor on WASM heap
        const descPtr = module._malloc(64);
        module.HEAPF32[descPtr / 4 + 0] = gravity.x;
        module.HEAPF32[descPtr / 4 + 1] = gravity.y;
        module.HEAPF32[descPtr / 4 + 2] = gravity.z;
        module.HEAP32[descPtr / 4 + 3] = 8;  // solver iterations
        // ... set other fields
        
        const worldPtr = module._ph_world_create(descPtr, 0);
        module._free(descPtr);
        
        if (!worldPtr) {
            throw new Error('Failed to create physics world');
        }
        
        return new PhysicsWorld(module, worldPtr);
    }
    
    destroy(): void {
        if (this.worldPtr) {
            this.module._ph_world_destroy(this.worldPtr);
            this.module._free(this.bodyPosePtr);
            this.worldPtr = 0;
        }
    }
    
    step(dt: number, substeps: number = 1): void {
        this.module._ph_world_step(this.worldPtr, dt, substeps);
    }
    
    createBody(desc: BodyDesc): number {
        // Map type enum
        const typeMap = { static: 0, dynamic: 1, kinematic: 2 };
        
        // Allocate descriptor
        const descPtr = this.module._malloc(128);
        this.module.HEAP32[descPtr / 4] = typeMap[desc.type];
        this.module.HEAPF32[descPtr / 4 + 1] = desc.position?.x ?? 0;
        this.module.HEAPF32[descPtr / 4 + 2] = desc.position?.y ?? 0;
        this.module.HEAPF32[descPtr / 4 + 3] = desc.position?.z ?? 0;
        // ... set other fields
        
        const bodyId = this.module._ph_body_create(
            this.worldPtr, descPtr
        );
        this.module._free(descPtr);
        
        return bodyId;
    }
    
    getBodyPose(bodyId: number): Transform {
        // Call into WASM to fill the pose buffer
        const offset = (bodyId & 0xFFFF) * 7;
        this.module._ph_body_get_pose_batch(
            this.worldPtr, 
            this.bodyPosePtr, 
            bodyId, 
            1
        );
        
        return {
            position: {
                x: this.bodyPoseBuffer[offset + 0],
                y: this.bodyPoseBuffer[offset + 1],
                z: this.bodyPoseBuffer[offset + 2]
            },
            rotation: {
                x: this.bodyPoseBuffer[offset + 3],
                y: this.bodyPoseBuffer[offset + 4],
                z: this.bodyPoseBuffer[offset + 5],
                w: this.bodyPoseBuffer[offset + 6]
            }
        };
    }
    
    // Efficient batch pose retrieval for rendering
    getBodyPosesBatch(bodyIds: Uint32Array): Float32Array {
        const count = bodyIds.length;
        
        // Copy body IDs to WASM heap
        const idsPtr = this.module._malloc(count * 4);
        this.module.HEAPU32.set(bodyIds, idsPtr / 4);
        
        // Batch retrieve poses
        this.module._ph_body_get_pose_batch(
            this.worldPtr,
            this.bodyPosePtr,
            idsPtr,
            count
        );
        
        this.module._free(idsPtr);
        
        // Return view into pose buffer
        return this.bodyPoseBuffer.subarray(0, count * 7);
    }
}
\end{lstlisting}

\begin{tipbox}[WASM Performance]
The main performance pitfall in WASM physics is per-frame marshaling. The batch pose retrieval pattern shown above avoids calling \texttt{ph\_body\_get\_pose} in a loop from JavaScript, which would incur significant overhead.
\end{tipbox}

\section{iOS Target}

\subsection{XCFramework Build}

\begin{lstlisting}[style=bashstyle,caption={iOS Build Script}]
#!/bin/bash
# build-ios.sh

set -e

BUILD_DIR="build-ios"
OUTPUT_DIR="output"

# Build for device (ARM64)
cmake -B "${BUILD_DIR}/device" \
    -G Xcode \
    -DCMAKE_SYSTEM_NAME=iOS \
    -DCMAKE_OSX_ARCHITECTURES=arm64 \
    -DCMAKE_OSX_DEPLOYMENT_TARGET=14.0 \
    -DPH_BUILD_STATIC=ON \
    .

cmake --build "${BUILD_DIR}/device" \
    --config Release \
    -- -sdk iphoneos

# Build for simulator (ARM64 + x86_64)
cmake -B "${BUILD_DIR}/simulator" \
    -G Xcode \
    -DCMAKE_SYSTEM_NAME=iOS \
    -DCMAKE_OSX_ARCHITECTURES="arm64;x86_64" \
    -DCMAKE_OSX_DEPLOYMENT_TARGET=14.0 \
    -DCMAKE_OSX_SYSROOT=iphonesimulator \
    -DPH_BUILD_STATIC=ON \
    .

cmake --build "${BUILD_DIR}/simulator" \
    --config Release \
    -- -sdk iphonesimulator

# Create XCFramework
xcodebuild -create-xcframework \
    -library "${BUILD_DIR}/device/Release-iphoneos/libphysics.a" \
    -headers "include" \
    -library "${BUILD_DIR}/simulator/Release-iphonesimulator/libphysics.a" \
    -headers "include" \
    -output "${OUTPUT_DIR}/Physics.xcframework"

echo "Built ${OUTPUT_DIR}/Physics.xcframework"
\end{lstlisting}

\subsection{Swift Bridging}

\begin{lstlisting}[caption={Swift Bridging Header}]
// Physics-Bridging-Header.h

#ifndef Physics_Bridging_Header_h
#define Physics_Bridging_Header_h

#include <physics/physics.h>

#endif
\end{lstlisting}

\begin{lstlisting}[caption={Swift Wrapper Class}]
// PhysicsWorld.swift

import Foundation

public class PhysicsWorld {
    private var world: OpaquePointer?
    
    public init(gravity: SIMD3<Float> = SIMD3(0, -9.81, 0)) {
        var desc = ph_world_desc()
        desc.gravity = ph_vec3(x: gravity.x, y: gravity.y, z: gravity.z)
        desc.solver_iterations = 8
        desc.position_iterations = 3
        desc.enable_sleeping = true
        desc.max_bodies = 1024
        desc.max_shapes = 2048
        
        var host = ph_host_config()
        // Use default allocator for simplicity
        // In production, provide custom allocator
        
        world = ph_world_create(&desc, &host)
    }
    
    deinit {
        if let w = world {
            ph_world_destroy(w)
        }
    }
    
    public func step(deltaTime: Float, substeps: Int32 = 1) {
        guard let w = world else { return }
        ph_world_step(w, deltaTime, substeps)
    }
    
    public func createBody(
        type: BodyType,
        position: SIMD3<Float> = .zero,
        mass: Float = 1.0
    ) -> BodyHandle {
        guard let w = world else { return BodyHandle(id: 0) }
        
        var desc = ph_body_desc()
        desc.type = ph_body_type(rawValue: type.rawValue)
        desc.initial_pose.position = ph_vec3(
            x: position.x, 
            y: position.y, 
            z: position.z
        )
        desc.initial_pose.rotation = ph_quat(x: 0, y: 0, z: 0, w: 1)
        desc.mass = mass
        desc.linear_damping = 0.01
        desc.angular_damping = 0.01
        desc.gravity_scale = 1.0
        desc.allow_sleep = true
        desc.start_awake = true
        
        let id = ph_body_create(w, &desc)
        return BodyHandle(id: id)
    }
    
    public func getBodyPosition(_ handle: BodyHandle) -> SIMD3<Float> {
        guard let w = world else { return .zero }
        let pose = ph_body_get_pose(w, handle.id)
        return SIMD3(pose.position.x, pose.position.y, pose.position.z)
    }
}

public struct BodyHandle {
    let id: ph_body_id
    
    public var isValid: Bool {
        return id != 0
    }
}

public enum BodyType: UInt32 {
    case `static` = 0
    case dynamic = 1
    case kinematic = 2
}
\end{lstlisting}

\section{Android Target}

\subsection{NDK Build Configuration}

\begin{lstlisting}[style=cmakestyle,caption={Android CMake Configuration}]
# CMakeLists.txt - Android target
if(ANDROID)
    # Minimum API level
    set(ANDROID_NATIVE_API_LEVEL 24)
    
    # Use LLD linker for faster builds
    set(ANDROID_LD lld)
    
    # Compile options for Android
    target_compile_options(physics_core PRIVATE
        -ffunction-sections
        -fdata-sections
        -fvisibility=hidden
    )
    
    # Link options
    target_link_options(physics_core PRIVATE
        -Wl,--gc-sections
        -Wl,--exclude-libs,ALL
    )
    
    # Only build for ARM64 (most common modern architecture)
    # Add armeabi-v7a and x86_64 if needed
    set(ANDROID_ABI arm64-v8a)
endif()
\end{lstlisting}

\subsection{JNI Wrapper}

\begin{lstlisting}[caption={JNI Native Implementation}]
// physics_jni.c

#include <jni.h>
#include <physics/physics.h>

// Global references (in production, use proper lifecycle management)
static ph_world* g_world = NULL;

JNIEXPORT jlong JNICALL
Java_com_example_physics_PhysicsWorld_nativeCreate(
    JNIEnv* env,
    jobject thiz,
    jfloat gravity_x,
    jfloat gravity_y,
    jfloat gravity_z
) {
    ph_world_desc desc = ph_world_desc_default();
    desc.gravity = (ph_vec3){ gravity_x, gravity_y, gravity_z };
    
    ph_host_config host = ph_default_host_config();
    
    ph_world* world = ph_world_create(&desc, &host);
    return (jlong)(intptr_t)world;
}

JNIEXPORT void JNICALL
Java_com_example_physics_PhysicsWorld_nativeDestroy(
    JNIEnv* env,
    jobject thiz,
    jlong world_ptr
) {
    ph_world* world = (ph_world*)(intptr_t)world_ptr;
    if (world) {
        ph_world_destroy(world);
    }
}

JNIEXPORT void JNICALL
Java_com_example_physics_PhysicsWorld_nativeStep(
    JNIEnv* env,
    jobject thiz,
    jlong world_ptr,
    jfloat dt,
    jint substeps
) {
    ph_world* world = (ph_world*)(intptr_t)world_ptr;
    if (world) {
        ph_world_step(world, dt, substeps);
    }
}

JNIEXPORT jint JNICALL
Java_com_example_physics_PhysicsWorld_nativeCreateBody(
    JNIEnv* env,
    jobject thiz,
    jlong world_ptr,
    jint type,
    jfloat px, jfloat py, jfloat pz,
    jfloat mass
) {
    ph_world* world = (ph_world*)(intptr_t)world_ptr;
    if (!world) return 0;
    
    ph_body_desc desc = ph_body_desc_default();
    desc.type = (ph_body_type)type;
    desc.initial_pose.position = (ph_vec3){ px, py, pz };
    desc.mass = mass;
    
    return (jint)ph_body_create(world, &desc);
}

// Batch pose retrieval for efficient rendering
JNIEXPORT void JNICALL
Java_com_example_physics_PhysicsWorld_nativeGetBodyPoses(
    JNIEnv* env,
    jobject thiz,
    jlong world_ptr,
    jintArray body_ids,
    jfloatArray out_poses
) {
    ph_world* world = (ph_world*)(intptr_t)world_ptr;
    if (!world) return;
    
    jsize count = (*env)->GetArrayLength(env, body_ids);
    jint* ids = (*env)->GetIntArrayElements(env, body_ids, NULL);
    jfloat* poses = (*env)->GetFloatArrayElements(env, out_poses, NULL);
    
    for (jsize i = 0; i < count; i++) {
        ph_transform pose = ph_body_get_pose(world, (ph_body_id)ids[i]);
        jsize offset = i * 7;
        poses[offset + 0] = pose.position.x;
        poses[offset + 1] = pose.position.y;
        poses[offset + 2] = pose.position.z;
        poses[offset + 3] = pose.rotation.x;
        poses[offset + 4] = pose.rotation.y;
        poses[offset + 5] = pose.rotation.z;
        poses[offset + 6] = pose.rotation.w;
    }
    
    (*env)->ReleaseIntArrayElements(env, body_ids, ids, JNI_ABORT);
    (*env)->ReleaseFloatArrayElements(env, out_poses, poses, 0);
}
\end{lstlisting}

\begin{lstlisting}[caption={Kotlin Wrapper Class}]
// PhysicsWorld.kt

package com.example.physics

class PhysicsWorld(
    gravityX: Float = 0f,
    gravityY: Float = -9.81f,
    gravityZ: Float = 0f
) : AutoCloseable {
    
    private var nativePtr: Long = nativeCreate(gravityX, gravityY, gravityZ)
    
    companion object {
        init {
            System.loadLibrary("physics")
        }
    }
    
    fun step(deltaTime: Float, substeps: Int = 1) {
        nativeStep(nativePtr, deltaTime, substeps)
    }
    
    fun createBody(
        type: BodyType,
        position: FloatArray = floatArrayOf(0f, 0f, 0f),
        mass: Float = 1f
    ): Int {
        return nativeCreateBody(
            nativePtr,
            type.ordinal,
            position[0], position[1], position[2],
            mass
        )
    }
    
    fun getBodyPoses(bodyIds: IntArray): FloatArray {
        val poses = FloatArray(bodyIds.size * 7)
        nativeGetBodyPoses(nativePtr, bodyIds, poses)
        return poses
    }
    
    override fun close() {
        if (nativePtr != 0L) {
            nativeDestroy(nativePtr)
            nativePtr = 0L
        }
    }
    
    // Native methods
    private external fun nativeCreate(gx: Float, gy: Float, gz: Float): Long
    private external fun nativeDestroy(ptr: Long)
    private external fun nativeStep(ptr: Long, dt: Float, substeps: Int)
    private external fun nativeCreateBody(
        ptr: Long, type: Int,
        px: Float, py: Float, pz: Float,
        mass: Float
    ): Int
    private external fun nativeGetBodyPoses(
        ptr: Long, 
        bodyIds: IntArray, 
        outPoses: FloatArray
    )
}

enum class BodyType {
    STATIC,
    DYNAMIC,
    KINEMATIC
}
\end{lstlisting}

% ============================================================================
% CHAPTER 6: BUILD SYSTEM AND PACKAGING
% ============================================================================
\chapter{Build System and Packaging}

\section{Repository Structure}

\begin{lstlisting}[style=bashstyle,caption={Recommended Repository Layout}]
physics-engine/
|-- include/
|   `-- physics/
|       |-- physics.h          # Main public header
|       |-- physics_math.h     # Math types
|       |-- physics_types.h    # Handle/descriptor types
|       `-- physics_version.h  # Version macros
|
|-- src/
|   |-- internal/
|   |   |-- broadphase.h
|   |   |-- broadphase.c
|   |   |-- narrowphase.h
|   |   |-- narrowphase.c
|   |   |-- solver.h
|   |   |-- solver.c
|   |   |-- body_internal.h
|   |   |-- shape_internal.h
|   |   `-- world_internal.h
|   |
|   |-- physics_world.c
|   |-- physics_body.c
|   |-- physics_shape.c
|   |-- physics_query.c
|   `-- physics_math.c
|
|-- pal/
|   |-- pal_common.h
|   |-- pal_common.c
|   |-- pal_wasm.c             # WASM-specific PAL
|   `-- pal_native.c           # Native platforms PAL
|
|-- bindings/
|   |-- wasm/
|   |   |-- physics-wrapper.ts
|   |   |-- package.json
|   |   `-- tsconfig.json
|   |
|   |-- ios/
|   |   |-- PhysicsWorld.swift
|   |   `-- Physics-Bridging-Header.h
|   |
|   `-- android/
|       |-- physics_jni.c
|       `-- PhysicsWorld.kt
|
|-- tests/
|   |-- test_body.c
|   |-- test_collision.c
|   |-- test_query.c
|   `-- test_determinism.c
|
|-- examples/
|   |-- console_basic/
|   |-- web_demo/
|   `-- mobile_demo/
|
|-- cmake/
|   |-- PhysicsConfig.cmake.in
|   |-- EmscriptenToolchain.cmake
|   `-- FindPhysics.cmake
|
|-- scripts/
|   |-- build-ios.sh
|   |-- build-android.sh
|   |-- build-wasm.sh
|   `-- package-all.sh
|
|-- docs/
|   |-- API.md
|   |-- INTEGRATION.md
|   `-- DETERMINISM.md
|
|-- CMakeLists.txt
|-- LICENSE
`-- README.md
\end{lstlisting}

\section{CMake Configuration}

\begin{lstlisting}[style=cmakestyle,caption={Root CMakeLists.txt}]
cmake_minimum_required(VERSION 3.20)

project(PhysicsEngine
    VERSION 1.0.0
    LANGUAGES C
    DESCRIPTION "Cross-platform physics engine"
)

# Options
option(PH_BUILD_STATIC "Build static library" ON)
option(PH_BUILD_SHARED "Build shared library" OFF)
option(PH_BUILD_TESTS "Build unit tests" ON)
option(PH_BUILD_EXAMPLES "Build examples" ON)
option(PH_ENABLE_SIMD "Enable SIMD optimizations" OFF)
option(PH_ENABLE_THREADING "Enable multi-threading" OFF)

# C standard
set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)

# Compiler warnings
if(CMAKE_C_COMPILER_ID MATCHES "GNU|Clang")
    add_compile_options(
        -Wall -Wextra -Wpedantic
        -Wno-unused-parameter
        -Werror=implicit-function-declaration
        -Werror=return-type
    )
elseif(MSVC)
    add_compile_options(/W4 /WX)
endif()

# Source files
set(PHYSICS_SOURCES
    src/physics_world.c
    src/physics_body.c
    src/physics_shape.c
    src/physics_query.c
    src/physics_math.c
    src/internal/broadphase.c
    src/internal/narrowphase.c
    src/internal/solver.c
)

# PAL sources
if(EMSCRIPTEN)
    list(APPEND PHYSICS_SOURCES pal/pal_wasm.c)
else()
    list(APPEND PHYSICS_SOURCES pal/pal_native.c)
endif()

list(APPEND PHYSICS_SOURCES pal/pal_common.c)

# Static library
if(PH_BUILD_STATIC)
    add_library(physics_static STATIC ${PHYSICS_SOURCES})
    target_include_directories(physics_static PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
    )
    target_compile_features(physics_static PUBLIC c_std_11)
    set_target_properties(physics_static PROPERTIES
        OUTPUT_NAME physics
        PUBLIC_HEADER "include/physics/physics.h"
    )
    
    # Feature flags
    if(PH_ENABLE_SIMD)
        target_compile_definitions(physics_static PRIVATE PH_ENABLE_SIMD=1)
    endif()
    if(PH_ENABLE_THREADING)
        target_compile_definitions(physics_static PRIVATE PH_ENABLE_THREADING=1)
        find_package(Threads REQUIRED)
        target_link_libraries(physics_static PRIVATE Threads::Threads)
    endif()
endif()

# Shared library
if(PH_BUILD_SHARED)
    add_library(physics_shared SHARED ${PHYSICS_SOURCES})
    target_include_directories(physics_shared PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
    )
    target_compile_definitions(physics_shared PRIVATE PH_BUILDING_DLL=1)
    set_target_properties(physics_shared PROPERTIES
        OUTPUT_NAME physics
        VERSION ${PROJECT_VERSION}
        SOVERSION ${PROJECT_VERSION_MAJOR}
    )
endif()

# WASM-specific configuration
if(EMSCRIPTEN)
    include(cmake/EmscriptenConfig.cmake)
endif()

# Tests
if(PH_BUILD_TESTS AND NOT EMSCRIPTEN)
    enable_testing()
    add_subdirectory(tests)
endif()

# Examples
if(PH_BUILD_EXAMPLES)
    add_subdirectory(examples)
endif()

# Install rules
include(GNUInstallDirs)
include(CMakePackageConfigHelpers)

install(TARGETS physics_static
    EXPORT PhysicsTargets
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/physics
)

install(DIRECTORY include/physics
    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
)

install(EXPORT PhysicsTargets
    FILE PhysicsTargets.cmake
    NAMESPACE Physics::
    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/Physics
)

configure_package_config_file(
    cmake/PhysicsConfig.cmake.in
    ${CMAKE_CURRENT_BINARY_DIR}/PhysicsConfig.cmake
    INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/Physics
)

write_basic_package_version_file(
    ${CMAKE_CURRENT_BINARY_DIR}/PhysicsConfigVersion.cmake
    VERSION ${PROJECT_VERSION}
    COMPATIBILITY SameMajorVersion
)

install(FILES
    ${CMAKE_CURRENT_BINARY_DIR}/PhysicsConfig.cmake
    ${CMAKE_CURRENT_BINARY_DIR}/PhysicsConfigVersion.cmake
    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/Physics
)
\end{lstlisting}

\section{Version Management}

\begin{lstlisting}[caption={Version Header}]
// include/physics/physics_version.h

#ifndef PHYSICS_VERSION_H
#define PHYSICS_VERSION_H

#define PH_VERSION_MAJOR 1
#define PH_VERSION_MINOR 0
#define PH_VERSION_PATCH 0

#define PH_VERSION_STRING "1.0.0"

#define PH_VERSION_NUMBER \
    ((PH_VERSION_MAJOR * 10000) + \
     (PH_VERSION_MINOR * 100) + \
      PH_VERSION_PATCH)

/**
 * @brief Get runtime version information.
 * 
 * Useful for checking library version when loaded dynamically.
 */
static inline int ph_get_version(void) {
    return PH_VERSION_NUMBER;
}

static inline const char* ph_get_version_string(void) {
    return PH_VERSION_STRING;
}

#endif /* PHYSICS_VERSION_H */
\end{lstlisting}

\section{Semantic Versioning Policy}

\begin{definitionbox}[Version Policy]
\begin{itemize}
    \item \textbf{MAJOR:} Breaking API changes (function signatures, struct layouts)
    \item \textbf{MINOR:} New features, backward-compatible additions
    \item \textbf{PATCH:} Bug fixes, performance improvements, no API changes
\end{itemize}
\end{definitionbox}

\begin{table}[H]
\centering
\caption{API Stability Tiers}
\begin{tabularx}{\textwidth}{lXl}
\toprule
\textbf{Component} & \textbf{Description} & \textbf{Stability} \\
\midrule
World lifecycle & create/destroy/step & Stable \\
Body management & create/destroy/pose/velocity & Stable \\
Basic shapes & sphere/box/capsule & Stable \\
Queries & raycast/overlap & Stable \\
Contact callbacks & listener interface & Stable \\
Convex shapes & convex hull support & Beta \\
Mesh shapes & triangle mesh colliders & Beta \\
Joints & constraint system & Experimental \\
Threading & parallel stepping & Experimental \\
\bottomrule
\end{tabularx}
\end{table}

% ============================================================================
% CHAPTER 7: DETERMINISM AND FIXED TIMESTEP
% ============================================================================
\chapter{Determinism and Fixed Timestep}

\section{Why Determinism Matters}

Deterministic physics simulation is critical for several use cases:

\begin{itemize}[leftmargin=*]
    \item \textbf{Networked Games:} Lockstep multiplayer requires identical simulation results
    \item \textbf{Replays:} Recording inputs and replaying them must produce identical outcomes
    \item \textbf{Testing:} Automated tests need reproducible physics behavior
    \item \textbf{Debugging:} Reproducing bugs requires deterministic execution
\end{itemize}

\section{Fixed Timestep Implementation}

\begin{lstlisting}[caption={Fixed Timestep Game Loop}]
/* Example game loop with fixed physics timestep */

#define PHYSICS_DT (1.0f / 60.0f)  /* 60 Hz physics */
#define MAX_SUBSTEPS 8

typedef struct game_state {
    ph_world*  physics_world;
    float      accumulated_time;
    uint64_t   frame_count;
    /* ... other game state ... */
} game_state_t;

void game_update(game_state_t* game, float delta_time) {
    /* Accumulate time */
    game->accumulated_time += delta_time;
    
    /* Clamp to prevent spiral of death */
    if (game->accumulated_time > PHYSICS_DT * MAX_SUBSTEPS) {
        game->accumulated_time = PHYSICS_DT * MAX_SUBSTEPS;
    }
    
    /* Step physics with fixed timestep */
    while (game->accumulated_time >= PHYSICS_DT) {
        ph_world_step(game->physics_world, PHYSICS_DT, 1);
        game->accumulated_time -= PHYSICS_DT;
        game->frame_count++;
    }
    
    /* Render interpolation factor */
    float alpha = game->accumulated_time / PHYSICS_DT;
    render_interpolated(game, alpha);
}

/* Interpolated rendering for smooth visuals */
void render_interpolated(game_state_t* game, float alpha) {
    /* For each visible body */
    for (uint32_t i = 0; i < game->body_count; i++) {
        ph_body_id body = game->bodies[i];
        
        ph_transform current = ph_body_get_pose(
            game->physics_world, body
        );
        
        /* Interpolate between previous and current pose */
        ph_transform interpolated;
        interpolated.position = lerp_vec3(
            game->previous_poses[i].position,
            current.position,
            alpha
        );
        interpolated.rotation = slerp_quat(
            game->previous_poses[i].rotation,
            current.rotation,
            alpha
        );
        
        /* Render at interpolated position */
        render_body(i, &interpolated);
        
        /* Store for next frame */
        game->previous_poses[i] = current;
    }
}
\end{lstlisting}

\section{Achieving Determinism}

\subsection{Compiler and Build Settings}

\begin{lstlisting}[style=cmakestyle,caption={Deterministic Build Configuration}]
# Deterministic build settings

# Disable fast-math (non-deterministic)
if(CMAKE_C_COMPILER_ID MATCHES "GNU|Clang")
    target_compile_options(physics_static PRIVATE
        -fno-fast-math
        -ffp-contract=off
    )
elseif(MSVC)
    target_compile_options(physics_static PRIVATE
        /fp:precise
    )
endif()

# For WASM builds
if(EMSCRIPTEN)
    target_compile_options(physics_static PRIVATE
        -s WASM=1
        -s DETERMINISTIC=1
    )
endif()
\end{lstlisting}

\subsection{Avoiding Non-Deterministic Operations}

\begin{lstlisting}[caption={Deterministic Iteration Patterns}]
/* BAD: Iterating over hash map with pointer-based ordering */
void process_contacts_bad(contact_map_t* map) {
    for (auto& [key, contact] : map) {
        /* Order depends on memory addresses - non-deterministic! */
        process_contact(&contact);
    }
}

/* GOOD: Sort before processing */
void process_contacts_good(contact_array_t* contacts) {
    /* Sort by deterministic key (body IDs) */
    qsort(contacts->data, contacts->count,
          sizeof(contact_t), compare_contacts_by_id);
    
    for (size_t i = 0; i < contacts->count; i++) {
        process_contact(&contacts->data[i]);
    }
}

/* Contact comparison function */
int compare_contacts_by_id(const void* a, const void* b) {
    const contact_t* ca = (const contact_t*)a;
    const contact_t* cb = (const contact_t*)b;
    
    /* Primary sort: smaller body ID first */
    uint32_t a_min = (ca->body_a < ca->body_b) ? ca->body_a : ca->body_b;
    uint32_t b_min = (cb->body_a < cb->body_b) ? cb->body_a : cb->body_b;
    
    if (a_min != b_min) {
        return (a_min < b_min) ? -1 : 1;
    }
    
    /* Secondary sort: larger body ID */
    uint32_t a_max = (ca->body_a > ca->body_b) ? ca->body_a : ca->body_b;
    uint32_t b_max = (cb->body_a > cb->body_b) ? cb->body_a : cb->body_b;
    
    if (a_max != b_max) {
        return (a_max < b_max) ? -1 : 1;
    }
    
    return 0;
}
\end{lstlisting}

\subsection{Floating Point Considerations}

\begin{lstlisting}[caption={Floating Point Determinism Helpers}]
/* Canonicalize floating point values to avoid -0.0 vs +0.0 issues */
static inline float ph_canonicalize(float x) {
    if (x == 0.0f) return 0.0f;  /* Convert -0.0 to +0.0 */
    return x;
}

/* Clamp to avoid denormals (slow and potentially non-deterministic) */
static inline float ph_flush_denormal(float x) {
    const float min_normal = 1.17549435e-38f;  /* FLT_MIN */
    if (fabsf(x) < min_normal) return 0.0f;
    return x;
}

/* Safe division that avoids inf/nan */
static inline float ph_safe_divide(float a, float b) {
    if (fabsf(b) < PH_EPSILON) {
        return 0.0f;
    }
    return a / b;
}

/* Deterministic sqrt with consistent handling of negative inputs */
static inline float ph_sqrt(float x) {
    if (x <= 0.0f) return 0.0f;
    return sqrtf(x);
}
\end{lstlisting}

\section{Determinism Verification}

\begin{lstlisting}[caption={Determinism Test Framework}]
/* Determinism verification test */

typedef struct simulation_state {
    uint32_t body_count;
    ph_transform* poses;
    ph_vec3* velocities;
    uint32_t hash;
} simulation_state_t;

/* Compute hash of entire simulation state */
uint32_t hash_simulation_state(ph_world* world, uint32_t body_count) {
    uint32_t hash = 0x811c9dc5;  /* FNV-1a offset basis */
    
    for (uint32_t i = 1; i <= body_count; i++) {
        ph_body_id body = i;  /* Assuming sequential IDs */
        ph_transform pose = ph_body_get_pose(world, body);
        ph_vec3 vel = ph_body_get_linear_velocity(world, body);
        
        /* Hash position */
        hash = fnv1a_hash_float(hash, pose.position.x);
        hash = fnv1a_hash_float(hash, pose.position.y);
        hash = fnv1a_hash_float(hash, pose.position.z);
        
        /* Hash rotation */
        hash = fnv1a_hash_float(hash, pose.rotation.x);
        hash = fnv1a_hash_float(hash, pose.rotation.y);
        hash = fnv1a_hash_float(hash, pose.rotation.z);
        hash = fnv1a_hash_float(hash, pose.rotation.w);
        
        /* Hash velocity */
        hash = fnv1a_hash_float(hash, vel.x);
        hash = fnv1a_hash_float(hash, vel.y);
        hash = fnv1a_hash_float(hash, vel.z);
    }
    
    return hash;
}

static inline uint32_t fnv1a_hash_float(uint32_t hash, float value) {
    uint32_t bits;
    memcpy(&bits, &value, sizeof(bits));
    hash ^= bits;
    hash *= 0x01000193;  /* FNV-1a prime */
    return hash;
}

/* Run determinism verification */
bool verify_determinism(int iterations, int steps_per_iteration) {
    uint32_t reference_hash = 0;
    
    for (int iter = 0; iter < iterations; iter++) {
        /* Create fresh world with identical configuration */
        ph_world_desc desc = create_test_world_desc();
        ph_host_config host = ph_default_host_config();
        ph_world* world = ph_world_create(&desc, &host);
        
        /* Add identical bodies */
        setup_test_bodies(world);
        
        /* Run simulation */
        for (int step = 0; step < steps_per_iteration; step++) {
            ph_world_step(world, 1.0f / 60.0f, 1);
        }
        
        /* Hash final state */
        uint32_t hash = hash_simulation_state(world, 100);
        
        if (iter == 0) {
            reference_hash = hash;
        } else if (hash != reference_hash) {
            printf("Determinism failure at iteration %d!\n", iter);
            printf("Expected: 0x%08x, Got: 0x%08x\n", 
                   reference_hash, hash);
            ph_world_destroy(world);
            return false;
        }
        
        ph_world_destroy(world);
    }
    
    printf("Determinism verified over %d iterations\n", iterations);
    return true;
}
\end{lstlisting}

% ============================================================================
% CHAPTER 8: IMPLEMENTATION ROADMAP
% ============================================================================
\chapter{Implementation Roadmap}

\section{Phased Development Approach}

This chapter outlines a disciplined feature roadmap that builds capabilities incrementally while maintaining a usable library at each phase.

\section{Phase 1: Core Simulation Loop}

\textbf{Goal:} Basic rigid body dynamics with gravity and integration.

\textbf{Deliverables:}
\begin{itemize}[leftmargin=*]
    \item World creation/destruction with allocator hooks
    \item Static and dynamic body creation
    \item Sphere and box shape primitives
    \item Semi-implicit Euler integration
    \item Fixed timestep stepping
\end{itemize}

\begin{lstlisting}[caption={Phase 1 Minimal Implementation}]
/* Phase 1: Core world step */
void ph_world_step(ph_world* world, float dt, int32_t substeps) {
    float sub_dt = dt / (float)substeps;
    
    for (int32_t sub = 0; sub < substeps; sub++) {
        /* Apply gravity to all dynamic bodies */
        for (uint32_t i = 0; i < world->body_count; i++) {
            body_t* body = &world->bodies[i];
            if (body->type != PH_BODY_DYNAMIC) continue;
            if (body->flags & BODY_FLAG_SLEEPING) continue;
            
            /* v += gravity * dt */
            body->linear_velocity.x += world->gravity.x * sub_dt;
            body->linear_velocity.y += world->gravity.y * sub_dt;
            body->linear_velocity.z += world->gravity.z * sub_dt;
        }
        
        /* Integrate positions */
        for (uint32_t i = 0; i < world->body_count; i++) {
            body_t* body = &world->bodies[i];
            if (body->type == PH_BODY_STATIC) continue;
            if (body->flags & BODY_FLAG_SLEEPING) continue;
            
            /* p += v * dt */
            body->pose.position.x += body->linear_velocity.x * sub_dt;
            body->pose.position.y += body->linear_velocity.y * sub_dt;
            body->pose.position.z += body->linear_velocity.z * sub_dt;
            
            /* Apply damping */
            float damping = 1.0f - body->linear_damping * sub_dt;
            body->linear_velocity.x *= damping;
            body->linear_velocity.y *= damping;
            body->linear_velocity.z *= damping;
        }
    }
}
\end{lstlisting}

\section{Phase 2: Collision Detection}

\textbf{Goal:} Detect and resolve collisions between shapes.

\textbf{Deliverables:}
\begin{itemize}[leftmargin=*]
    \item Spatial hashing broadphase
    \item Sphere-sphere narrowphase
    \item Box-box narrowphase (SAT)
    \item Sphere-box narrowphase
    \item Contact manifold generation
    \item Basic impulse solver
\end{itemize}

\begin{lstlisting}[caption={Phase 2 Spatial Hash Broadphase}]
#define CELL_SIZE 2.0f
#define HASH_TABLE_SIZE 4096

typedef struct spatial_hash {
    struct {
        ph_body_id* bodies;
        uint32_t count;
        uint32_t capacity;
    } cells[HASH_TABLE_SIZE];
} spatial_hash_t;

/* Hash function for 3D cell coordinates */
static inline uint32_t hash_cell(int32_t x, int32_t y, int32_t z) {
    uint32_t h = (uint32_t)x * 73856093u;
    h ^= (uint32_t)y * 19349663u;
    h ^= (uint32_t)z * 83492791u;
    return h % HASH_TABLE_SIZE;
}

/* Get cell coordinates for a position */
static inline void get_cell_coords(ph_vec3 pos, 
                                    int32_t* cx, 
                                    int32_t* cy, 
                                    int32_t* cz) {
    *cx = (int32_t)floorf(pos.x / CELL_SIZE);
    *cy = (int32_t)floorf(pos.y / CELL_SIZE);
    *cz = (int32_t)floorf(pos.z / CELL_SIZE);
}

/* Insert body into spatial hash */
void spatial_hash_insert(spatial_hash_t* hash,
                         ph_body_id body,
                         const ph_aabb* aabb) {
    int32_t min_x, min_y, min_z;
    int32_t max_x, max_y, max_z;
    
    get_cell_coords(aabb->min, &min_x, &min_y, &min_z);
    get_cell_coords(aabb->max, &max_x, &max_y, &max_z);
    
    /* Insert into all overlapping cells */
    for (int32_t z = min_z; z <= max_z; z++) {
        for (int32_t y = min_y; y <= max_y; y++) {
            for (int32_t x = min_x; x <= max_x; x++) {
                uint32_t cell_index = hash_cell(x, y, z);
                cell_add_body(&hash->cells[cell_index], body);
            }
        }
    }
}

/* Find potential collision pairs */
void spatial_hash_find_pairs(spatial_hash_t* hash,
                             pair_array_t* out_pairs) {
    for (uint32_t i = 0; i < HASH_TABLE_SIZE; i++) {
        uint32_t count = hash->cells[i].count;
        ph_body_id* bodies = hash->cells[i].bodies;
        
        /* All pairs within this cell */
        for (uint32_t a = 0; a < count; a++) {
            for (uint32_t b = a + 1; b < count; b++) {
                /* Ensure consistent ordering (smaller ID first) */
                ph_body_id body_a = bodies[a];
                ph_body_id body_b = bodies[b];
                if (body_a > body_b) {
                    ph_body_id tmp = body_a;
                    body_a = body_b;
                    body_b = tmp;
                }
                
                /* Add unique pair */
                pair_array_add_unique(out_pairs, body_a, body_b);
            }
        }
    }
}
\end{lstlisting}

\section{Phase 3: Queries and Filters}

\textbf{Goal:} Enable game code to query the physics world.

\textbf{Deliverables:}
\begin{itemize}[leftmargin=*]
    \item Raycast (closest hit and all hits)
    \item Sphere overlap query
    \item Box overlap query
    \item Collision layer/mask filtering
    \item Contact begin/persist/end callbacks
\end{itemize}

\begin{lstlisting}[caption={Phase 3 Raycast Implementation}]
bool ph_world_raycast(const ph_world* world,
                      ph_vec3 origin,
                      ph_vec3 direction,
                      float max_distance,
                      const ph_query_filter* filter,
                      ph_raycast_hit* out_hit) {
    
    float closest_t = max_distance;
    bool hit_found = false;
    
    /* Normalize direction */
    float dir_len = vec3_length(direction);
    if (dir_len < PH_EPSILON) {
        return false;
    }
    ph_vec3 dir_norm = vec3_scale(direction, 1.0f / dir_len);
    
    /* Test all shapes (optimize with broadphase in production) */
    for (uint32_t i = 0; i < world->shape_count; i++) {
        shape_t* shape = &world->shapes[i];
        
        /* Apply collision filter */
        if (!filter_test(filter, shape->collision_group)) {
            continue;
        }
        
        /* Skip sensors unless requested */
        if (shape->is_sensor && !filter->include_sensors) {
            continue;
        }
        
        /* Get world-space transform */
        body_t* body = get_body(world, shape->body_id);
        ph_transform world_pose = transform_combine(
            &body->pose, &shape->local_pose
        );
        
        /* Test ray against shape */
        float t;
        ph_vec3 normal;
        bool shape_hit = false;
        
        switch (shape->type) {
            case PH_SHAPE_SPHERE:
                shape_hit = ray_sphere_intersect(
                    origin, dir_norm, closest_t,
                    world_pose.position, shape->sphere.radius,
                    &t, &normal
                );
                break;
                
            case PH_SHAPE_BOX:
                shape_hit = ray_box_intersect(
                    origin, dir_norm, closest_t,
                    &world_pose, &shape->box.half_extents,
                    &t, &normal
                );
                break;
                
            /* ... other shape types ... */
        }
        
        if (shape_hit && t < closest_t) {
            closest_t = t;
            hit_found = true;
            
            out_hit->body = shape->body_id;
            out_hit->shape = PH_MAKE_HANDLE(
                shape->generation, i
            );
            out_hit->distance = t;
            out_hit->point = vec3_add(
                origin, vec3_scale(dir_norm, t)
            );
            out_hit->normal = normal;
        }
    }
    
    return hit_found;
}
\end{lstlisting}

\section{Phase 4: Constraints and Joints}

\textbf{Goal:} Connect bodies with constraints.

\textbf{Deliverables:}
\begin{itemize}[leftmargin=*]
    \item Distance joint
    \item Hinge joint (revolute)
    \item Fixed joint (weld)
    \item Prismatic joint (slider)
    \item Warm starting for solver stability
\end{itemize}

\section{Phase 5: Performance Optimization}

\textbf{Goal:} Production-ready performance.

\textbf{Deliverables:}
\begin{itemize}[leftmargin=*]
    \item Profiling harness
    \item BVH broadphase option
    \item SIMD integration (optional)
    \item Multi-threaded island solving (optional)
    \item Memory pool optimizations
    \item Sleeping and island management
\end{itemize}

\section{Phase 6: Advanced Features}

\textbf{Goal:} Extended functionality for complex games.

\textbf{Deliverables:}
\begin{itemize}[leftmargin=*]
    \item Capsule and cylinder shapes
    \item Convex hull shapes
    \item Triangle mesh collision (static only)
    \item Continuous collision detection (CCD)
    \item Compound shapes
\end{itemize}

% ============================================================================
% CHAPTER 9: INTEGRATION EXAMPLES
% ============================================================================
\chapter{Integration Examples}

\section{Basic Console Example}

\begin{lstlisting}[caption={Minimal Console Application}]
/* examples/console_basic/main.c */

#include <stdio.h>
#include <physics/physics.h>

int main(void) {
    /* Create world with default configuration */
    ph_world_desc world_desc = ph_world_desc_default();
    ph_host_config host = ph_default_host_config();
    
    ph_world* world = ph_world_create(&world_desc, &host);
    if (!world) {
        fprintf(stderr, "Failed to create physics world\n");
        return 1;
    }
    
    /* Create ground (static box) */
    ph_body_desc ground_desc = {0};
    ground_desc.type = PH_BODY_STATIC;
    ground_desc.initial_pose.position = (ph_vec3){ 0, -1, 0 };
    ground_desc.initial_pose.rotation = PH_QUAT_IDENTITY;
    
    ph_body_id ground = ph_body_create(world, &ground_desc);
    
    ph_shape_desc ground_shape_desc = ph_shape_desc_default();
    ground_shape_desc.type = PH_SHAPE_BOX;
    ground_shape_desc.params.box.half_extents = (ph_vec3){ 10, 1, 10 };
    
    ph_shape_id ground_shape = ph_shape_create(world, &ground_shape_desc);
    ph_body_attach_shape(world, ground, ground_shape, 
                         &PH_TRANSFORM_IDENTITY);
    
    /* Create falling sphere */
    ph_body_desc sphere_desc = ph_body_desc_default();
    sphere_desc.type = PH_BODY_DYNAMIC;
    sphere_desc.initial_pose.position = (ph_vec3){ 0, 10, 0 };
    sphere_desc.mass = 1.0f;
    
    ph_body_id sphere = ph_body_create(world, &sphere_desc);
    
    ph_shape_desc sphere_shape_desc = ph_shape_desc_default();
    sphere_shape_desc.type = PH_SHAPE_SPHERE;
    sphere_shape_desc.params.sphere.radius = 0.5f;
    
    ph_shape_id sphere_shape = ph_shape_create(world, &sphere_shape_desc);
    ph_body_attach_shape(world, sphere, sphere_shape, 
                         &PH_TRANSFORM_IDENTITY);
    
    /* Simulate for 5 seconds */
    printf("Simulating...\n");
    for (int frame = 0; frame < 300; frame++) {
        ph_world_step(world, 1.0f / 60.0f, 1);
        
        if (frame % 60 == 0) {
            ph_transform pose = ph_body_get_pose(world, sphere);
            printf("Frame %d: sphere at (%.2f, %.2f, %.2f)\n",
                   frame, 
                   pose.position.x, 
                   pose.position.y, 
                   pose.position.z);
        }
    }
    
    /* Cleanup */
    ph_world_destroy(world);
    
    printf("Done!\n");
    return 0;
}
\end{lstlisting}

\section{Web Browser Demo}

\begin{lstlisting}[style=jsstyle,caption={Browser Demo Application}]
// examples/web_demo/main.ts

import { PhysicsWorld, BodyType } from './physics-wrapper';

interface RenderObject {
    bodyId: number;
    mesh: THREE.Mesh;
}

class PhysicsDemo {
    private world: PhysicsWorld;
    private scene: THREE.Scene;
    private camera: THREE.PerspectiveCamera;
    private renderer: THREE.WebGLRenderer;
    private objects: RenderObject[] = [];
    private lastTime: number = 0;
    private accumulator: number = 0;
    private readonly PHYSICS_DT = 1 / 60;
    
    async initialize(): Promise<void> {
        // Initialize physics
        this.world = await PhysicsWorld.create({ 
            x: 0, y: -9.81, z: 0 
        });
        
        // Initialize Three.js
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(
            75, window.innerWidth / window.innerHeight, 0.1, 1000
        );
        this.camera.position.set(0, 5, 15);
        this.camera.lookAt(0, 0, 0);
        
        this.renderer = new THREE.WebGLRenderer();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);
        
        // Create ground
        this.createGround();
        
        // Create falling boxes
        for (let i = 0; i < 20; i++) {
            this.createBox(
                (Math.random() - 0.5) * 4,
                5 + i * 1.5,
                (Math.random() - 0.5) * 4
            );
        }
        
        // Start render loop
        this.lastTime = performance.now();
        requestAnimationFrame((t) => this.update(t));
    }
    
    private createGround(): void {
        // Physics body
        const groundBody = this.world.createBody({
            type: 'static',
            position: { x: 0, y: -1, z: 0 }
        });
        
        // Visual mesh
        const geometry = new THREE.BoxGeometry(20, 2, 20);
        const material = new THREE.MeshStandardMaterial({ 
            color: 0x444444 
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(0, -1, 0);
        this.scene.add(mesh);
    }
    
    private createBox(x: number, y: number, z: number): void {
        // Physics body
        const bodyId = this.world.createBody({
            type: 'dynamic',
            position: { x, y, z },
            mass: 1.0
        });
        
        // Visual mesh
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshStandardMaterial({
            color: Math.random() * 0xffffff
        });
        const mesh = new THREE.Mesh(geometry, material);
        this.scene.add(mesh);
        
        this.objects.push({ bodyId, mesh });
    }
    
    private update(currentTime: number): void {
        const deltaTime = (currentTime - this.lastTime) / 1000;
        this.lastTime = currentTime;
        
        // Fixed timestep physics
        this.accumulator += deltaTime;
        
        while (this.accumulator >= this.PHYSICS_DT) {
            this.world.step(this.PHYSICS_DT);
            this.accumulator -= this.PHYSICS_DT;
        }
        
        // Sync visuals to physics
        this.syncVisuals();
        
        // Render
        this.renderer.render(this.scene, this.camera);
        
        requestAnimationFrame((t) => this.update(t));
    }
    
    private syncVisuals(): void {
        // Batch retrieve poses for efficiency
        const bodyIds = new Uint32Array(
            this.objects.map(o => o.bodyId)
        );
        const poses = this.world.getBodyPosesBatch(bodyIds);
        
        for (let i = 0; i < this.objects.length; i++) {
            const offset = i * 7;
            const obj = this.objects[i];
            
            obj.mesh.position.set(
                poses[offset + 0],
                poses[offset + 1],
                poses[offset + 2]
            );
            
            obj.mesh.quaternion.set(
                poses[offset + 3],
                poses[offset + 4],
                poses[offset + 5],
                poses[offset + 6]
            );
        }
    }
}

// Start demo
const demo = new PhysicsDemo();
demo.initialize().catch(console.error);
\end{lstlisting}

\section{Debug Rendering Bridge}

\begin{lstlisting}[caption={Debug Draw Interface}]
/* Debug draw callback interface */

typedef struct ph_debug_line {
    ph_vec3 start;
    ph_vec3 end;
    uint32_t color;  /* RGBA packed */
} ph_debug_line;

typedef struct ph_debug_triangle {
    ph_vec3 v0, v1, v2;
    uint32_t color;
} ph_debug_triangle;

typedef void (*ph_debug_draw_line_fn)(void* context, 
                                       const ph_debug_line* line);
typedef void (*ph_debug_draw_triangle_fn)(void* context,
                                           const ph_debug_triangle* tri);

typedef struct ph_debug_draw {
    void* context;
    ph_debug_draw_line_fn draw_line;
    ph_debug_draw_triangle_fn draw_triangle;
    
    /* What to draw */
    bool draw_shapes;
    bool draw_contacts;
    bool draw_aabbs;
    bool draw_joints;
    bool draw_velocities;
} ph_debug_draw;

/**
 * @brief Render debug visualization of the physics world.
 * 
 * Call after ph_world_step() to visualize current state.
 */
void ph_world_debug_draw(const ph_world* world,
                          const ph_debug_draw* draw);

/* Example: OpenGL debug draw implementation */
void gl_draw_line(void* context, const ph_debug_line* line) {
    glBegin(GL_LINES);
    
    uint8_t r = (line->color >> 24) & 0xFF;
    uint8_t g = (line->color >> 16) & 0xFF;
    uint8_t b = (line->color >>  8) & 0xFF;
    uint8_t a = (line->color >>  0) & 0xFF;
    glColor4ub(r, g, b, a);
    
    glVertex3f(line->start.x, line->start.y, line->start.z);
    glVertex3f(line->end.x, line->end.y, line->end.z);
    
    glEnd();
}
\end{lstlisting}

% ============================================================================
% CHAPTER 10: PORTABILITY CHECKLIST
% ============================================================================
\chapter{Portability Checklist}

\section{Critical Requirements}

The following engineering practices are non-negotiable for cross-platform portability:

\begin{table}[H]
\centering
\caption{Portability Checklist}
\begin{tabularx}{\textwidth}{lXc}
\toprule
\textbf{Category} & \textbf{Requirement} & \textbf{Status} \\
\midrule
\multirow{3}{*}{Types} 
    & Use fixed-size types (\texttt{uint32\_t}, not \texttt{int}) & $\square$ \\
    & Explicit \texttt{float} usage (not \texttt{double}) & $\square$ \\
    & No compiler-specific extensions in public API & $\square$ \\
\midrule
\multirow{3}{*}{Memory}
    & Configurable allocator (no hidden malloc) & $\square$ \\
    & Explicit alignment requirements documented & $\square$ \\
    & No global/static mutable state & $\square$ \\
\midrule
\multirow{3}{*}{ABI}
    & C linkage for all public functions & $\square$ \\
    & Opaque handles (no exposed struct internals) & $\square$ \\
    & POD descriptors for all configuration & $\square$ \\
\midrule
\multirow{3}{*}{Platform}
    & No OS calls in core (all via PAL) & $\square$ \\
    & No file I/O in core & $\square$ \\
    & No socket/network code in core & $\square$ \\
\midrule
\multirow{3}{*}{Threading}
    & Single-threaded by default & $\square$ \\
    & Parallelism behind feature flag & $\square$ \\
    & Thread-safety rules documented & $\square$ \\
\midrule
\multirow{3}{*}{FP Math}
    & Fixed timestep API & $\square$ \\
    & No fast-math in deterministic builds & $\square$ \\
    & Consistent FP settings per platform & $\square$ \\
\midrule
\multirow{3}{*}{Build}
    & CMake as source of truth & $\square$ \\
    & Feature flags for optional components & $\square$ \\
    & Documented compiler/standard requirements & $\square$ \\
\bottomrule
\end{tabularx}
\end{table}

\section{Undefined Behavior Avoidance}

\begin{lstlisting}[caption={UB Prevention Patterns}]
/* ====== STRICT ALIASING ====== */

/* BAD: Type punning via pointer cast */
float bad_uint_to_float(uint32_t bits) {
    return *(float*)&bits;  /* UB: strict aliasing violation */
}

/* GOOD: Use memcpy for type punning */
float good_uint_to_float(uint32_t bits) {
    float result;
    memcpy(&result, &bits, sizeof(result));
    return result;
}

/* ====== UNINITIALIZED READS ====== */

/* BAD: Struct may have uninitialized padding */
ph_body_desc create_body_bad(void) {
    ph_body_desc desc;
    desc.type = PH_BODY_DYNAMIC;
    desc.mass = 1.0f;
    /* Other fields uninitialized! */
    return desc;
}

/* GOOD: Zero-initialize, then set fields */
ph_body_desc create_body_good(void) {
    ph_body_desc desc = {0};  /* Zero all fields including padding */
    desc.type = PH_BODY_DYNAMIC;
    desc.mass = 1.0f;
    return desc;
}

/* ====== ALIGNMENT ====== */

/* BAD: Unaligned access */
void read_unaligned_bad(const uint8_t* data) {
    /* May crash on ARM if data is not 4-byte aligned */
    uint32_t value = *(uint32_t*)data;
}

/* GOOD: Use memcpy for potentially unaligned reads */
void read_unaligned_good(const uint8_t* data) {
    uint32_t value;
    memcpy(&value, data, sizeof(value));
}

/* ====== SIGNED INTEGER OVERFLOW ====== */

/* BAD: Signed overflow is UB */
int32_t multiply_bad(int32_t a, int32_t b) {
    return a * b;  /* UB if result overflows */
}

/* GOOD: Check for overflow or use unsigned */
uint32_t multiply_good(uint32_t a, uint32_t b) {
    /* Unsigned overflow is well-defined (wraps) */
    return a * b;
}
\end{lstlisting}

\section{Endianness Handling}

\begin{lstlisting}[caption={Endianness Utilities}]
/* Document assumption */
/* NOTE: This library assumes little-endian byte order */

/* Runtime endianness check (for assertions) */
static inline bool is_little_endian(void) {
    uint32_t test = 1;
    return *(uint8_t*)&test == 1;
}

/* Portable byte swap */
static inline uint32_t byte_swap_32(uint32_t value) {
    return ((value & 0x000000FF) << 24) |
           ((value & 0x0000FF00) << 8)  |
           ((value & 0x00FF0000) >> 8)  |
           ((value & 0xFF000000) >> 24);
}

/* Convert to/from little-endian for serialization */
static inline uint32_t to_little_endian_32(uint32_t value) {
#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
    return byte_swap_32(value);
#else
    return value;
#endif
}
\end{lstlisting}

% ============================================================================
% APPENDICES
% ============================================================================
\appendix

\chapter{Complete Public Header}

\begin{lstlisting}[caption={Complete physics.h Header}]
/**
 * @file physics.h
 * @brief Cross-Platform Physics Engine Public API
 * @version 1.0.0
 * 
 * This is the only header consumers need to include.
 * All types, functions, and constants are defined here.
 */

#ifndef PHYSICS_H
#define PHYSICS_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Version information */
#define PH_VERSION_MAJOR 1
#define PH_VERSION_MINOR 0
#define PH_VERSION_PATCH 0

/* DLL export/import macros */
#if defined(_WIN32) && defined(PH_BUILDING_DLL)
    #define PH_API __declspec(dllexport)
#elif defined(_WIN32) && defined(PH_USING_DLL)
    #define PH_API __declspec(dllimport)
#else
    #define PH_API
#endif

/* ================================================================
 * FORWARD DECLARATIONS
 * ================================================================ */

typedef struct ph_world ph_world;

/* ================================================================
 * MATHEMATICAL TYPES
 * ================================================================ */

typedef struct ph_vec3 { float x, y, z; } ph_vec3;
typedef struct ph_quat { float x, y, z, w; } ph_quat;
typedef struct ph_transform {
    ph_vec3 position;
    ph_quat rotation;
} ph_transform;
typedef struct ph_mat33 { float m[3][3]; } ph_mat33;
typedef struct ph_aabb { ph_vec3 min, max; } ph_aabb;

/* ================================================================
 * HANDLE TYPES
 * ================================================================ */

typedef uint32_t ph_body_id;
typedef uint32_t ph_shape_id;
typedef uint32_t ph_joint_id;

#define PH_INVALID_BODY   ((ph_body_id)0)
#define PH_INVALID_SHAPE  ((ph_shape_id)0)
#define PH_INVALID_JOINT  ((ph_joint_id)0)

/* ================================================================
 * HOST CONFIGURATION
 * ================================================================ */

typedef void* (*ph_alloc_fn)(void* user, size_t size, size_t align);
typedef void  (*ph_free_fn)(void* user, void* ptr);
typedef void  (*ph_log_fn)(void* user, int severity, const char* msg);

typedef struct ph_host_config {
    void*       user_context;
    ph_alloc_fn alloc;
    ph_free_fn  free;
    ph_log_fn   log;
} ph_host_config;

PH_API ph_host_config ph_default_host_config(void);

/* ================================================================
 * BODY TYPES AND DESCRIPTORS
 * ================================================================ */

typedef enum ph_body_type {
    PH_BODY_STATIC    = 0,
    PH_BODY_DYNAMIC   = 1,
    PH_BODY_KINEMATIC = 2
} ph_body_type;

typedef struct ph_body_desc {
    ph_body_type type;
    ph_transform initial_pose;
    ph_vec3      linear_velocity;
    ph_vec3      angular_velocity;
    float        mass;
    ph_mat33     inertia_tensor;
    float        linear_damping;
    float        angular_damping;
    float        gravity_scale;
    bool         allow_sleep;
    bool         start_awake;
    bool         continuous;
    uint32_t     user_data;
} ph_body_desc;

/* ================================================================
 * SHAPE TYPES AND DESCRIPTORS
 * ================================================================ */

typedef enum ph_shape_type {
    PH_SHAPE_SPHERE   = 0,
    PH_SHAPE_BOX      = 1,
    PH_SHAPE_CAPSULE  = 2,
    PH_SHAPE_CYLINDER = 3,
    PH_SHAPE_CONVEX   = 4,
    PH_SHAPE_MESH     = 5
} ph_shape_type;

typedef struct ph_shape_desc {
    ph_shape_type type;
    union {
        struct { float radius; } sphere;
        struct { ph_vec3 half_extents; } box;
        struct { float radius, height; } capsule;
        struct { const ph_vec3* vertices; uint32_t count; } convex;
    } params;
    ph_transform  local_pose;
    float         density;
    float         friction;
    float         restitution;
    uint32_t      collision_group;
    uint32_t      collision_mask;
    bool          is_sensor;
} ph_shape_desc;

/* ================================================================
 * WORLD CONFIGURATION
 * ================================================================ */

typedef struct ph_world_desc {
    ph_vec3  gravity;
    int32_t  solver_iterations;
    int32_t  position_iterations;
    float    slop;
    float    baumgarte;
    float    sleep_threshold;
    float    sleep_time;
    bool     enable_sleeping;
    bool     enable_ccd;
    uint32_t max_bodies;
    uint32_t max_shapes;
} ph_world_desc;

/* ================================================================
 * QUERY TYPES
 * ================================================================ */

typedef struct ph_raycast_hit {
    ph_body_id  body;
    ph_shape_id shape;
    float       distance;
    ph_vec3     point;
    ph_vec3     normal;
} ph_raycast_hit;

typedef struct ph_query_filter {
    uint32_t collision_group;
    uint32_t collision_mask;
    bool     include_sensors;
} ph_query_filter;

/* ================================================================
 * CONTACT CALLBACKS
 * ================================================================ */

typedef enum ph_contact_event {
    PH_CONTACT_BEGIN   = 0,
    PH_CONTACT_PERSIST = 1,
    PH_CONTACT_END     = 2
} ph_contact_event;

typedef struct ph_contact_pair {
    ph_body_id       body_a, body_b;
    ph_shape_id      shape_a, shape_b;
    ph_contact_event event;
    ph_vec3          contact_point;
    ph_vec3          contact_normal;
    float            penetration;
    float            impulse_normal;
    float            impulse_tangent;
} ph_contact_pair;

typedef void (*ph_contact_callback)(void* user, const ph_contact_pair* pair);

typedef struct ph_contact_listener {
    void* user_context;
    ph_contact_callback on_contact_begin;
    ph_contact_callback on_contact_persist;
    ph_contact_callback on_contact_end;
} ph_contact_listener;

/* ================================================================
 * WORLD FUNCTIONS
 * ================================================================ */

PH_API ph_world* ph_world_create(const ph_world_desc* desc,
                                  const ph_host_config* host);
PH_API void      ph_world_destroy(ph_world* world);
PH_API void      ph_world_step(ph_world* world, float dt, int32_t substeps);
PH_API void      ph_world_set_contact_listener(ph_world* world,
                                                const ph_contact_listener* l);

/* ================================================================
 * BODY FUNCTIONS
 * ================================================================ */

PH_API ph_body_id   ph_body_create(ph_world* w, const ph_body_desc* desc);
PH_API void         ph_body_destroy(ph_world* w, ph_body_id body);
PH_API void         ph_body_attach_shape(ph_world* w, ph_body_id body,
                                          ph_shape_id shape,
                                          const ph_transform* local_pose);
PH_API ph_transform ph_body_get_pose(const ph_world* w, ph_body_id body);
PH_API void         ph_body_set_pose(ph_world* w, ph_body_id body,
                                      const ph_transform* pose);
PH_API ph_vec3      ph_body_get_linear_velocity(const ph_world* w,
                                                 ph_body_id body);
PH_API void         ph_body_set_linear_velocity(ph_world* w, ph_body_id body,
                                                 ph_vec3 velocity);
PH_API ph_vec3      ph_body_get_angular_velocity(const ph_world* w,
                                                  ph_body_id body);
PH_API void         ph_body_set_angular_velocity(ph_world* w, ph_body_id body,
                                                  ph_vec3 velocity);
PH_API void         ph_body_apply_force(ph_world* w, ph_body_id body,
                                         ph_vec3 force);
PH_API void         ph_body_apply_impulse(ph_world* w, ph_body_id body,
                                           ph_vec3 impulse);
PH_API void         ph_body_apply_torque(ph_world* w, ph_body_id body,
                                          ph_vec3 torque);
PH_API uint32_t     ph_body_get_user_data(const ph_world* w, ph_body_id body);
PH_API void         ph_body_set_user_data(ph_world* w, ph_body_id body,
                                           uint32_t user_data);
PH_API bool         ph_body_is_sleeping(const ph_world* w, ph_body_id body);
PH_API void         ph_body_wake(ph_world* w, ph_body_id body);
PH_API void         ph_body_sleep(ph_world* w, ph_body_id body);

/* ================================================================
 * SHAPE FUNCTIONS
 * ================================================================ */

PH_API ph_shape_id ph_shape_create(ph_world* w, const ph_shape_desc* desc);
PH_API void        ph_shape_destroy(ph_world* w, ph_shape_id shape);
PH_API ph_aabb     ph_shape_get_local_bounds(const ph_world* w,
                                              ph_shape_id shape);
PH_API void        ph_shape_set_filter(ph_world* w, ph_shape_id shape,
                                        uint32_t group, uint32_t mask);
PH_API void        ph_shape_set_material(ph_world* w, ph_shape_id shape,
                                          float friction, float restitution);

/* ================================================================
 * QUERY FUNCTIONS
 * ================================================================ */

PH_API bool    ph_world_raycast(const ph_world* w, ph_vec3 origin,
                                 ph_vec3 direction, float max_distance,
                                 const ph_query_filter* filter,
                                 ph_raycast_hit* out_hit);
PH_API int32_t ph_world_raycast_all(const ph_world* w, ph_vec3 origin,
                                     ph_vec3 direction, float max_distance,
                                     const ph_query_filter* filter,
                                     ph_raycast_hit* out_hits,
                                     int32_t max_hits);

#ifdef __cplusplus
}
#endif

#endif /* PHYSICS_H */
\end{lstlisting}

\chapter{Quick Reference}

\section{API Cheat Sheet}

\begin{table}[H]
\centering
\caption{Core API Quick Reference}
\begin{tabularx}{\textwidth}{lX}
\toprule
\textbf{Function} & \textbf{Purpose} \\
\midrule
\texttt{ph\_world\_create} & Create physics world \\
\texttt{ph\_world\_destroy} & Destroy world and all objects \\
\texttt{ph\_world\_step} & Advance simulation \\
\midrule
\texttt{ph\_body\_create} & Create rigid body \\
\texttt{ph\_body\_destroy} & Remove body \\
\texttt{ph\_body\_get\_pose} & Get world transform \\
\texttt{ph\_body\_set\_pose} & Teleport body \\
\texttt{ph\_body\_apply\_force} & Add force for next step \\
\texttt{ph\_body\_apply\_impulse} & Instant velocity change \\
\midrule
\texttt{ph\_shape\_create} & Create collision shape \\
\texttt{ph\_body\_attach\_shape} & Attach shape to body \\
\midrule
\texttt{ph\_world\_raycast} & Cast ray, get closest hit \\
\texttt{ph\_world\_raycast\_all} & Cast ray, get all hits \\
\bottomrule
\end{tabularx}
\end{table}

\section{Build Commands}

\begin{lstlisting}[style=bashstyle,caption={Common Build Commands}]
# Native debug build
cmake -B build -DCMAKE_BUILD_TYPE=Debug
cmake --build build

# Native release build
cmake -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build

# WASM build
emcmake cmake -B build-wasm
cmake --build build-wasm

# iOS build
./scripts/build-ios.sh

# Android build (requires NDK)
./scripts/build-android.sh
\end{lstlisting}

% ============================================================================
% END DOCUMENT
% ============================================================================

\end{document}