
\documentclass[11pt,a4paper]{article}

% Encoding & fonts
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{microtype}

% Layout & links
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=blue!60!black,
  urlcolor=blue!60!black,
  citecolor=blue!60!black
}

% Colors & boxes
\usepackage[table]{xcolor}
\definecolor{Teal}{RGB}{0,128,128}
\definecolor{LightGray}{RGB}{244,244,244}
\usepackage{tcolorbox}
\tcbset{colback=white, colframe=black!15, left=6pt, right=6pt, top=6pt, bottom=6pt}

% Tables & lists
\usepackage{tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\newcolumntype{R}{>{\raggedleft\arraybackslash}X}
\usepackage{enumitem}
\setlist{itemsep=2pt, topsep=4pt, leftmargin=1.2em}

% Icons
\usepackage{pifont}
\newcommand{\checkbox}{\ding{113}}

% Tag pill
\newcommand{\Tag}[1]{\fcolorbox{Teal!60!black}{Teal!7}{\strut\;#1\;}}

% Card environments
\newtcolorbox{StoryCard}[1]{title={#1}}
\newtcolorbox{TasksBox}[1]{title={#1}, colframe=Teal!60!black, coltitle=Teal!60!black}

% Reusable footlines
\newcommand{\DoR}{\textit{Definition of Ready:} Persona clear; AC drafted; Dependencies known; Estimate set.}
\newcommand{\DoD}{\textit{Definition of Done:} All ACs pass; Tests green; Security and accessibility checks complete; Docs updated; Artifacts published.}

% Header (8 args max due to TeX limit)
% 1 Epic/Feature, 2 Business Value, 3 Priority, 4 Story Points, 5 Persona, 6 Dependencies, 7 Assumptions/Risks, 8 Story
\newcommand{\StoryHeader}[8]{%
\begin{tabularx}{\textwidth}{L R}
\textbf{Epic / Feature} & #1 \\
\textbf{Business Value} & #2 \\
\textbf{Priority / Estimate} & \textbf{Priority:} #3 \quad \textbf{SP:} #4 \\
\textbf{Persona} & #5 \\
\textbf{Dependencies} & #6 \\
\textbf{Assumptions / Risks} & #7 \\
\end{tabularx}

\vspace{0.5em}
\textbf{Story} \hspace{0.4em} \emph{#8}

\vspace{0.6em}
\textbf{Non-Functional} \hspace{0.6em}
\Tag{Performance}\hspace{0.3em}
\Tag{Security}\hspace{0.3em}
\Tag{Reliability}\hspace{0.3em}
\Tag{Accessibility}
}

% BDD block (4 args: Scenario, Given, When, Then)
\newcommand{\StoryBDD}[4]{%
\vspace{0.6em}
\textbf{Acceptance Criteria (BDD)}
\begin{description}[leftmargin=1.8cm, style=nextline]
\item[Scenario] #1
\item[Given] #2
\item[When] #3
\item[Then] #4
\end{description}
}

\title{TypeScript Cookbook --- User Stories Study Plan}
\author{}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\clearpage
\begin{StoryCard}{TEMPLATE --- Replace with short, action-oriented title}
\StoryHeader{<epic/feature>}{<why this matters to stakeholders>}{Must/Should/Could}{<story points>}{<who benefits>}{<tools, repos, environments>}{<key assumptions and risks>}{As a <persona>, I want <capability> so that <value>.}
\StoryBDD{Happy path}{the target repo/project/context is available}{the hands-on objectives for this story are executed}{the stated outcomes/deliverables are produced and reviewed}


\begin{TasksBox}{Tasks}
\begin{itemize}
  \item \checkbox\; <Task 1 (concrete, 15--60 minutes)>
  \item \checkbox\; <Task 2>
  \item \checkbox\; <Task 3>
  \item \checkbox\; <Add 5--10 test assertions or type tests>
  \item \checkbox\; <Document findings in README.md>
\end{itemize}
\end{TasksBox}
\end{StoryCard}
\clearpage

\begin{StoryCard}{TC-01 --- Project Setup}
\StoryHeader{TypeScript Cookbook Study}{Establish consistent TS project setup across Node, React, and Deno to accelerate later chapters and reduce configuration risk.}{Must}{3}{Full-stack developer starting a typed JS codebase}{Node LTS, pnpm/npm, TypeScript (strict), Vitest/Jest, Vite (for React), Deno}{Strict mode enabled; CI can run \texttt{tsc --noEmit}. Risk: ESM/CJS mismatch; different TS versions across tools.}{As a developer, I want to create a repeatable TS project baseline so that I can focus on learning the cookbook's patterns without configuration drift.}
\StoryBDD{Happy path}{the workstation has Node/Deno installed and a clean repo is available}{the setup scripts are executed for Node ESM, React (Vite), and Deno}{CI can run type-checks and tests successfully; a README documents the setup and trade-offs}


\begin{TasksBox}{Tasks}
\begin{itemize}
  \item \checkbox\; Create \texttt{/ch01-setup} with \texttt{tsconfig.json} (strict) and \texttt{tsconfig.base.json}.
  \item \checkbox\; Initialize Node ESM project; add Vitest; set \texttt{tsc --noEmit} in CI.
  \item \checkbox\; Scaffold Vite React app; enable TS strict mode; run a sample test.
  \item \checkbox\; Create a minimal Deno example with \texttt{deno.json} and \texttt{deno task}.
  \item \checkbox\; Document module resolution (ESM/CJS), path aliases, and test runner choices.
\end{itemize}
\end{TasksBox}
\end{StoryCard}
\clearpage

\begin{StoryCard}{TC-02 --- Basic Types}
\StoryHeader{TypeScript Cookbook Study}{Model data precisely using primitives, tuples, interfaces/types, and safe unknown handling to prevent runtime class of errors.}{Must}{3}{Backend engineer touching external APIs}{Strict null checks, ESLint + TS, type tests}{Incoming data may be untrusted; avoid \texttt{any}.}{As an engineer, I want to replace loose \texttt{any} usage with \texttt{unknown} + refinements so that misuse is caught at compile time.}
\StoryBDD{Happy path}{a small JSON parsing module exists}{the parser is refactored to use precise tuples and type predicates}{unit tests assert that unsafe access fails to compile while valid paths compile}


\begin{TasksBox}{Tasks}
\begin{itemize}
  \item \checkbox\; Convert an \texttt{any}-based parser to \texttt{unknown} + narrowing functions.
  \item \checkbox\; Model a tuple return type for \texttt{parseUrl()} and update call sites.
  \item \checkbox\; Introduce \texttt{symbol}-keyed registry for plugin lookups.
  \item \checkbox\; Add 10 \texttt{expect-type} assertions proving safe/unsafe paths.
\end{itemize}
\end{TasksBox}
\end{StoryCard}
\clearpage

\begin{StoryCard}{TC-03 --- The Type System}
\StoryHeader{TypeScript Cookbook Study}{Use unions, intersections, discriminated unions, and exhaustiveness checks to model real-world state machines safely.}{Must}{3}{Payments developer}{Test runner, \texttt{assertNever} helper, strictNullChecks}{Future states may be added; enforce exhaustive switches.}{As a payments dev, I want to encode workflow states with discriminated unions so that invalid transitions canâ€™t ship.}
\StoryBDD{Happy path}{a \texttt{Payment} union type is defined}{all reducers and handlers switch on the discriminator}{adding a new state fails compilation until all handlers are updated}


\begin{TasksBox}{Tasks}
\begin{itemize}
  \item \checkbox\; Define \texttt{Payment = Created | Authorized | Captured | Refunded}.
  \item \checkbox\; Implement handlers with \texttt{assertNever} to force exhaustiveness.
  \item \checkbox\; Create a branded \texttt{UserId} nominal type and adapters.
  \item \checkbox\; Add tests that simulate a new state to prove compile-time breakage.
\end{itemize}
\end{TasksBox}
\end{StoryCard}
\clearpage

\begin{StoryCard}{TC-04 --- Generics}
\StoryHeader{TypeScript Cookbook Study}{Generalize utilities while keeping inference ergonomic to reduce duplication and improve DX.}{Must}{3}{Library author}{Generics playground, \texttt{ThisType}, assertion signatures}{Over-generalization hurts inference; keep APIs readable.}{As a library author, I want generic helpers like \texttt{compose()} and typed builders so that consumers get strong inference with minimal annotations.}
\StoryBDD{Happy path}{utility function skeletons exist}{generic constraints and assertion signatures are added}{type tests show correct inference across several call shapes}


\begin{TasksBox}{Tasks}
\begin{itemize}
  \item \checkbox\; Implement \texttt{compose()} and \texttt{mapValues()} with generics.
  \item \checkbox\; Write \texttt{assertIsNonEmptyArray<T>} using assertion signatures.
  \item \checkbox\; Prototype a fluent builder using \texttt{ThisType}.
  \item \checkbox\; Add \texttt{tsd} tests for inference edge cases.
\end{itemize}
\end{TasksBox}
\end{StoryCard}
\clearpage

\begin{StoryCard}{TC-05 --- Conditional Types}
\StoryHeader{TypeScript Cookbook Study}{Transform types using \texttt{infer}, conditional distribution, and never-filtering to model advanced APIs.}{Must}{3}{API designer}{Type utilities workspace}{Conditional types can become unreadable; keep helpers focused.}{As an API designer, I want \texttt{PickByValue}/\texttt{OmitByValue} and shape-sensitive return types so that my APIs adapt to input flags.}
\StoryBDD{Happy path}{base utility types are created}{conditional versions are implemented with \texttt{infer}}{tests prove behavior for unions, \texttt{any}, and \texttt{unknown}}


\begin{TasksBox}{Tasks}
\begin{itemize}
  \item \checkbox\; Implement \texttt{PickByValue<T,V>} and \texttt{OmitByValue<T,V>}.
  \item \checkbox\; Build a flag-sensitive function with conditional return types.
  \item \checkbox\; Create a \texttt{GroupByKind<T>} to partition unions via \texttt{infer}.
  \item \checkbox\; Add edge-case tests for distribution behavior.
\end{itemize}
\end{TasksBox}
\end{StoryCard}
\clearpage

\begin{StoryCard}{TC-06 --- String Template Literal Types}
\StoryHeader{TypeScript Cookbook Study}{Leverage template literal types to type event names, routes, and formatters while extracting parameters safely.}{Must}{3}{Frontend engineer}{Vite React app; router skeleton}{Recursive templates can hit depth limits; keep patterns shallow.}{As a frontend engineer, I want typed event and route keys so that handler payloads and path params are inferred correctly.}
\StoryBDD{Happy path}{event and router modules exist}{template literal types are added for keys and params}{handlers receive inferred payloads/params without casting}


\begin{TasksBox}{Tasks}
\begin{itemize}
  \item \checkbox\; Create \texttt{EventMap} with keys like \texttt{user:created}.
  \item \checkbox\; Implement a \texttt{format()} enforcing named placeholders.
  \item \checkbox\; Model \texttt{/users/:id} to infer \texttt{\{ id: string \}}.
  \item \checkbox\; Type tests proving inference across several routes.
\end{itemize}
\end{TasksBox}
\end{StoryCard}
\clearpage

\begin{StoryCard}{TC-07 --- Variadic Tuple Types}
\StoryHeader{TypeScript Cookbook Study}{Use variadic tuples to type curry/compose and to transform callback-style APIs into promises.}{Must}{3}{Node developer}{Utility lib playground}{Complex parameter lists can confuse inference; keep overloads minimal.}{As a Node dev, I want fully typed \texttt{curry()} and \texttt{Promisify<F>} so that consumers get safe parameter and result inference.}
\StoryBDD{Happy path}{function utilities are scaffolded}{variadic tuple types are applied}{test cases verify parameter splitting and return inference}


\begin{TasksBox}{Tasks}
\begin{itemize}
  \item \checkbox\; Implement \texttt{curry()} supporting multiple arg lengths.
  \item \checkbox\; Write \texttt{Promisify<F>} for Node-style callbacks.
  \item \checkbox\; Derive a union/enum from a tuple of literals.
  \item \checkbox\; Add compile-time assertion tests.
\end{itemize}
\end{TasksBox}
\end{StoryCard}
\clearpage

\begin{StoryCard}{TC-08 --- Helper Types}
\StoryHeader{TypeScript Cookbook Study}{Create reusable helper types to express ``at least one'', ``exactly one'', nested partial/required, and union-to-intersection.}{Must}{3}{Library consumer/author}{Type playground; \texttt{type-fest} for comparison}{Helpers must be documented; prefer well-known names to reduce cognitive load.}{As a library author, I want a small helper set so that teams share a common vocabulary for optionality and exclusivity.}
\StoryBDD{Happy path}{helper skeletons exist}{helpers are implemented and documented}{tests confirm semantics vs \texttt{type-fest} equivalents}


\begin{TasksBox}{Tasks}
\begin{itemize}
  \item \checkbox\; Implement \texttt{AtLeastOne<T>} and \texttt{ExactlyOne<T>}.
  \item \checkbox\; Implement \texttt{DeepPartial<T>} and \texttt{DeepRequired<T>}.
  \item \checkbox\; Add \texttt{UnionToIntersection<U>} with tests.
  \item \checkbox\; Compare ergonomics with \texttt{type-fest} in README.
\end{itemize}
\end{TasksBox}
\end{StoryCard}
\clearpage

\begin{StoryCard}{TC-09 --- Standard Library and External Type Definitions}
\StoryHeader{TypeScript Cookbook Study}{Augment stdlib gaps (e.g., \texttt{Object.keys}) and third-party packages to preserve literal types and improve safety.}{Must}{3}{App developer}{Ambient \texttt{*.d.ts} typings folder, module augmentation example}{Augmentations should be minimal and discoverable.}{As an app dev, I want safe wrappers and augmentations so that key/values and imports retain useful types.}
\StoryBDD{Happy path}{a \texttt{typings} folder exists}{safe \texttt{objectKeys<T>()} wrapper and module augmentation are added}{React can import \texttt{*.svg} with types; unit tests compile}


\begin{TasksBox}{Tasks}
\begin{itemize}
  \item \checkbox\; Write \texttt{objectKeys<T>()} preserving key literals.
  \item \checkbox\; Augment a third-party module to fix a missing type.
  \item \checkbox\; Add \texttt{declare module '*.svg'} and React usage example.
  \item \checkbox\; Add tests demonstrating safer usage vs raw stdlib calls.
\end{itemize}
\end{TasksBox}
\end{StoryCard}
\clearpage

\begin{StoryCard}{TC-10 --- TypeScript and React}
\StoryHeader{TypeScript Cookbook Study}{Type hooks, polymorphic components, contexts, and \texttt{forwardRef} to improve safety and reuse.}{Must}{3}{Frontend engineer working in React}{Vite React app, Storybook (optional)}{Prop generics can overfit; prefer straightforward props where possible.}{As a React engineer, I want typed hooks and components so that consumers get safe props and proper ref types with minimal annotation.}
\StoryBDD{Happy path}{component library skeleton exists}{generic \texttt{forwardRef}, \texttt{useAsync<T>()}, and a polymorphic \texttt{Text} are implemented}{storybook or tests verify prop inference and refs}


\begin{TasksBox}{Tasks}
\begin{itemize}
  \item \checkbox\; Implement \texttt{useAsync<T>()} with discriminated states.
  \item \checkbox\; Create \texttt{List<T>} using \texttt{forwardRef} and render prop.
  \item \checkbox\; Add polymorphic \texttt{Text} that forwards props safely.
  \item \checkbox\; Add prop-level tests and a minimal Storybook.
\end{itemize}
\end{TasksBox}
\end{StoryCard}
\clearpage

\begin{StoryCard}{TC-11 --- Classes}
\StoryHeader{TypeScript Cookbook Study}{Use visibility modifiers, \texttt{override}, strict init, and decorators to build robust class-based utilities.}{Should}{2}{Services engineer}{Decorator experiment (optional), strictPropertyInitialization}{Prefer composition where appropriate; document design choices.}{As a services engineer, I want a typed \texttt{EventEmitter} and safe overrides so that misuse is prevented at compile time.}
\StoryBDD{Happy path}{class skeletons exist}{visibility and override rules are applied; decorator added for timing or memoization}{tests validate behavior and typing}

\begin{TasksBox}{Tasks}
\begin{itemize}
  \item \checkbox\; Implement \texttt{EventEmitter<TMap>} with generic payloads.
  \item \checkbox\; Enforce \texttt{override} on subclass methods.
  \item \checkbox\; Add a method decorator for timing or memoization (optional).
  \item \checkbox\; Document trade-offs vs functional patterns.
\end{itemize}
\end{TasksBox}
\end{StoryCard}
\clearpage

\begin{StoryCard}{TC-12 --- Type Development Strategies}
\StoryHeader{TypeScript Cookbook Study}{Develop a sustainable approach to authoring types, using \texttt{satisfies}, type tests, and runtime validation (e.g., Zod).}{Must}{3}{Library maintainer}{tsd/expect-type, Zod}{Balance type power and maintainability; avoid clever one-offs.}{As a maintainer, I want a small \texttt{@you/ts-utils} package with tests so that types evolve safely with semantic versioning.}
\StoryBDD{Happy path}{a utilities package skeleton exists}{helpers from earlier chapters are consolidated with type tests and Zod schemas}{the package is published locally and documented with a CHANGELOG}

\begin{TasksBox}{Tasks}
\begin{itemize}
  \item \checkbox\; Create \texttt{@you/ts-utils} with 6--8 helpers.
  \item \checkbox\; Add \texttt{tsd} tests and a few Zod schemas.
  \item \checkbox\; Publish to local registry (e.g., Verdaccio) and write CHANGELOG.
  \item \checkbox\; Draft ``when to stop typing'' checklist in README.
\end{itemize}
\end{TasksBox}
\end{StoryCard}
\end{document}
