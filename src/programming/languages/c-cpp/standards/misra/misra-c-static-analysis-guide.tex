\documentclass[11pt,letterpaper]{report}

% ============================================================================
% PACKAGES
% ============================================================================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{titletoc}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{tabularx}
\usepackage{colortbl}
\usepackage{tcolorbox}
\usepackage{enumitem}
\usepackage{parskip}
%\usepackage{microtype}
\usepackage{float}

% ============================================================================
% COLOR DEFINITIONS
% ============================================================================
\definecolor{headerblue}{RGB}{30,58,95}
\definecolor{accentblue}{RGB}{43,87,154}
\definecolor{codebg}{RGB}{245,245,245}
\definecolor{warningbg}{RGB}{255,243,205}
\definecolor{infobg}{RGB}{213,232,240}
\definecolor{tableheader}{RGB}{30,58,95}
\definecolor{linkcolor}{RGB}{0,102,204}
\definecolor{codegreen}{RGB}{40,160,40}
\definecolor{codegray}{RGB}{128,128,128}
\definecolor{codepurple}{RGB}{160,32,240}

% ============================================================================
% HYPERREF SETUP
% ============================================================================
\hypersetup{
    colorlinks=true,
    linkcolor=headerblue,
    filecolor=headerblue,
    urlcolor=linkcolor,
    citecolor=headerblue,
    pdftitle={Open-Source MISRA C Static Analysis Guide},
    pdfauthor={},
    pdfsubject={Static Analysis, MISRA C, Code Quality},
    pdfkeywords={MISRA, C, Static Analysis, Cppcheck, Clang, Semgrep}
}

% ============================================================================
% LISTINGS SETUP FOR CODE
% ============================================================================
\lstdefinestyle{codestyle}{
    backgroundcolor=\color{codebg},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    commentstyle=\color{codegreen},
    keepspaces=true,
    keywordstyle=\color{codepurple}\bfseries,
    numbers=none,
    numbersep=5pt,
    numberstyle=\tiny\color{codegray},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    stringstyle=\color{codepurple},
    tabsize=2,
    frame=single,
    rulecolor=\color{codegray!50},
    xleftmargin=0.5em,
    xrightmargin=0.5em,
    framesep=0.5em,
    framexleftmargin=0.5em,
}

\lstdefinestyle{bashstyle}{
    style=codestyle,
    language=bash,
    morekeywords={sudo,apt-get,pip,npm,cmake,make,git,cppcheck,clang-tidy,semgrep,bear,scan-build},
}

\lstdefinestyle{cstyle}{
    style=codestyle,
    language=C,
    morekeywords={uint8_t,uint16_t,uint32_t,int16_t,int32_t,size_t,status_t,buffer_t,bool},
}

\lstdefinestyle{yamlstyle}{
    style=codestyle,
    morekeywords={rules,id,patterns,pattern,pattern-either,pattern-not,message,languages,severity,metadata,Checks,WarningsAsErrors,CheckOptions,key,value},
    morecomment=[l]{\#},
    morestring=[b]",
    morestring=[b]',
}

\lstset{style=codestyle}

% ============================================================================
% TCOLORBOX ENVIRONMENTS
% ============================================================================
\tcbuselibrary{skins,breakable}

\newtcolorbox{notebox}[1][]{
    colback=warningbg,
    colframe=orange!70!black,
    fonttitle=\bfseries,
    title=#1,
    breakable,
    boxrule=0.5pt,
    arc=2pt,
    left=6pt,
    right=6pt,
    top=6pt,
    bottom=6pt,
}

\newtcolorbox{infobox}[1][]{
    colback=infobg,
    colframe=accentblue,
    fonttitle=\bfseries,
    title=#1,
    breakable,
    boxrule=0.5pt,
    arc=2pt,
    left=6pt,
    right=6pt,
    top=6pt,
    bottom=6pt,
}

% ============================================================================
% TITLE FORMATTING
% ============================================================================
\titleformat{\chapter}[display]
    {\normalfont\huge\bfseries\color{headerblue}}
    {\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titlespacing*{\chapter}{0pt}{-20pt}{40pt}

\titleformat{\section}
    {\normalfont\Large\bfseries\color{accentblue}}
    {\thesection}{1em}{}

\titleformat{\subsection}
    {\normalfont\large\bfseries\color{headerblue!80}}
    {\thesubsection}{1em}{}

\titleformat{\subsubsection}
    {\normalfont\normalsize\bfseries}
    {\thesubsubsection}{1em}{}

% ============================================================================
% HEADER/FOOTER
% ============================================================================
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{\textit{Open-Source MISRA C Static Analysis Guide}}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% ============================================================================
% TABLE SETUP
% ============================================================================
\newcolumntype{L}[1]{>{\raggedright\arraybackslash}p{#1}}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash}p{#1}}

% ============================================================================
% DOCUMENT START
% ============================================================================
\begin{document}

% ============================================================================
% TITLE PAGE
% ============================================================================
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\Huge\bfseries\color{headerblue} Open-Source MISRA C\\[0.3cm] Static Analysis\par}
    
    \vspace{1cm}
    
    {\LARGE\color{accentblue} A Comprehensive Implementation Guide\par}
    
    \vspace{1.5cm}
    
    {\large\itshape Practical Defect Detection, Safer C Coding, and\\Migration Path to Perforce Helix QAC\par}
    
    \vfill
    
    {\large Version 1.0\par}
    {\large January 2026\par}
    
    \vspace{2cm}
\end{titlepage}

% ============================================================================
% TABLE OF CONTENTS
% ============================================================================
\tableofcontents
\newpage

% ============================================================================
% CHAPTER 1: EXECUTIVE SUMMARY
% ============================================================================
\chapter{Executive Summary}

This document provides a comprehensive guide for implementing open-source static analysis tools as a practical alternative to Perforce Helix QAC for MISRA C compliance. The primary focus is on practical defect detection and safer C coding practices, with a clear migration path toward strict, auditable MISRA compliance using commercial tooling.

The recommended open-source stack combines Cppcheck with its MISRA addon, clang-tidy and the Clang Static Analyzer, and Semgrep for custom rule enforcement. This combination provides substantial coverage for common defects and coding standard violations while maintaining low false-positive rates and minimal integration friction.

\begin{notebox}[Key Distinction: Quality Scanning vs. Auditable Compliance]
Open-source tools excel at practical defect detection and coding policy enforcement. However, strict auditable MISRA compliance---with defensible traceability and complete rule coverage---typically requires commercial tooling or a rigorously engineered hybrid approach, partly because the MISRA guidelines themselves are copyrighted and sold.
\end{notebox}

% ============================================================================
% CHAPTER 2: UNDERSTANDING MISRA C
% ============================================================================
\chapter{Understanding MISRA C and Compliance Requirements}

\section{What is MISRA C?}

MISRA C is a set of software development guidelines for the C programming language developed by the Motor Industry Software Reliability Association (MISRA). Originally created for the automotive industry, these guidelines have become the de facto standard for safety-critical embedded systems across aerospace, medical devices, industrial automation, and defense applications.

\subsection{MISRA C Versions}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{@{}>{\columncolor{tableheader}\color{white}\bfseries}L{2.5cm} L{3.5cm} L{7cm}@{}}
\toprule
\rowcolor{tableheader}
\textcolor{white}{\textbf{Version}} & \textcolor{white}{\textbf{C Standard}} & \textcolor{white}{\textbf{Key Characteristics}} \\
\midrule
MISRA C:2012 & C90, C99 & Most widely adopted; 143 rules; Amendment 2 adds C11 support \\
\rowcolor{gray!10}
MISRA C:2023 & C11, C17, C18 & Updated for modern C; improved decidability classification \\
MISRA C:2025 & C23 (expected) & In development; will address C23 features \\
\bottomrule
\end{tabular}
\caption{MISRA C Version Comparison}
\end{table}

\section{Rule Categories and Classifications}

MISRA rules are classified by enforcement level and decidability:

\subsection{Enforcement Categories}

\begin{itemize}[leftmargin=*]
    \item \textbf{Mandatory:} Must be followed without exception. Violations require deviation documentation and approval.
    \item \textbf{Required:} Should be followed unless a documented deviation exists. Most rules fall into this category.
    \item \textbf{Advisory:} Good practice recommendations. Organizations choose which to enforce.
\end{itemize}

\subsection{Decidability Classifications}

\begin{itemize}[leftmargin=*]
    \item \textbf{Decidable:} Can be checked by static analysis with complete precision (no false positives/negatives).
    \item \textbf{Undecidable:} Requires runtime information or is provably impossible to check with complete precision. Tools may report suspected violations.
\end{itemize}

\section{The ``MISRA Isn't Free'' Reality}

Understanding the licensing implications is critical for any MISRA compliance strategy:

\begin{enumerate}[leftmargin=*]
    \item \textbf{Guideline Documents Are Copyrighted and Sold:} The official MISRA C guideline documents must be purchased from \url{https://misra.org.uk/shop/}. Organizations cannot legally distribute rule text.
    
    \item \textbf{Tools Cannot Ship Rule Mappings Verbatim:} Open-source tools like Cppcheck can check behaviors consistent with MISRA but cannot include the actual rule descriptions.
    
    \item \textbf{Audit-Ready Mapping Requires Ownership:} Producing compliance reports that cite specific rules (``Rule X.Y violated because...'') requires legal ownership of the guidelines.
\end{enumerate}

% ============================================================================
% CHAPTER 3: TOOL-BY-TOOL ANALYSIS
% ============================================================================
\chapter{Tool-by-Tool Analysis}

\section{Cppcheck: The Free Baseline}

Cppcheck is an open-source static analysis tool specifically designed for C and C++. It excels at detecting common bug patterns with relatively low friction and ships with a MISRA C:2012 checking addon (\texttt{misra.py}).

\subsection{Strengths}

\begin{itemize}[leftmargin=*]
    \item Low false-positive rate compared to other analyzers
    \item Native MISRA C:2012 addon with partial rule coverage
    \item Fast execution suitable for CI/CD integration
    \item XML and SARIF output formats for tool integration
    \item Active development and community support
\end{itemize}

\subsection{Limitations}

\begin{itemize}[leftmargin=*]
    \item MISRA addon does not include rule texts---you must supply them separately
    \item Partial MISRA rule coverage (explicitly documented)
    \item Limited inter-procedural analysis compared to commercial tools
\end{itemize}

\subsection{Installation}

\begin{lstlisting}[style=bashstyle]
# Ubuntu/Debian
sudo apt-get update
sudo apt-get install cppcheck

# From source (for latest version)
git clone https://github.com/danmar/cppcheck.git
cd cppcheck
mkdir build && cd build
cmake -DCMAKE_BUILD_TYPE=Release ..
cmake --build . -j$(nproc)
sudo cmake --install .

# Verify installation
cppcheck --version
\end{lstlisting}

\subsection{Basic Usage Examples}

Standard analysis with all checks enabled:

\begin{lstlisting}[style=bashstyle]
# Basic analysis of a single file
cppcheck --enable=all --suppress=missingIncludeSystem src/main.c

# Analysis with verbose output
cppcheck --enable=all --verbose src/

# Generate XML report for CI integration
cppcheck --enable=all --xml --xml-version=2 src/ 2> cppcheck-report.xml

# Generate SARIF output (for GitHub Code Scanning)
cppcheck --enable=all --output-format=sarif src/ > cppcheck.sarif
\end{lstlisting}

\subsection{MISRA C:2012 Configuration}

Setting up the MISRA addon requires creating a configuration file that points to your rule text file:

\textbf{misra.json configuration file:}

\begin{lstlisting}[style=codestyle]
{
    "script": "misra.py",
    "args": [
        "--rule-texts=/path/to/misra_rules.txt"
    ]
}
\end{lstlisting}

\textbf{misra\_rules.txt format} (you must create this from the official guidelines):

\begin{lstlisting}[style=codestyle]
Appendix A Summary of guidelines
Rule 1.1 Required
The program shall contain no violations of the standard C syntax
Rule 1.2 Advisory
Language extensions should not be used
Rule 1.3 Required
There shall be no occurrence of undefined or critical unspecified behaviour
...
\end{lstlisting}

\textbf{Running Cppcheck with MISRA addon:}

\begin{lstlisting}[style=bashstyle]
# Basic MISRA check
cppcheck --addon=misra.json --enable=style src/

# MISRA check with specific suppressions
cppcheck --addon=misra.json --enable=style \
    --suppress=misra-c2012-20.9 \
    --suppress=misra-c2012-21.6 \
    src/

# Generate MISRA compliance report
cppcheck --addon=misra.json --enable=style \
    --xml --xml-version=2 src/ 2> misra-report.xml
\end{lstlisting}

\subsection{Cppcheck Suppression File}

Create \texttt{suppressions.txt} for known false positives or documented deviations:

\begin{lstlisting}[style=codestyle]
# suppressions.txt
# Format: [error id]:[filename]:[line]
# Or: [error id]:*:[filename pattern]

# Suppress specific MISRA rule at specific location
misra-c2012-11.3:src/hardware/registers.c:45

# Suppress rule for entire file (documented deviation)
misra-c2012-20.9:*:src/platform/stdio_wrapper.c

# Suppress by pattern
misra-c2012-8.4:*:*_test.c

# Generic suppressions
unusedFunction:src/api/*.c
missingIncludeSystem
\end{lstlisting}

\section{Clang-Tidy and Clang Static Analyzer}

Clang-tidy is a clang-based C++ linter tool that provides deep semantic analysis through the Clang compiler infrastructure. The Clang Static Analyzer extends this with path-sensitive analysis for finding bugs that require tracking program state.

\subsection{Strengths}

\begin{itemize}[leftmargin=*]
    \item Deep semantic understanding through compiler integration
    \item Path-sensitive analysis for complex bug detection
    \item Automatic fix suggestions for many issues
    \item Excellent undefined behavior detection
    \item Integration with \texttt{compile\_commands.json} for accurate analysis
\end{itemize}

\subsection{Installation}

\begin{lstlisting}[style=bashstyle]
# Ubuntu/Debian
sudo apt-get install clang-tools clang-tidy

# macOS
brew install llvm
export PATH="/opt/homebrew/opt/llvm/bin:$PATH"

# Verify installation
clang-tidy --version
clang --analyze --version
\end{lstlisting}

\subsection{Generating compile\_commands.json}

Clang tools work best with a compilation database:

\begin{lstlisting}[style=bashstyle]
# For CMake projects
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ..

# For Make projects using Bear
bear -- make

# For simple projects, create manually
cat > compile_commands.json << 'EOF'
[
    {
        "directory": "/path/to/project",
        "command": "gcc -c -I./include -DDEBUG=1 src/main.c",
        "file": "src/main.c"
    }
]
EOF
\end{lstlisting}

\subsection{Clang-Tidy Configuration}

Create \texttt{.clang-tidy} in your project root:

\begin{lstlisting}[style=yamlstyle]
---
# .clang-tidy configuration for MISRA-informed C development
Checks: >
    -*,
    bugprone-*,
    cert-*,
    clang-analyzer-*,
    cppcoreguidelines-*,
    misc-*,
    modernize-*,
    performance-*,
    portability-*,
    readability-*,
    -readability-magic-numbers,
    -cppcoreguidelines-avoid-magic-numbers,
    -modernize-use-trailing-return-type

WarningsAsErrors: >
    bugprone-undefined-memory-access,
    bugprone-use-after-move,
    clang-analyzer-core.*,
    clang-analyzer-security.*,
    cert-err33-c

HeaderFilterRegex: '.*'

CheckOptions:
  - key: readability-identifier-naming.VariableCase
    value: lower_case
  - key: readability-identifier-naming.FunctionCase
    value: lower_case
  - key: readability-identifier-naming.MacroDefinitionCase
    value: UPPER_CASE
  - key: readability-function-cognitive-complexity.Threshold
    value: '25'
...
\end{lstlisting}

\subsection{Running Clang-Tidy}

\begin{lstlisting}[style=bashstyle]
# Analyze single file
clang-tidy src/main.c -- -I./include -std=c11

# Analyze with compilation database
clang-tidy -p build/ src/main.c

# Analyze all files in project
find src -name '*.c' | xargs clang-tidy -p build/

# Run specific checks only
clang-tidy -checks='-*,bugprone-*,cert-*' src/main.c -- -I./include

# Generate fixes (review before applying)
clang-tidy -fix -fix-errors src/main.c -- -I./include

# Export to YAML for CI processing
clang-tidy -export-fixes=fixes.yaml src/main.c -- -I./include
\end{lstlisting}

\subsection{Clang Static Analyzer}

For deeper path-sensitive analysis:

\begin{lstlisting}[style=bashstyle]
# Analyze single file
clang --analyze -Xanalyzer -analyzer-output=text src/main.c

# Analyze with HTML report generation
scan-build -o ./analyzer-reports make

# Analyze with specific checkers
clang --analyze \
    -Xanalyzer -analyzer-checker=core \
    -Xanalyzer -analyzer-checker=security \
    -Xanalyzer -analyzer-checker=unix \
    -Xanalyzer -analyzer-checker=deadcode \
    src/main.c

# List available checkers
clang --analyze -Xanalyzer -analyzer-checker-help
\end{lstlisting}

\subsection{Relevant Clang-Tidy Checks for MISRA Alignment}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\small
\begin{tabular}{@{}>{\columncolor{tableheader}\color{white}}L{4cm} L{3.5cm} L{5cm}@{}}
\toprule
\rowcolor{tableheader}
\textcolor{white}{\textbf{Clang-Tidy Check}} & \textcolor{white}{\textbf{Related MISRA Area}} & \textcolor{white}{\textbf{Detection Focus}} \\
\midrule
\texttt{bugprone-*} & Rules 1.x, 10.x & Undefined behavior, common mistakes \\
\rowcolor{gray!10}
\texttt{cert-*} & Rules 11.x, 12.x, 21.x & CERT C secure coding \\
\texttt{clang-analyzer-core.*} & Rules 17.x, 18.x & Null deref, memory, division \\
\rowcolor{gray!10}
\texttt{clang-analyzer-security.*} & Rules 21.x & Buffer overflows, format strings \\
\texttt{misc-redundant-expression} & Rules 12.x, 14.x & Dead code, redundant conditions \\
\rowcolor{gray!10}
\texttt{readability-implicit-bool-conversion} & Rules 10.x, 14.x & Essential type violations \\
\bottomrule
\end{tabular}
\caption{Clang-Tidy Checks Mapped to MISRA Categories}
\end{table}

\section{Semgrep: Custom Targeted Checks}

Semgrep is a fast, pattern-based static analysis tool designed for writing custom rules. It excels when you need to enforce organization-specific coding patterns or create targeted MISRA-like checks with fast feedback in CI.

\subsection{Strengths}

\begin{itemize}[leftmargin=*]
    \item Simple, readable rule syntax using code patterns
    \item Very fast execution (suitable for pre-commit hooks)
    \item Excellent for ``must-not-do'' pattern enforcement
    \item Native SARIF output for GitHub/GitLab integration
\end{itemize}

\subsection{Limitations}

\begin{itemize}[leftmargin=*]
    \item Curated C/C++ security rules require Semgrep Pro (paid)
    \item ``Fully free'' approach requires writing/curating your own rules
    \item Pattern-based (not deep semantic analysis)
\end{itemize}

\subsection{Installation}

\begin{lstlisting}[style=bashstyle]
# Using pip (recommended)
pip install semgrep

# Using Homebrew (macOS)
brew install semgrep

# Verify installation
semgrep --version
\end{lstlisting}

\subsection{Custom MISRA-Aligned Rule Examples}

Create \texttt{rules/misra-custom.yaml}:

\begin{lstlisting}[style=yamlstyle]
rules:
  # MISRA C:2012 Rule 11.3 - Cast between pointer types
  - id: misra-c2012-11.3-pointer-cast
    patterns:
      - pattern: ($TYPE *)$EXPR
      - pattern-not: (void *)$EXPR
      - pattern-not: ($TYPE *)NULL
    message: >-
      Potential MISRA C:2012 Rule 11.3 violation: Cast between
      pointer to different object types. Review for type safety.
    languages: [c]
    severity: WARNING
    metadata:
      category: correctness
      misra-rule: "11.3"

  # MISRA C:2012 Rule 14.4 - Boolean controlling expression
  - id: misra-c2012-14.4-non-boolean-condition
    patterns:
      - pattern-either:
          - pattern: if ($X) { ... }
          - pattern: while ($X) { ... }
      - metavariable-pattern:
          metavariable: $X
          patterns:
            - pattern-not: $A == $B
            - pattern-not: $A != $B
            - pattern-not: $A < $B
            - pattern-not: $A > $B
            - pattern-not: $A && $B
            - pattern-not: $A || $B
            - pattern-not: "!$A"
    message: >-
      Potential MISRA C:2012 Rule 14.4 violation: Controlling
      expression should have essentially boolean type.
    languages: [c]
    severity: WARNING

  # MISRA C:2012 Rule 21.3 - Dynamic memory prohibited
  - id: misra-c2012-21.3-dynamic-memory
    pattern-either:
      - pattern: malloc(...)
      - pattern: calloc(...)
      - pattern: realloc(...)
      - pattern: free(...)
    message: >-
      MISRA C:2012 Rule 21.3 violation: Dynamic memory allocation
      functions shall not be used.
    languages: [c]
    severity: ERROR

  # MISRA C:2012 Rule 21.6 - Standard I/O prohibited
  - id: misra-c2012-21.6-stdio
    pattern-either:
      - pattern: printf(...)
      - pattern: fprintf(...)
      - pattern: sprintf(...)
      - pattern: scanf(...)
      - pattern: fscanf(...)
      - pattern: gets(...)
    message: >-
      MISRA C:2012 Rule 21.6 violation: Standard library input/output
      functions shall not be used.
    languages: [c]
    severity: ERROR
\end{lstlisting}

\subsection{Running Semgrep}

\begin{lstlisting}[style=bashstyle]
# Run custom rules
semgrep --config rules/misra-custom.yaml src/

# Run with auto-detection of project rules
semgrep --config auto .

# Generate SARIF output for CI
semgrep --config rules/ --sarif --output semgrep.sarif src/

# Run with verbose output
semgrep --config rules/ --verbose src/

# Exclude test files
semgrep --config rules/ --exclude '*_test.c' --exclude 'test_*.c' src/
\end{lstlisting}

\section{SonarQube: Quality Management Platform}

SonarQube is a powerful quality management platform that provides dashboards, quality gates, and PR decoration. It excels at aggregating findings from multiple sources and tracking quality over time.

\begin{notebox}[Edition-Dependent C/C++ Support]
SonarSource's official C/C++ (CFamily) analyzer availability depends on edition. SonarQube Server documentation states C-family analysis is available starting with Developer Edition. Community Build documentation lists C/C++ as supported, but this may rely on community analyzers. Always validate against your exact SonarQube distribution before positioning it as a C/MISRA solution.
\end{notebox}

\subsection{MISRA Coverage}

SonarSource markets ``100\% MISRA C++:2023 compliance'' specifically for Enterprise/Data Center tiers---this is not an open-source path. For MISRA C coverage in the open-source context, SonarQube primarily serves as an aggregation platform for findings from other tools.

\subsection{Integration Architecture}

Using SonarQube as a findings aggregator:

\begin{lstlisting}[style=bashstyle]
# Run Cppcheck and generate report
cppcheck --addon=misra.json --enable=all \
    --xml --xml-version=2 src/ 2> cppcheck-report.xml

# Run sonar-scanner with external issues
sonar-scanner \
    -Dsonar.projectKey=my-c-project \
    -Dsonar.sources=src \
    -Dsonar.host.url=http://localhost:9000 \
    -Dsonar.cxx.cppcheck.reportPaths=cppcheck-report.xml
\end{lstlisting}

% ============================================================================
% CHAPTER 4: COMPILER WARNINGS
% ============================================================================
\chapter{Compiler Warnings as First Line of Defense}

Before any static analysis tool, the compiler itself is your most important safety check. Configuring strict compiler warnings catches many MISRA-relevant issues at zero additional cost.

\section{GCC Recommended Flags}

\begin{lstlisting}[style=bashstyle]
# Recommended MISRA-aligned GCC flags
CFLAGS += -std=c11                    # Explicit C standard
CFLAGS += -pedantic                   # Strict ISO C compliance
CFLAGS += -Wall                       # Enable common warnings
CFLAGS += -Wextra                     # Enable extra warnings
CFLAGS += -Werror                     # Treat warnings as errors
CFLAGS += -Wconversion                # Implicit conversion warnings
CFLAGS += -Wsign-conversion           # Sign conversion warnings
CFLAGS += -Wcast-align                # Alignment-increasing casts
CFLAGS += -Wstrict-prototypes         # Functions must have prototypes
CFLAGS += -Wmissing-prototypes        # Missing extern declarations
CFLAGS += -Wold-style-definition      # Old-style function definitions
CFLAGS += -Wundef                     # Undefined macro usage
CFLAGS += -Wunused                    # All unused warnings
CFLAGS += -Wuninitialized             # Uninitialized variables
CFLAGS += -Wdouble-promotion          # Float promoted to double
CFLAGS += -Wfloat-equal               # Floating-point equality
CFLAGS += -Wshadow                    # Variable shadowing
CFLAGS += -Wformat=2                  # Printf format checking
CFLAGS += -Wformat-security           # Format string security
CFLAGS += -Wnull-dereference          # Null pointer dereference
CFLAGS += -Wstack-protector           # Stack protection
CFLAGS += -fstack-protector-strong    # Enable stack protection

# Additional safety for undefined behavior detection
CFLAGS += -fsanitize=undefined        # UB sanitizer (debug builds)
CFLAGS += -fno-strict-aliasing        # Disable strict aliasing (safer)
\end{lstlisting}

\section{Clang Recommended Flags}

\begin{lstlisting}[style=bashstyle]
# Recommended MISRA-aligned Clang flags
CFLAGS += -std=c11
CFLAGS += -pedantic
CFLAGS += -Weverything                # Enable ALL warnings
CFLAGS += -Werror

# Disable overly pedantic warnings
CFLAGS += -Wno-padded                 # Structure padding
CFLAGS += -Wno-covered-switch-default # Default in exhaustive switch
CFLAGS += -Wno-disabled-macro-expansion
\end{lstlisting}

\section{Warning Mapping to MISRA Categories}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{@{}>{\columncolor{tableheader}\color{white}}L{3.5cm} L{4cm} L{5cm}@{}}
\toprule
\rowcolor{tableheader}
\textcolor{white}{\textbf{Compiler Warning}} & \textcolor{white}{\textbf{MISRA Category}} & \textcolor{white}{\textbf{Detection Focus}} \\
\midrule
\texttt{-Wconversion} & Rules 10.x (Essential Types) & Implicit type conversions \\
\rowcolor{gray!10}
\texttt{-Wuninitialized} & Rules 9.x (Initialization) & Uninitialized variables \\
\texttt{-Wstrict-prototypes} & Rules 8.x (Declarations) & Function prototype issues \\
\rowcolor{gray!10}
\texttt{-Wformat=2} & Rules 21.x (Standard Library) & Format string security \\
\texttt{-Wshadow} & Rules 5.x (Identifiers) & Variable shadowing \\
\bottomrule
\end{tabular}
\caption{Compiler Warnings Mapped to MISRA Categories}
\end{table}

% ============================================================================
% CHAPTER 5: CI/CD INTEGRATION
% ============================================================================
\chapter{CI/CD Pipeline Integration}

\section{GitHub Actions Complete Workflow}

Create \texttt{.github/workflows/static-analysis.yml}:

\begin{lstlisting}[style=yamlstyle]
name: Static Analysis Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  BUILD_TYPE: Release
  CC: gcc

jobs:
  # Job 1: Compiler Warnings Check
  compiler-warnings:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Build with strict warnings
        run: |
          mkdir -p build && cd build
          cmake .. -DCMAKE_BUILD_TYPE=$BUILD_TYPE \
                   -DCMAKE_C_FLAGS="-Wall -Wextra -Werror -pedantic \
                                    -Wconversion -Wsign-conversion"
          cmake --build . 2>&1 | tee compile.log
          
      - name: Upload compile log
        uses: actions/upload-artifact@v4
        with:
          name: compile-warnings
          path: build/compile.log

  # Job 2: Cppcheck Analysis
  cppcheck:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Cppcheck
        run: |
          sudo apt-get update
          sudo apt-get install -y cppcheck
          
      - name: Run Cppcheck
        run: |
          cppcheck --enable=all \
                   --suppress=missingIncludeSystem \
                   --error-exitcode=1 \
                   --xml --xml-version=2 \
                   -I include/ \
                   src/ 2> cppcheck-report.xml
          
      - name: Run Cppcheck MISRA addon
        continue-on-error: true  # MISRA findings are warnings
        run: |
          cppcheck --addon=misra \
                   --enable=style \
                   --xml --xml-version=2 \
                   -I include/ \
                   src/ 2> cppcheck-misra-report.xml
                   
      - name: Upload Cppcheck reports
        uses: actions/upload-artifact@v4
        with:
          name: cppcheck-reports
          path: |
            cppcheck-report.xml
            cppcheck-misra-report.xml

  # Job 3: Clang-Tidy Analysis
  clang-tidy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Clang tools
        run: |
          sudo apt-get update
          sudo apt-get install -y clang clang-tidy cmake
          
      - name: Generate compilation database
        run: |
          mkdir -p build && cd build
          cmake .. -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
          
      - name: Run clang-tidy
        run: |
          find src -name '*.c' | xargs clang-tidy \
            -p build/ \
            --checks='-*,bugprone-*,cert-*,clang-analyzer-*,misc-*' \
            --warnings-as-errors='clang-analyzer-*,cert-err33-c' \
            2>&1 | tee clang-tidy-report.txt
            
      - name: Upload clang-tidy report
        uses: actions/upload-artifact@v4
        with:
          name: clang-tidy-report
          path: clang-tidy-report.txt

  # Job 4: Semgrep Custom Rules
  semgrep:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: rules/  # Your custom MISRA rules
          generateSarif: true
          
      - name: Upload SARIF to GitHub
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: semgrep.sarif

  # Job 5: Quality Gate
  quality-gate:
    needs: [compiler-warnings, cppcheck, clang-tidy, semgrep]
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        
      - name: Evaluate quality gate
        run: |
          # Count critical findings
          CPPCHECK_ERRORS=$(grep -c '<error' \
            cppcheck-reports/cppcheck-report.xml || echo 0)
          
          echo "Cppcheck errors: $CPPCHECK_ERRORS"
          
          # Fail if critical threshold exceeded
          if [ "$CPPCHECK_ERRORS" -gt 0 ]; then
            echo "Quality gate failed: Critical issues found"
            exit 1
          fi
          
          echo "Quality gate passed"
\end{lstlisting}

\section{GitLab CI Pipeline}

Create \texttt{.gitlab-ci.yml}:

\begin{lstlisting}[style=yamlstyle]
stages:
  - build
  - analyze
  - report

variables:
  GIT_DEPTH: 0

build:
  stage: build
  image: gcc:latest
  script:
    - mkdir -p build && cd build
    - cmake .. -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
    - cmake --build .
  artifacts:
    paths:
      - build/compile_commands.json
    expire_in: 1 hour

cppcheck:
  stage: analyze
  image: neszt/cppcheck-docker:latest
  script:
    - cppcheck --enable=all --xml --xml-version=2
              -I include/ src/ 2> cppcheck-report.xml
  artifacts:
    reports:
      codequality: cppcheck-report.xml
    paths:
      - cppcheck-report.xml
    expire_in: 1 week

clang-tidy:
  stage: analyze
  image: silkeh/clang:latest
  needs: [build]
  script:
    - find src -name '*.c' -exec clang-tidy -p build/ {} \;
        2>&1 | tee clang-tidy-report.txt
  artifacts:
    paths:
      - clang-tidy-report.txt
    expire_in: 1 week

semgrep:
  stage: analyze
  image: returntocorp/semgrep
  script:
    - semgrep --config rules/ --sarif -o semgrep.sarif src/
  artifacts:
    reports:
      sast: semgrep.sarif
    expire_in: 1 week
\end{lstlisting}

\section{Makefile Integration}

For projects using Make:

\begin{lstlisting}[style=bashstyle]
# Makefile targets for static analysis

# Directories
SRC_DIR := src
INC_DIR := include
BUILD_DIR := build
REPORT_DIR := reports

# Source files
SOURCES := $(wildcard $(SRC_DIR)/*.c)

# Ensure report directory exists
$(REPORT_DIR):
	mkdir -p $(REPORT_DIR)

# Run all static analysis
.PHONY: analyze
analyze: cppcheck clang-tidy semgrep
	@echo "All static analysis complete"

# Cppcheck target
.PHONY: cppcheck
cppcheck: $(REPORT_DIR)
	@echo "Running Cppcheck..."
	cppcheck --enable=all \
		--suppress=missingIncludeSystem \
		--xml --xml-version=2 \
		-I $(INC_DIR) \
		$(SRC_DIR) 2> $(REPORT_DIR)/cppcheck.xml

# Cppcheck MISRA addon
.PHONY: cppcheck-misra
cppcheck-misra: $(REPORT_DIR)
	@echo "Running Cppcheck MISRA addon..."
	cppcheck --addon=misra.json \
		--enable=style \
		-I $(INC_DIR) \
		$(SRC_DIR) 2> $(REPORT_DIR)/cppcheck-misra.txt

# Clang-tidy target
.PHONY: clang-tidy
clang-tidy: $(REPORT_DIR) compile_commands.json
	@echo "Running clang-tidy..."
	clang-tidy -p . $(SOURCES) > $(REPORT_DIR)/clang-tidy.txt 2>&1

# Generate compilation database
compile_commands.json:
	bear -- $(MAKE) all

# Semgrep target
.PHONY: semgrep
semgrep: $(REPORT_DIR)
	@echo "Running Semgrep..."
	semgrep --config rules/ --sarif \
		-o $(REPORT_DIR)/semgrep.sarif $(SRC_DIR)

# Clean reports
.PHONY: clean-reports
clean-reports:
	rm -rf $(REPORT_DIR)
\end{lstlisting}

% ============================================================================
% CHAPTER 6: PRACTICAL EXAMPLES
% ============================================================================
\chapter{Practical Defect Detection Examples}

This section demonstrates common defects detected by the open-source tool stack and their MISRA relevance.

\section{Undefined Behavior Detection}

\textbf{Example: Integer overflow (MISRA Rule 12.1)}

\begin{lstlisting}[style=cstyle]
/* Problematic code */
#include <stdint.h>

uint16_t calculate_checksum(uint8_t *data, size_t len) {
    uint16_t sum = 0;
    for (size_t i = 0; i < len; i++) {
        sum += data[i];  /* Potential overflow not handled */
    }
    return sum;
}

/* Tool detection:
 * Cppcheck: [style] Variable 'sum' is assigned in a loop
 * clang-tidy: bugprone-implicit-widening-of-multiplication
 */

/* MISRA-compliant version */
uint16_t calculate_checksum_safe(const uint8_t *data, size_t len) {
    uint32_t sum = 0U;  /* Use wider type for accumulation */
    for (size_t i = 0U; i < len; i++) {
        sum += (uint32_t)data[i];
        if (sum > UINT16_MAX) {
            sum = sum & 0xFFFFU;  /* Wrap explicitly */
        }
    }
    return (uint16_t)(sum & 0xFFFFU);
}
\end{lstlisting}

\section{Pointer Safety Issues}

\textbf{Example: Null pointer dereference (MISRA Rules 11.x, 18.x)}

\begin{lstlisting}[style=cstyle]
/* Problematic code */
void process_buffer(buffer_t *buf) {
    size_t len = buf->length;  /* Potential null dereference */
    
    memcpy(buf->data, source, len);
}

/* Tool detection:
 * clang-analyzer: Dereference of null pointer (loaded from 'buf')
 * Cppcheck: [warning] Possible null pointer dereference: buf
 */

/* MISRA-compliant version */
status_t process_buffer_safe(buffer_t *buf) {
    status_t result = STATUS_ERROR;
    
    if (buf != NULL) {
        if (buf->data != NULL) {
            size_t len = buf->length;
            if (len <= BUFFER_MAX_SIZE) {
                (void)memcpy(buf->data, source, len);
                result = STATUS_OK;
            }
        }
    }
    
    return result;
}
\end{lstlisting}

\section{Type Conversion Issues}

\textbf{Example: Implicit conversion (MISRA Rules 10.x)}

\begin{lstlisting}[style=cstyle]
/* Problematic code */
void set_timer(uint32_t milliseconds) {
    int16_t timer_value = milliseconds / 10;  /* Truncation */
    hardware_timer_set(timer_value);
}

/* Tool detection:
 * GCC -Wconversion: conversion from 'uint32_t' to 'int16_t'
 *                   may change value
 * clang-tidy: bugprone-narrowing-conversions
 * Cppcheck MISRA: misra-c2012-10.3 - Value assigned to narrower type
 */

/* MISRA-compliant version */
#define TIMER_MAX_VALUE ((uint16_t)0xFFFFU)

status_t set_timer_safe(uint32_t milliseconds) {
    status_t result;
    uint32_t scaled = milliseconds / 10U;
    
    if (scaled <= (uint32_t)TIMER_MAX_VALUE) {
        uint16_t timer_value = (uint16_t)scaled;
        hardware_timer_set(timer_value);
        result = STATUS_OK;
    } else {
        result = STATUS_OVERFLOW;
    }
    
    return result;
}
\end{lstlisting}

\section{Control Flow Issues}

\textbf{Example: Unreachable code and dead code (MISRA Rules 2.x, 14.x)}

\begin{lstlisting}[style=cstyle]
/* Problematic code */
int32_t get_state(void) {
    int32_t state = read_hardware_register();
    
    if (state >= 0) {
        return state;
    } else if (state < 0) {
        return -1;
    }
    
    return 0;  /* Unreachable code */
}

/* Tool detection:
 * clang-analyzer: This statement is never executed
 * Cppcheck: [style] Condition 'state<0' is always true
 */

/* MISRA-compliant version */
int32_t get_state_safe(void) {
    int32_t state = read_hardware_register();
    int32_t result;
    
    if (state >= 0) {
        result = state;
    } else {
        result = -1;
    }
    
    return result;  /* Single point of exit */
}
\end{lstlisting}

% ============================================================================
% CHAPTER 7: MIGRATION PATH
% ============================================================================
\chapter{Migration Path to Perforce Helix QAC}

This section outlines the strategic migration from open-source tooling to Perforce Helix QAC for strict, auditable MISRA compliance.

\section{Why Migrate to Helix QAC?}

\begin{itemize}[leftmargin=*]
    \item \textbf{Complete MISRA Rule Coverage:} Helix QAC provides comprehensive coverage of all MISRA C:2012/2023 rules, including decidable and undecidable rules with sophisticated analysis.
    
    \item \textbf{Auditable Compliance Reports:} Generate compliance matrices with rule text citations acceptable to certification bodies and auditors.
    
    \item \textbf{Deviation Management:} Structured workflow for documenting and approving rule deviations required for certification.
    
    \item \textbf{Dataflow Analysis:} Deep inter-procedural analysis for undecidable rules that open-source tools cannot fully address.
    
    \item \textbf{Certification Support:} Tool qualification packs for ISO 26262, IEC 61508, DO-178C, and other safety standards.
\end{itemize}

\section{Phased Migration Strategy}

\subsection{Phase 1: Foundation (Current State)}

Establish baseline quality with open-source tools:

\begin{enumerate}[leftmargin=*]
    \item Implement strict compiler warnings as errors
    \item Deploy Cppcheck with MISRA addon for partial coverage
    \item Configure clang-tidy for semantic analysis
    \item Create Semgrep rules for critical patterns
    \item Establish CI/CD pipeline with quality gates
    \item Document all findings and suppressions
\end{enumerate}

\subsection{Phase 2: Stabilization}

Achieve zero-tolerance baseline:

\begin{enumerate}[leftmargin=*]
    \item Resolve all critical findings from Phase 1
    \item Create formal deviation documentation for suppressed items
    \item Purchase official MISRA guidelines documentation
    \item Map open-source findings to specific MISRA rules
    \item Establish coding standard document based on enforced rules
\end{enumerate}

\subsection{Phase 3: Helix QAC Pilot}

Evaluate commercial tool on subset of codebase:

\begin{enumerate}[leftmargin=*]
    \item Select representative module for pilot analysis
    \item Run Helix QAC parallel to open-source tools
    \item Compare findings to identify coverage gaps
    \item Evaluate false-positive rates between tools
    \item Assess compliance report quality for audit requirements
\end{enumerate}

\subsection{Phase 4: Full Deployment}

Transition to Helix QAC as primary tool:

\begin{enumerate}[leftmargin=*]
    \item Deploy Helix QAC across entire codebase
    \item Integrate into CI/CD pipeline (replace or augment)
    \item Establish baseline and suppress legacy issues with deviations
    \item Configure quality gates for new code
    \item Retain open-source tools as secondary checks
\end{enumerate}

\section{Mapping Open-Source Findings to Helix QAC}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{@{}>{\columncolor{tableheader}\color{white}}L{4cm} L{3.5cm} L{5cm}@{}}
\toprule
\rowcolor{tableheader}
\textcolor{white}{\textbf{Open-Source Tool}} & \textcolor{white}{\textbf{Helix QAC Equivalent}} & \textcolor{white}{\textbf{Migration Notes}} \\
\midrule
Cppcheck MISRA addon & QAC MISRA module & Full rule coverage with dataflow \\
\rowcolor{gray!10}
clang-tidy bugprone-* & QAC core analysis & Enhanced path sensitivity \\
Semgrep custom rules & QAC user messages & Port patterns to QAC format \\
\rowcolor{gray!10}
Compiler warnings & Retain in parallel & Keep as first-line defense \\
\bottomrule
\end{tabular}
\caption{Open-Source to Helix QAC Mapping}
\end{table}

% ============================================================================
% CHAPTER 8: DOCUMENTATION AND COMPLIANCE
% ============================================================================
\chapter{Documentation and Compliance Claiming}

\section{What You Can Claim}

With the open-source tool stack, appropriate claims include:

\begin{itemize}[leftmargin=*]
    \item \textit{``MISRA-informed static analysis and coding-policy enforcement''}
    \item \textit{``Partial automated checking against MISRA C:2012 via Cppcheck addon''}
    \item \textit{``Static analysis coverage for common defects and safety issues''}
\end{itemize}

\section{What You Cannot Claim (Without Commercial Tooling)}

\begin{itemize}[leftmargin=*]
    \item ``MISRA Compliant'' without defensible compliance argument
    \item Full rule coverage percentages
    \item Auditor-ready compliance matrices citing specific rule text
\end{itemize}

\section{Deviation Documentation Template}

When suppressing findings, document deviations properly:

\begin{lstlisting}[style=cstyle]
/* DEVIATION: MISRA C:2012 Rule 11.3
 * 
 * Location: src/hardware/registers.c:45
 * Deviation ID: DEV-2024-0042
 * 
 * Rule Text: A cast shall not be performed between a pointer to
 *            object type and a pointer to a different object type.
 * 
 * Rationale: Hardware register access requires casting volatile
 *            uint32_t* to specific register structure types. The
 *            memory-mapped addresses are documented in the hardware
 *            reference manual and alignment is guaranteed.
 * 
 * Risk Assessment: Low. The cast preserves alignment and the
 *                  register structures match hardware layout.
 * 
 * Approved By: [Name], [Date]
 * Review ID: [Code Review Reference]
 */
\end{lstlisting}

\section{Alternative Standard: Barr Group Embedded C}

If the primary driver is ``safer embedded C practices'' rather than contractual MISRA compliance, the Barr Group Embedded C Coding Standard is a commonly referenced alternative that can be used as a policy baseline. This standard is freely available and provides practical guidelines without the licensing considerations of MISRA.

% ============================================================================
% CHAPTER 9: SUMMARY
% ============================================================================
\chapter{Summary and Recommendations}

\section{Recommended Open-Source Stack}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{@{}>{\columncolor{tableheader}\color{white}}C{1.2cm} L{5cm} L{6cm}@{}}
\toprule
\rowcolor{tableheader}
\textcolor{white}{\textbf{Layer}} & \textcolor{white}{\textbf{Tool}} & \textcolor{white}{\textbf{Purpose}} \\
\midrule
1 & Compiler warnings (\texttt{-Wall -Wextra -Werror}) & First-line defense, zero additional cost \\
\rowcolor{gray!10}
2 & clang-tidy + Clang Static Analyzer & Deep semantic and path-sensitive analysis \\
3 & Cppcheck + misra.py addon & MISRA-specific checks, additional defect classes \\
\rowcolor{gray!10}
4 & Semgrep (custom rules) & Organization-specific ``must-not-do'' patterns \\
\bottomrule
\end{tabular}
\caption{Recommended Open-Source Tool Stack}
\end{table}

\section{Key Takeaways}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Open-source tools provide substantial value} for practical defect detection and safer C coding, but have limitations for auditable compliance.
    
    \item \textbf{The MISRA guidelines themselves are copyrighted}---plan for this when establishing compliance claims.
    
    \item \textbf{A phased migration approach} allows you to build quality foundations now while planning for commercial tooling later.
    
    \item \textbf{Perforce Helix QAC} is the recommended target for strict, auditable MISRA compliance with certification support.
    
    \item \textbf{Document everything}---deviation records, tool configurations, and suppression rationales are essential for any compliance program.
\end{enumerate}

% ============================================================================
% APPENDIX A: REFERENCES
% ============================================================================
\appendix
\chapter{References}

\begin{enumerate}[leftmargin=*]
    \item MISRA Guidelines: \url{https://misra.org.uk/shop/}
    \item Cppcheck Manual: \url{https://cppcheck.sourceforge.io/manual.html}
    \item Clang-Tidy Documentation: \url{https://clang.llvm.org/extra/clang-tidy/}
    \item Semgrep Documentation: \url{https://semgrep.dev/docs/}
    \item SonarQube Documentation: \url{https://docs.sonarsource.com/}
    \item Barr Group Embedded C Coding Standard: \url{https://barrgroup.com/embedded-systems/books/embedded-c-coding-standard}
    \item Perforce Helix QAC: \url{https://www.perforce.com/products/helix-qac}
\end{enumerate}

\end{document}
