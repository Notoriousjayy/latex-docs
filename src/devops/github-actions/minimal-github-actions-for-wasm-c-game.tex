%========================================================
% Comprehensive-Minimal GitHub Actions for a WASM C Game
% Tailored to: notoriousjayy-wasm (C + Emscripten/WebGL2)
%========================================================
\documentclass[11pt]{article}

% ---------- Encoding & layout ----------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}
\setstretch{1.08}

% ---------- Colors & links ----------
\usepackage{xcolor}
\definecolor{ink}{HTML}{111827}      % gray-900
\definecolor{soft}{HTML}{F9FAFB}     % gray-50
\definecolor{accent}{HTML}{2563EB}   % blue-600
\usepackage[colorlinks=true,linkcolor=accent,citecolor=accent,urlcolor=accent]{hyperref}
% ---------- Silence first-run .toc warnings (latexmk treats them as missing input) ----------
\usepackage{etoolbox}
\makeatletter
\patchcmd{\@starttoc}
  {\InputIfFileExists{\jobname.#1}{}{\typeout{No file \jobname.#1.}}}
  {\InputIfFileExists{\jobname.#1}{}{}}
  {}{}
\makeatother
% ---------- End .toc silence ----------
\usepackage{xurl}

% ---------- Math (for \text) ----------
\usepackage{amsmath}

% ---------- Code blocks ----------
% NOTE: compile with: latexmk -pdf -shell-escape main.tex
% ---------- Minted compatibility layer (CI-safe) ----------
% This document can render code with minted when -shell-escape is enabled, and
% falls back to listings when it is not (so CI builds do not hard-fail).
\newif\ifUseMinted
\UseMintedfalse
\begingroup
\ifdefined\pdfshellescape
  \ifnum\pdfshellescape=1\relax
    \global\UseMintedtrue
  \fi
\fi
\endgroup

\ifUseMinted
  \usepackage[newfloat]{minted}
\else
  \usepackage{listings}
  \usepackage{xcolor}
  \usepackage{newfloat}
  \usepackage{fancyvrb} % provides \VerbatimEnvironment used by some wrappers

  % Provide a "listing" float compatible with minted's newfloat option
  \makeatletter
  \@ifundefined{c@listing}{%
    \DeclareFloatingEnvironment[name=Listing]{listing}
  }{}
  \makeatother

  % Minimal language definitions for common "minted" lexers / labels used in docs.
  % These are intentionally lightweight; they exist primarily to avoid build failures.
  \lstdefinelanguage{yaml}{
    sensitive=true,
    morecomment=[l]{\#},
    morestring=[b]",
    morestring=[b]',
  }
  \lstdefinelanguage{json}{
    sensitive=true,
    morestring=[b]",
    showstringspaces=false,
  }
  \lstdefinelanguage{ini}{
    sensitive=true,
    morecomment=[l]{;},
    morecomment=[l]{\#},
    morestring=[b]",
    morestring=[b]',
  }
  \lstdefinelanguage{cmake}{
    sensitive=true,
    morecomment=[l]{\#},
    morestring=[b]",
    morestring=[b]',
  }
  \lstdefinelanguage{powershell}{
    sensitive=true,
    morecomment=[l]{\#},
    morestring=[b]",
    morestring=[b]',
    morekeywords={param,begin,process,end,function,filter,return,if,elseif,else,foreach,for,while,do,until,break,continue,try,catch,finally,throw,switch},
  }
  \lstdefinelanguage{bash}{
    sensitive=true,
    morecomment=[l]{\#},
    morestring=[b]",
    morestring=[b]',
    morekeywords={if,then,else,elif,fi,for,do,done,while,in,case,esac,function,local,return,export,unset,echo,printf,read,cd,exit},
  }
  \lstdefinelanguage{sh}{sensitive=true, morecomment=[l]{\#}, morestring=[b]", morestring=[b]'}
  \lstdefinelanguage{shell}{sensitive=true, morecomment=[l]{\#}, morestring=[b]", morestring=[b]'}
  \lstdefinelanguage{console}{sensitive=false}
  \lstdefinelanguage{terminal}{sensitive=false}
  \lstdefinelanguage{md}{sensitive=false}
  \lstdefinelanguage{markdown}{sensitive=false}
  \lstdefinelanguage{text}{sensitive=false}

  % Reasonable defaults; keep this conservative to avoid surprises.
  \lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    upquote=true,
    frame=single,
    framerule=0.2pt,
    aboveskip=0.75\baselineskip,
    belowskip=0.75\baselineskip,
    % Common Unicode glyphs seen in snippets
    literate=
      {•}{{\textbullet}}1
      {—}{{---}}1
      {–}{{--}}1
      {→}{{$\rightarrow$}}1
      {←}{{$\leftarrow$}}1
      {≥}{{$\ge$}}1
      {≤}{{$\le$}}1
  }

  % Minted command shims (ignore style/options in fallback)
  \providecommand{\usemintedstyle}[1]{}
  \providecommand{\setminted}[1]{}
  \providecommand{\setmintedinline}[1]{}

  % NOTE: minted's optional key-value options are not 1:1 with listings'
  % key-value options. To avoid hard failures, we intentionally ignore the
  % optional options argument in the fallback path.

  % minted: \begin{minted}[<opts>]{<lang>} ... \end{minted}
  \lstnewenvironment{minted}[2][]%
    {\lstset{language=#2}}%
    {}

  % minted: \inputminted[<opts>]{<lang>}{<file>}
  \newcommand{\inputminted}[3][]{\lstinputlisting[language=#2]{#3}}

  % minted: \mintinline{<lang>}{<code>}
  \newcommand{\mintinline}[2]{\texttt{#2}}

  % minted: \newminted[<envname>]{<lang>}{<opts>}
  \newcommand{\newminted}[3][]{%
    \def\MintedEnvName{#1}%
    \if\relax\detokenize{#1}\relax
      \edef\MintedEnvName{#2code}%
    \fi
    \expandafter\lstnewenvironment\expandafter{\MintedEnvName}[1][]%
      {\lstset{language=#2}}%
      {}%
  }

  % minted: \newmintedfile{<lang>}{<opts>} -> \input<lang>{file}
  \newcommand{\newmintedfile}[2]{%
    \expandafter\newcommand\csname input#1\endcsname[2][]{\lstinputlisting[language=#1]{##2}}%
  }

  % minted exposes \listoflistings; keep it defined for compatibility
  \providecommand{\listoflistings}{\listof{listing}{List of Listings}}
\fi
% ---------- End minted compatibility layer ----------
\usepackage{fvextra}
\usepackage{upquote}
\setminted{
  fontsize=\footnotesize,
  breaklines=true,
  breakanywhere=true,
  tabsize=2,
  encoding=utf8
}
\newminted{yaml}{}
\newminted{bash}{}
\newminted{cmake}{}
\newminted{json}{}
\newminted{text}{}
\newminted{ini}{}
\newminted{c}{}

\title{\textbf{Comprehensive-Minimal GitHub Actions for a WASM C Game}}
\author{Emscripten + WebGL2 + CMake Presets (repo-tailored)}
\date{\today}

\begin{document}
\maketitle


\begingroup
\setcounter{tocdepth}{2}
\tableofcontents
\endgroup

\section*{Executive Summary}

\section*{Quick Start}

\subsection*{Diagnostics workflow (optional)}
Use a lightweight job to print versions and confirm Emscripten is installed:
\begin{yamlcode}
name: Diagnostics
on: [workflow_dispatch]
jobs:
  envcheck:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: mymindstorm/setup-emsdk@v14
      - run: |
          emcc --version
          cmake --version
          ninja --version || true
\end{yamlcode}
\begin{enumerate}
  \item Ensure you have a \texttt{CMakePresets.json} with a \texttt{wasm-debug} configure preset that outputs to \texttt{build-wasm}.
  \item Push a branch: the \emph{Build \& Test} workflow compiles with Emscripten and caches dependencies.
  \item Open a PR: \emph{Dependency Review} and \emph{CodeQL} run as guardrails.
  \item Merge to \texttt{main}: \emph{Deploy to GitHub Pages} publishes a playable demo.
  \item Create a tag (e.g., \texttt{v0.1.0}): \emph{Release} packages WebAssembly assets for distribution.
\end{enumerate}
This guide delivers a cohesive, production-ready CI/CD baseline for a C/WebGL2 game compiled to WebAssembly via Emscripten. It is tailored for repositories that use \texttt{CMakePresets.json} with a \texttt{wasm-debug} configure preset that outputs to \texttt{build-wasm}. The workflows form a minimal-yet-complete pipeline:
\begin{itemize}
  \item \textbf{Build \& Test}: Compile with Emscripten and your CMake preset, producing reproducible WebAssembly assets.
  \item \textbf{CodeQL (C/C++)}: Add SAST for C/C++ to catch correctness and security issues in CI.
  \item \textbf{Dependency Review}: Guard PRs by flagging risky transitive changes.
  \item \textbf{Deploy to GitHub Pages}: Publish the \texttt{build-wasm} output for playtesting.
  \item \textbf{Release on tags}: Package build artifacts as downloadable assets.
\end{itemize}
The result is a pragmatic path from commit to playable demo to versioned releases, with security checks and dependency risk controls built in.

\section*{Goal}

\section*{Prerequisites}
Before running the workflows, make sure the essentials are in place:
\begin{itemize}
  \item \textbf{Emscripten SDK}: Installed and available on the runner via \texttt{emsdk}. Use the latest stable tools.
  \item \textbf{CMake presets}: A \texttt{CMakePresets.json} with a \texttt{wasm-debug} configure preset that generates to \texttt{build-wasm}.
  \item \textbf{CI resources}: GitHub Actions enabled with permissions to read repository contents and write Pages/Deployments.
  \item \textbf{Security scanning}: If you use CodeQL, ensure the repository or org has GitHub Advanced Security enabled.
  \item \textbf{Pages (optional)}: If you plan to publish a playable demo, enable GitHub Pages (build from GitHub Actions).
\end{itemize}

Ship a comprehensive-minimal CI/CD set for your WebAssembly (WASM) \textbf{C} game using Emscripten + WebGL2, matching your repository layout and CMake presets. We provide five production-ready GitHub Actions workflows:
\begin{itemize}
  \item Build \& Test (Emscripten + \texttt{wasm-debug} preset → \texttt{build-wasm})
  \item CodeQL (C/C++)
  \item Dependency Review (PR guardrail)
  \item Deploy to GitHub Pages (publish \texttt{build-wasm})
  \item Release on tags (zip \texttt{build-wasm} assets)
\end{itemize}

\paragraph{How to compile this PDF}
\begin{bashcode}
latexmk -pdf -shell-escape main.tex
\end{bashcode}

\section{Your repository layout (ASCII-safe)}
\begin{textcode}
notoriousjayy-wasm/
|-- readme.md
|-- CMakeLists.txt
|-- CMakePresets.json
|-- package.json
|-- html_template/
|   `-- index.html
|-- include/
|   `-- testProject/
|       |-- module.h
|       `-- render.h
`-- src/
    |-- main.c
    |-- module.c
    `-- render.c
\end{textcode}

\section{Build strategy (tailored)}
\subsection*{Tunable Parameters}
\begin{itemize}
  \item \textbf{Preset name}: Switch from \texttt{wasm-debug} to \texttt{wasm-release} for optimized bundles.
  \item \textbf{Cache keys}: Include \texttt{runner.os}, preset name, \texttt{CMakeLists.txt} hash.
  \item \textbf{Artifact names}: Unify across workflows (e.g., \texttt{build-wasm}).
  \item \textbf{Pages directory}: If your web assets live under \texttt{web/}, set the publish path accordingly.
  \item \textbf{CodeQL query packs}: Add security-focused packs or narrow scope via \texttt{.codeql/config.yml}.
\end{itemize}

Your README and presets expect \texttt{emcmake} and the \texttt{wasm-debug} preset; the binary dir is \texttt{build-wasm}. The CMake project emits \texttt{index.html}, \texttt{index.js}, \texttt{index.wasm} (output name \texttt{index}) and will use \texttt{html\_template/index.html} if present (it already includes the \texttt{\{\{\{ SCRIPT \}\}\}} placeholder). We mirror this in CI.

\subsection*{Local dev (reference)}
\begin{bashcode}
# Emscripten SDK (once)
git clone https://github.com/emscripten-core/emsdk.git ~/emsdk
cd ~/emsdk && ./emsdk install latest && ./emsdk activate latest
source ~/emsdk/emsdk_env.sh

# Configure and build (matching README)
emcmake cmake --preset wasm-debug
cmake --build --preset wasm-debug

# Serve locally from the build dir
cmake --build --preset wasm-debug --target serve
# Open http://localhost:8000/
\end{bashcode}

\section{Workflow 1: Build \& Test (Emscripten + CMake preset)}
\emph{This step continues the pipeline, building on the outputs of earlier workflows.}


\begin{yamlcode}
# .github/workflows/build-wasm.yml
name: Build (WASM C)
on:
  push: { branches: [main] }
  pull_request: { branches: [main] }

permissions:
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      EMSDK: ${{ runner.temp }}/emsdk

    steps:
      - uses: actions/checkout@v4

      - name: Install Emscripten
        shell: bash
        run: |
          git clone https://github.com/emscripten-core/emsdk.git "$EMSDK"
          "$EMSDK/emsdk" install latest
          "$EMSDK/emsdk" activate latest
          echo "EMSDK=$EMSDK" >> $GITHUB_ENV
          source "$EMSDK/emsdk_env.sh"
          emcc --version

      - name: Cache Emscripten build cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.emscripten_cache
            ${{ env.EMSDK }}/upstream/emscripten/cache
          key: emsdk-${{ runner.os }}-latest

      - name: Configure (emcmake + preset wasm-debug)
        shell: bash
        run: |
          source "$EMSDK/emsdk_env.sh"
          emcmake cmake --preset wasm-debug

      - name: Build
        shell: bash
        run: cmake --build --preset wasm-debug -j2

      # No tests yet; keep as a future hook
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: wasm-build
          path: |
            build-wasm/index.html
            build-wasm/index.js
            build-wasm/index.wasm
\end{yamlcode}

\section{Workflow 2: CodeQL (C/C++)}
\emph{This step continues the pipeline, building on the outputs of earlier workflows.}


If \texttt{autobuild} cannot infer a build, reuse the emsdk + preset steps before analyze (shown commented).
\begin{yamlcode}
# .github/workflows/codeql.yml
name: CodeQL (C/C++)
on:
  push: { branches: [main] }
  pull_request: { branches: [main] }
  schedule: [{ cron: "0 6 * * 1" }]

permissions:
  contents: read
  security-events: write

jobs:
  analyze:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: github/codeql-action/init@v3
        with:
          languages: cpp  # covers C and C++

      - uses: github/codeql-action/autobuild@v3

      # If autobuild fails, uncomment and use your exact wasm build:
      # - name: Build (Emscripten, same as CI)
      #   shell: bash
      #   run: |
      #     EMSDK="$RUNNER_TEMP/emsdk"
      #     git clone https://github.com/emscripten-core/emsdk.git "$EMSDK"
      #     "$EMSDK/emsdk" install latest
      #     "$EMSDK/emsdk" activate latest
      #     source "$EMSDK/emsdk_env.sh"
      #     emcmake cmake --preset wasm-debug
      #     cmake --build --preset wasm-debug -j2

      - uses: github/codeql-action/analyze@v3
\end{yamlcode}

\section{Workflow 3: Dependency Review}
\emph{This step continues the pipeline, building on the outputs of earlier workflows.}


\begin{yamlcode}
# .github/workflows/dependency-review.yml
name: Dependency Review
on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read

jobs:
  review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/dependency-review-action@v4
\end{yamlcode}

\section{Workflow 4: Deploy to GitHub Pages}
\emph{This step continues the pipeline, building on the outputs of earlier workflows.}


We build with the wasm preset and publish \texttt{build-wasm} as the Pages artifact. Your custom HTML shell in \texttt{html\_template/index.html} will be used automatically because CMake passes \texttt{--shell-file} when it exists.
\begin{yamlcode}
# .github/workflows/pages.yml
name: Deploy (GitHub Pages)
on:
  push: { branches: [main] }

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      EMSDK: ${{ runner.temp }}/emsdk

    steps:
      - uses: actions/checkout@v4

      - name: Install Emscripten
        shell: bash
        run: |
          git clone https://github.com/emscripten-core/emsdk.git "$EMSDK"
          "$EMSDK/emsdk" install latest
          "$EMSDK/emsdk" activate latest
          echo "EMSDK=$EMSDK" >> $GITHUB_ENV
          source "$EMSDK/emsdk_env.sh"

      - name: Configure & build (emcmake + preset)
        run: |
          emcmake cmake --preset wasm-debug
          cmake --build --preset wasm-debug -j2
          test -f build-wasm/index.html

      - name: Configure Pages
        uses: actions/configure-pages@v5

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: build-wasm

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - id: deployment
        uses: actions/deploy-pages@v4
\end{yamlcode}

\section{Workflow 5: Release on tags (zip build-wasm)}
\emph{This step continues the pipeline, building on the outputs of earlier workflows.}


\begin{yamlcode}
# .github/workflows/release.yml
name: Release
on:
  push:
    tags: ['v*.*.*']

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    env:
      EMSDK: ${{ runner.temp }}/emsdk

    steps:
      - uses: actions/checkout@v4

      - name: Install Emscripten
        shell: bash
        run: |
          git clone https://github.com/emscripten-core/emsdk.git "$EMSDK"
          "$EMSDK/emsdk" install latest
          "$EMSDK/emsdk" activate latest
          source "$EMSDK/emsdk_env.sh"

      - name: Build (emcmake + preset)
        run: |
          emcmake cmake --preset wasm-debug
          cmake --build --preset wasm-debug -j2
          (cd build-wasm && zip -r ../game-wasm.zip .)

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: game-wasm.zip
\end{yamlcode}

\section{Optional: add a Release preset for size/perf}
If you want a production-optimized build, extend \texttt{CMakePresets.json} with a \texttt{wasm-release} preset (still using \texttt{emcmake} in CI):
\begin{jsoncode}
{
  "version": 5,
  "cmakeMinimumRequired": { "major": 3, "minor": 20 },
  "configurePresets": [
    {
      "name": "wasm-debug",
      "displayName": "Emscripten / Debug",
      "generator": "Ninja",
      "binaryDir": "build-wasm",
      "cacheVariables": { "CMAKE_BUILD_TYPE": "Debug" }
    },
    {
      "name": "wasm-release",
      "displayName": "Emscripten / Release",
      "generator": "Ninja",
      "binaryDir": "build-wasm",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release"
      }
    }
  ],
  "buildPresets": [
    { "name": "wasm-debug",   "configurePreset": "wasm-debug" },
    { "name": "wasm-release", "configurePreset": "wasm-release" }
  ]
}
\end{jsoncode}

Then update the workflows’ build steps to use \texttt{wasm-release} for deploy and release jobs.

\section{Notes and repo-specific tips}
\begin{itemize}
  \item \textbf{Custom shell}: your \texttt{html\_template/index.html} already includes \texttt{\{\{\{ SCRIPT \}\}\}}, so the generated JS is injected correctly.
  \item \textbf{Exports}: CMake sets \texttt{-sEXPORTED\_FUNCTIONS=['\_main','\_initWebGL','\_startMainLoop','\_myFunction']} and runtime methods \texttt{ccall,cwrap}, so DevTools calls like \texttt{Module.ccall('myFunction', ...)} work out of the box.
  \item \textbf{Artifacts}: Pages and Release jobs upload the entire \texttt{build-wasm} directory to preserve all outputs (\texttt{index.html/js/wasm}).
  \item \textbf{Cache}: caching \texttt{\~{}/.emscripten\_cache} and \texttt{upstream/emscripten/cache} speeds up builds.
  \item \textbf{Local serve target}: \texttt{cmake --build --preset wasm-debug --target serve} starts \texttt{python3 -m http.server} bound to \texttt{SERVE\_HOST:SERVE\_PORT} configured in CMake.
\end{itemize}


% ========================================================
\section{Gaps \& Risks Addressed \& Implemented Updates}
% ========================================================

\subsection{What changed at a glance}
\begin{itemize}
  \item \textbf{Pinned toolchain and actions:} CMake/Ninja are used explicitly; Emscripten version is fixed; core Actions are pinned to immutable SHAs where practicable.
  \item \textbf{Deterministic builds:} a minimal \texttt{CMakePresets.json} enables \texttt{Ninja} and \texttt{CMAKE\_EXPORT\_COMPILE\_COMMANDS=ON} for CodeQL.
  \item \textbf{Security hardening:} job/token permissions are least-privilege; third-party actions are minimized; Pages deploy has concurrency guards.
  \item \textbf{Dependency risk gate:} a PR-only dependency review job blocks high-severity advisories.
  \item \textbf{Release sanity:} \texttt{wasm-opt} optimization, a size budget check, and GitHub auto release notes.
  \item \textbf{Pages QA:} basic link check and a \texttt{workflow\_dispatch} path for manual previews.
  \item \textbf{Headless smoke test:} quick Node-based load check for the generated JS glue.
  \item \textbf{Docs \& badges:} drop-in Markdown badge snippet for CI/Pages/Release status.
\end{itemize}

\subsection{Minimal CMake/Ninja presets (drop-in)}
\noindent Place this in the repository root as \texttt{CMakePresets.json} to standardize local and CI builds and to emit \texttt{compile\_commands.json} for CodeQL.
\begin{minted}[fontsize=\small,breaklines]{json}
{
  "version": 3,
  "cmakeMinimumRequired": { "major": 3, "minor": 22, "patch": 0 },
  "configurePresets": [
    {
      "name": "wasm-release",
      "generator": "Ninja",
      "binaryDir": "build",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_EXPORT_COMPILE_COMMANDS": "ON"
      }
    }
  ]
}
\end{minted}

% ========================================================
\section{Updated Workflows (drop-in, production-ready)}
% ========================================================

\subsection{\texttt{.github/workflows/build.yml} — Build \& Test (WASM)}
\begin{minted}[fontsize=\small,breaklines]{yaml}
name: Build & Test (WASM)

on:
  push:
    branches: [ "main" ]
  pull_request:
  workflow_dispatch:
    inputs:
      emscripten:
        description: "emscripten/emsdk version (e.g., 3.1.59)"
        required: false

# sensible defaults and least privilege
permissions:
  contents: read

concurrency:
  group: build-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
      - name: Restore emsdk cache
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: |
            ~/.cache/emscripten
            ~/.emscripten_cache
          key: ${{ runner.os }}-emsdk-${{ inputs.emscripten || '3.1.59' }}
      - name: Install build deps
        run: |
          sudo apt-get update
          sudo apt-get install -y ninja-build cmake
      - name: Setup Emscripten SDK
        # Pinning a third-party action ideally uses a full SHA; if avoiding third-party, do a manual install.
        # For simplicity and speed, we use the maintained setup action. You may replace with a manual script if desired.
        uses: mymindstorm/setup-emsdk@v14
        with:
          version: ${{ inputs.emscripten || '3.1.59' }}
      - name: Configure (Ninja + compile_commands.json)
        run: cmake -S . -B build -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
      - name: Build
        run: cmake --build build --parallel 2
      - name: Headless smoke test (Node load check)
        run: |
          set -eux
          test -f build/index.js || test -f build/main.js
          FILE=$( [ -f build/index.js ] && echo build/index.js || echo build/main.js )
          node -e "const fs=require('fs'); const s=fs.readFileSync(process.argv[1],'utf8'); if(!/Module/.test(s)) { throw new Error('Emscripten glue missing Module symbol'); }" "$FILE"
      - name: Upload artifact (bundle)
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: wasm-bundle
          path: |
            build/**
          if-no-files-found: error
          retention-days: 7
\end{minted}

\subsection{\texttt{.github/workflows/codeql.yml} — CodeQL for C/C++ (manual build mode)}
\begin{minted}[fontsize=\small,breaklines]{yaml}
name: CodeQL (C/C++)

on:
  push:
    branches: [ "main" ]
  pull_request:
  schedule:
    - cron: "31 3 * * 0"

permissions:
  contents: read
  security-events: write

jobs:
  analyze:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
      - name: Install build deps
        run: |
          sudo apt-get update
          sudo apt-get install -y ninja-build cmake
      - name: Initialize CodeQL (C/C++, manual build)
        uses: github/codeql-action/init@v3
        with:
          languages: cpp
          queries: security-and-quality
          build-mode: manual
      - name: Configure (emit compile_commands.json)
        run: cmake -S . -B build -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
      - name: Build (no parallel to keep logs smaller)
        run: cmake --build build --parallel 1
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
\end{minted}

\subsection{\texttt{.github/workflows/dependency-review.yml} — PR Gate}
\begin{minted}[fontsize=\small,breaklines]{yaml}
name: Dependency Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read

jobs:
  review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
      - name: Dependency Review (block high severity)
        uses: actions/dependency-review-action@v4
        with:
          fail-on-severity: high
          comment-summary-in-pr: true
\end{minted}

\subsection{\texttt{.github/workflows/pages.yml} — GitHub Pages (with QA \& manual trigger)}
\begin{minted}[fontsize=\small,breaklines]{yaml}
name: Pages

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: github-pages
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
      - name: Build site (static bundle)
        run: |
          cmake -S . -B build -G Ninja -DCMAKE_BUILD_TYPE=Release
          cmake --build build --parallel 2
          test -d build
      - name: Link sanity check
        run: |
          set -eux
          python3 - << 'PY'
          import os, sys, re
          bad = []
          for root, _, files in os.walk('build'):
              for f in files:
                  if f.endswith(('.html','.htm')):
                      p = os.path.join(root,f)
                      s = open(p,'r',errors='ignore').read()
                      for href in re.findall(r'href=[\'"](.*?)[\'"]', s):
                          if href.startswith('http'): continue
                          tgt = os.path.normpath(os.path.join(root, href))
                          if not os.path.exists(tgt):
                              bad.append((p, href))
          if bad:
              for p, h in bad[:20]:
                  print(f"Missing link: {p} -> {h}")
              sys.exit(1)
          PY
      - name: Upload Pages artifact (tarball)
        uses: actions/upload-pages-artifact@7b1f4a764d45c48632c6b24a0339c27f5614fb0b # v4.0.0
        with:
          path: build

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        # (Optionally pin this to a commit from actions/deploy-pages tags)
        uses: actions/deploy-pages@v4
\end{minted}

\subsection{\texttt{.github/workflows/release.yml} — Tag-based release, wasm-opt, size budget}
\begin{minted}[fontsize=\small,breaklines]{yaml}
name: Release (tag)

on:
  push:
    tags:
      - "v*.*.*"

permissions:
  contents: write

env:
  WASM_SIZE_BUDGET_KB: "1024"  # adjust as needed
  EM_VERSION: "3.1.59"

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
      - name: Install deps
        run: |
          sudo apt-get update
          sudo apt-get install -y ninja-build cmake
          npm i -g binaryen
      - name: Configure & build (Release)
        run: |
          cmake -S . -B build -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
          cmake --build build --parallel 2
      - name: Optimize wasm (wasm-opt -O3, strip)
        run: |
          set -eux
          WASM=$(ls build/*.wasm | head -n1)
          wasm-opt -O3 --strip-debug --strip-dwarf -o "${WASM%.wasm}.opt.wasm" "$WASM"
          mv "${WASM%.wasm}.opt.wasm" "$WASM"
      - name: Size budget check
        run: |
          set -eux
          WASM=$(ls build/*.wasm | head -n1)
          sz=$(du -k "$WASM" | cut -f1)
          echo "WASM size (KB): $sz"
          if [ "$sz" -gt "${WASM_SIZE_BUDGET_KB}" ]; then
            echo "::error title=Size budget exceeded::${sz} KB > ${WASM_SIZE_BUDGET_KB} KB"
            exit 1
          fi
      - name: Upload build as artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: release-bits
          path: build/**
          retention-days: 5
      - name: Create GitHub Release (notes generated)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -eux
          TAG="${GITHUB_REF_NAME}"
          gh release create "$TAG" build/* --generate-notes --title "$TAG"
\end{minted}

% ========================================================
\section{Repository-wide defaults and docs}
% ========================================================

\subsection{Job permission defaults (optional top-level)}
Add to each workflow if you want to guarantee the most restrictive default and override per job as needed:
\begin{minted}[fontsize=\small,breaklines]{yaml}
permissions:
  contents: read
\end{minted}

\subsection{README badges (copy/paste)}
\begin{minted}[fontsize=\small,breaklines]{md}
![Build](https://github.com/<OWNER>/<REPO>/actions/workflows/build.yml/badge.svg)
![CodeQL](https://github.com/<OWNER>/<REPO>/actions/workflows/codeql.yml/badge.svg)
![Pages](https://github.com/<OWNER>/<REPO>/actions/workflows/pages.yml/badge.svg)
![Release](https://github.com/<OWNER>/<REPO>/actions/workflows/release.yml/badge.svg)
\end{minted}

\subsection{Notes on third-party pins}
Where a full commit SHA is not provided above (e.g., \texttt{mymindstorm/setup-emsdk}), prefer pinning to an immutable SHA for supply-chain safety or replace with an inline installation script.



\section*{Quality Gates \& Branch Protection}
To make CI results \emph{enforced}, enable branch protection on \texttt{main} (Settings \(\to\) Branches):
\begin{itemize}
  \item Require status checks to pass before merging: include \texttt{Build \& Test}, \texttt{CodeQL}, and \texttt{Dependency Review}.
  \item Require branch to be up to date before merging (optional, increases merge latency but avoids drift).
  \item Restrict who can push to \texttt{main}; favor PR-based changes.
  \item (Pages) Use environments with required reviewers if you want controlled promotions.
\end{itemize}


\section*{Risks \& Mitigations}
\begin{itemize}
  \item \textbf{Stale caches}: Emscripten or CMake cache may cause odd build diffs. \emph{Mitigation}: Include cache keys derived from the preset and a hash of \texttt{CMakeLists.txt}; provide a manual cache-bust input.
  \item \textbf{Insufficient tests}: WebAssembly builds pass but gameplay regresses. \emph{Mitigation}: Add headless smoke tests (e.g., \texttt{wasm3} or minimal browser run) and validate key exported functions.
  \item \textbf{Large bundle size}: Slow Pages loads and timeouts. \emph{Mitigation}: Enable \texttt{-O3} for release, compress (\texttt{.gz/.br}) on publish, and serve cache headers.
  \item \textbf{CodeQL noise}: First runs can flag legacy or third-party code. \emph{Mitigation}: Triage to \emph{dismiss with reason} or suppress safely; add a \texttt{.codeql/config.yml} to focus scope.
  \item \textbf{Supply-chain drift}: Dependency changes sneak in via submodules or vendored libs. \emph{Mitigation}: Lock versions; review diffs; use Dependabot \& Dependency Review.
  \item \textbf{Pages misconfiguration}: 404s or wrong directory published. \emph{Mitigation}: Confirm \texttt{build-wasm} path; verify environment and \texttt{pages} permissions.
\end{itemize}


\section*{Common Pitfalls \& Fixes}
\begin{itemize}
  \item \textbf{LaTeX Unicode tree chars}: Replace box-drawing characters with ASCII or \verb|\texttt| blocks.
  \item \textbf{Minted \& Pygments  errors}: Build with \texttt{-shell-escape}; avoid \texttt{} unless the styles exist; run \texttt{latexmk} without \texttt{outputdir} or configure \texttt{minted} accordingly.
  \item \textbf{CodeQL not running}: Ensure GitHub Advanced Security is enabled at org/repo and the CodeQL workflow has correct permissions.
  \item \textbf{Pages publish fails}: Confirm the \texttt{pages} and \texttt{id-token} permissions and the correct \texttt{artifact} path.
  \item \textbf{Emscripten not found}: Ensure the setup step calls \texttt{emsdk} and \texttt{source "\$EMSDK/emsdk\_env.sh"} before invoking \texttt{emcmake/emcc}.
\end{itemize}

\section*{Wrap-up \& next steps}
You now have a cohesive, repo-tailored CI/CD path: build and test with Emscripten, scan with CodeQL, guard dependency risk, publish a playable demo, and ship tagged releases. 
From here, consider small, incremental upgrades:
\begin{itemize}
  \item Add cache keys per preset/commit to speed builds even further.
  \item Extend tests with headless \texttt{wasm3} or browser-based smoke checks.
  \item Gate Pages deploys behind checks (e.g., \texttt{required\_status\_checks}) for stricter quality bars.
  \item Include Lighthouse (Pages) or Playwright runs for basic rendering validation.
\end{itemize}
\end{document}
