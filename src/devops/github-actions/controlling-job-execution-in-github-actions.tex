%========================================================
% Controlling Job Execution in GitHub Actions
% Dependencies • Conditions • Outputs • Concurrency • Containers • Matrix
%========================================================
\documentclass[11pt]{article}

% ---------- Encoding & layout ----------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{microtype}
\usepackage{setspace}
\setstretch{1.12}

% ---------- Colors & links ----------
\usepackage{xcolor}
\definecolor{ink}{HTML}{111827}      % gray-900
\definecolor{soft}{HTML}{F9FAFB}     % gray-50
\definecolor{accent}{HTML}{2563EB}   % blue-600
\definecolor{ok}{HTML}{059669}       % emerald-600
\definecolor{warn}{HTML}{D97706}     % amber-600
\definecolor{bad}{HTML}{DC2626}      % red-600
\usepackage[colorlinks=true,linkcolor=accent,urlcolor=accent,citecolor=accent]{hyperref}

% ---------- Code (minted) ----------
% ---------- Code (minted; CI-safe fallback) ----------
% If compiled with *unrestricted* -shell-escape and Pygments is available, minted will be used.
% Otherwise, we fall back to listings-based shims that compile in CI (no syntax highlighting).
\usepackage{xparse}

\newif\ifuseminted
\ifnum\pdfshellescape=1\relax
  \usemintedtrue
\else
  \usemintedfalse
\fi

% Floating code listings (optional; keeps \SetupFloatingEnvironment{listing}{...} working)
\usepackage{newfloat}
\usepackage{caption}
\usepackage{float}
\makeatletter
\@ifundefined{c@listing}{\DeclareFloatingEnvironment[fileext=lol,placement={!ht},name=Listing]{listing}}{}
\makeatother

\ifuseminted
  \usepackage[cache=false]{minted}
\else
  \usepackage{listings}

  % Global listings defaults (plain, robust)
  \lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    columns=fullflexible,
    frame=single,
    tabsize=2,
    % Common Unicode seen in docs (renders as ASCII / LaTeX equivalents)
    literate=
      {—}{{---}}1
      {–}{{--}}1
      {•}{{$\bullet$}}1
      {…}{{\ldots}}1
      {→}{{$\rightarrow$}}1
      {⇒}{{$\Rightarrow$}}1
      {✓}{{\checkmark}}1
      {✗}{{$\times$}}1
      {“}{{``}}1
      {”}{{''}}1
      {‘}{{`}}1
      {’}{{'}}1
  }

  % minted-compatible shims (options/lang are accepted but intentionally ignored)
  \providecommand{\usemintedstyle}[1]{}
  \providecommand{\setminted}[2][]{}
  \providecommand{\setmintedinline}[2][]{}

  \lstnewenvironment{minted}[2][]{\lstset{}}{}

  \NewDocumentCommand{\inputminted}{ O{} m m }{\lstinputlisting{#3}}

  \NewDocumentCommand{\mintinline}{ O{} m m }{\texttt{#3}}

  % Support for \newminted / \newmintedfile (define environments/commands; options/lang ignored)
  \makeatletter
  \NewDocumentCommand{\newminted}{ O{} m m }{%
    \def\minted@envname{#1}%
    \ifx\minted@envname\@empty
      \edef\minted@envname{#2code}%
    \fi
    \expandafter\lstnewenvironment\expandafter{\minted@envname}[1][]%
      {\lstset{}}{}%
  }
  \NewDocumentCommand{\newmintedfile}{ O{} m m }{%
    \def\minted@cmdname{#1}%
    \ifx\minted@cmdname\@empty
      \edef\minted@cmdname{input#2}%
    \fi
    \expandafter\NewDocumentCommand\csname \minted@cmdname\endcsname{ O{} m }{%
      \lstinputlisting{##2}%
    }%
  }
  \makeatother
\fi
\usemintedstyle{friendly}
\setminted{
  fontsize=\footnotesize,
  breaklines=true,
  breakanywhere=true,
  autogobble=true,
  tabsize=2
}

% ---------- Robust callout (no fragile grouping) ----------
\usepackage{framed} % already loaded indirectly, but harmless to include
\definecolor{calloutframe}{HTML}{111827}
\definecolor{calloutback}{HTML}{F9FAFB}
\setlength{\FrameRule}{0.6pt}
\setlength{\FrameSep}{8pt}
\newenvironment{callout}[1]{%
  \def\FrameCommand{\fcolorbox{calloutframe}{calloutback}}%
  \MakeFramed{\advance\hsize-\width \FrameRestore}%
  \noindent\textbf{#1}\par\medskip
}{%
  \endMakeFramed
}

% ---------- Title ----------
\title{\textbf{Controlling Job Execution in GitHub Actions}\\
\large Dependencies, Conditions, Outputs, Concurrency, Containers, and Matrix Strategies}
\author{}
\date{}

\begin{document}
\maketitle

\begin{callout}{What you'll learn}
Make jobs run serially with \texttt{needs}, guard runs with job/step \texttt{if} conditions, pass strings between jobs with job \texttt{outputs}, throttle work with \texttt{concurrency} groups, run inside containers via \texttt{container}, and fan out builds with \texttt{strategy.matrix}.
\end{callout}

\section*{Quick Reference}
\begin{itemize}
  \item \textbf{Serializing jobs:} use \texttt{needs: [job-a, job-b]}.
  \item \textbf{Conditional execution:} job/step \texttt{if: <expression>} (e.g., \texttt{success()}, \texttt{failure()}, \texttt{always()}, \texttt{cancelled()}).
  \item \textbf{Share small strings across jobs:} write to \texttt{GITHUB\_OUTPUT} in a step, map that step output to \texttt{jobs.<job>.outputs}, then consume via \texttt{\$\{\{ needs.<job>.outputs.<name> \}\}}.
  \item \textbf{Concurrency:} \texttt{concurrency:\{group:\ldots, cancel-in-progress: true|false\}} to ensure one run per group.
  \item \textbf{Containers:} \texttt{container: <image>} at job-level (plus \texttt{credentials}, \texttt{env}, \texttt{ports}, \texttt{volumes}).
  \item \textbf{Matrix:} \texttt{strategy.matrix} with \texttt{include}/\texttt{exclude}; control with \texttt{fail-fast} and \texttt{max-parallel}.
\end{itemize}

\section{Drop-in Example: Outputs + Needs + Concurrency + Container}
\subsection*{.github/workflows/jobs.yml}
\begin{minted}{yaml}
name: Jobs: outputs • needs • concurrency • container
on:
  push:
    branches: [ main ]

jobs:
  build:
    name: Build in Bun container (produce output)
    runs-on: ubuntu-latest
    # Job-level container pulls from Docker Hub by default
    container:
      image: oven/bun:1
      # Optionally authenticate to a private registry:
      # credentials:
      #   username: ${{ secrets.REGISTRY_USER }}
      #   password: ${{ secrets.REGISTRY_PASS }}
      env:
        MY_ENV_VAR: "hello"
      ports:
        - 8080
      volumes:
        - my_volume:/data
    outputs:
      bun_version: ${{ steps.capture.outputs.bun_version }}
    steps:
      - name: Capture Bun version
        id: capture
        run: |
          ver="$(bun --version)"
          echo "bun_version=${ver}" >> "$GITHUB_OUTPUT"

  deploy:
    name: Deploy (needs build output)
    runs-on: ubuntu-latest
    needs: [build]
    # Example condition: only run if not on the main branch
    if: ${{ github.ref != 'refs/heads/main' || always() }}
    steps:
      - name: Show value passed from build
        run: |
          echo "Bun version from build: ${{ needs.build.outputs.bun_version }}"

  concurrency-job-1:
    name: Concurrency A (group=test-concurrency)
    runs-on: ubuntu-latest
    concurrency:
      group: test-concurrency
      cancel-in-progress: false
    steps:
      - run: sleep 15

  concurrency-job-2:
    name: Concurrency B (group=test-concurrency)
    runs-on: ubuntu-latest
    concurrency:
      group: test-concurrency
      cancel-in-progress: false
    steps:
      - run: sleep 15
\end{minted}

\paragraph{Why this works.}
\texttt{deploy} waits for \texttt{build} (\texttt{needs}). The \texttt{build} job writes a step output to \texttt{GITHUB\_OUTPUT}, maps it to a job output, and \texttt{deploy} consumes it. The two \texttt{concurrency-*} jobs share a group so only one runs at a time; the other queues until the first finishes.

\begin{callout}{Outputs vs. Artifacts}
Use \textbf{job outputs} for small strings. For files/binaries/reports, use artifacts:
\end{callout}

\begin{minted}{yaml}
- name: Upload build report
  uses: actions/upload-artifact@v4
  with:
    name: report
    path: build/report.txt
\end{minted}

\section{Drop-in Example: Matrix Across OS and Versions}
\subsection*{.github/workflows/matrix.yml}
\begin{minted}{yaml}
name: Matrix demo
on:
  push:
    branches: [ main ]

jobs:
  test:
    name: ${{ matrix.runner }} • py ${{ matrix.python-version }}
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        runner: [ubuntu-latest, windows-latest]
        python-version: ["3.11", "3.12", "3.13"]
        include:
          - runner: macos-latest
            python-version: "3.12"
        exclude:
          - runner: windows-latest
            python-version: "3.13"
    steps:
      - name: Show current combo
        run: echo "Runner=${{ matrix.runner }}, Python=${{ matrix.python-version }}"
\end{minted}

\paragraph{Expected fan-out.}
Ubuntu: 3 jobs (3.11, 3.12, 3.13). Windows: 2 jobs (3.11, 3.12) because 3.13 excluded. macOS: 1 job (3.12). Total = 6.
\clearpage

\section{Recipes \& Patterns (Copy/Paste)}
\subsection*{Guard Jobs/Steps with Conditions}
\begin{minted}{yaml}
# Job runs even if dependencies fail:
if: ${{ always() }}

# Only on tags:
if: ${{ startsWith(github.ref, 'refs/tags/') }}

# Skip if commit message contains [skip ci]:
if: ${{ !contains(github.event.head_commit.message, '[skip ci]') }}

# Only on pull requests from forks:
if: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}
\end{minted}

\subsection*{Chain Jobs with Multiple Dependencies}
\begin{minted}{yaml}
jobs:
  a: { runs-on: ubuntu-latest, steps: [ { run: echo A } ] }
  b:
    needs: [a]
    runs-on: ubuntu-latest
    steps: [ { run: echo B needs A } ]
  c:
    needs: [a, b]
    runs-on: ubuntu-latest
    steps: [ { run: echo C after A and B } ]
\end{minted}

\subsection*{Concurrency: Key by Branch or Workflow}
\begin{minted}{yaml}
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
\end{minted}

\subsection*{Containers: Private Registry + Env/Ports/Volumes}
\begin{minted}{yaml}
jobs:
  in-container:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/acme/my-runtime:1.2.3
      credentials:
        username: ${{ secrets.GHCR_USER }}
        password: ${{ secrets.GHCR_TOKEN }}
      env:
        APP_MODE: ci
      ports: [8080]
      volumes:
        - cache:/cache
    steps:
      - run: my-runtime --version
\end{minted}

\subsection*{Dynamic Matrix (from Script Output)}
\begin{minted}{yaml}
jobs:
  gen-matrix:
    runs-on: ubuntu-latest
    outputs:
      combo: ${{ steps.mk.outputs.combo }}
    steps:
      - id: mk
        run: |
          # Produce JSON: {"include":[{"runner":"ubuntu-latest","py":"3.12"}]}
          echo 'combo={"include":[{"runner":"ubuntu-latest","py":"3.12"},{"runner":"windows-latest","py":"3.11"}]}' >> "$GITHUB_OUTPUT"

  use-matrix:
    needs: gen-matrix
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix: ${{ fromJson(needs.gen-matrix.outputs.combo) }}
    steps:
      - run: echo "Runner=${{ matrix.runner }}, py=${{ matrix.py }}"
\end{minted}

\section{Common Pitfalls \& Fixes}
\begin{itemize}
  \item \textbf{Forgot \texttt{id} on a step} before referencing \texttt{steps.<id>.outputs.<name>}.
  \item \textbf{Not writing to \texttt{GITHUB\_OUTPUT}}: use \texttt{echo "k=v" >> \$GITHUB\_OUTPUT}.
  \item \textbf{Using outputs for files}: prefer artifacts for files/binaries.
  \item \textbf{Matrix blow-up}: add \texttt{exclude} and tune \texttt{max-parallel}.
  \item \textbf{Container networking confusion}: job-level \texttt{ports} expose container ports on the runner; services need \texttt{services:}.
  \item \textbf{Long queues on hot branches}: set \texttt{cancel-in-progress: true} with a branch-keyed group.
\end{itemize}

\section{Debugging Tips}
\begin{minted}{yaml}
- name: Dump context (useful for authoring)
  if: ${{ runner.os == 'Linux' }}
  run: |
    echo "Ref=${GITHUB_REF}"
    echo "SHA=${GITHUB_SHA}"
    echo "Actor=${GITHUB_ACTOR}"
    echo "Workflow=${GITHUB_WORKFLOW}"
\end{minted}

\end{document}
