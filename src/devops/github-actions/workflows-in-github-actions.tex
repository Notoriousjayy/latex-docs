
%========================================================
% Workflows in GitHub Actions — Practical Quick Reference
%========================================================
\documentclass[11pt]{article}

% ---------- Encoding & layout ----------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}         % Better Latin fonts
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{microtype}
\usepackage{setspace}
\setstretch{1.1}

% ---------- Colors, links, boxes ----------
\usepackage{xcolor}
\definecolor{ink}{HTML}{111827}      % gray-900
\definecolor{soft}{HTML}{F9FAFB}     % gray-50
\definecolor{accent}{HTML}{2563EB}   % blue-600
\definecolor{ok}{HTML}{059669}       % emerald-600
\definecolor{warn}{HTML}{D97706}     % amber-600
\definecolor{bad}{HTML}{DC2626}      % red-600
\usepackage{hyperref}
% ---------- Silence first-run .toc warnings (latexmk treats them as missing input) ----------
\usepackage{etoolbox}
\makeatletter
\patchcmd{\@starttoc}
  {\InputIfFileExists{\jobname.#1}{}{\typeout{No file \jobname.#1.}}}
  {\InputIfFileExists{\jobname.#1}{}{}}
  {}{}
\makeatother
% ---------- End .toc silence ----------
\hypersetup{
  colorlinks=true,
  linkcolor=accent,
  urlcolor=accent,
  citecolor=accent
}

% ---------- Minted (syntax highlighting) ----------
% NOTE: Compile with: -shell-escape
% ---------- Minted compatibility layer (CI-safe) ----------
% This document can render code with minted when -shell-escape is enabled, and
% falls back to listings when it is not (so CI builds do not hard-fail).
\newif\ifUseMinted
\UseMintedfalse
\begingroup
\ifdefined\pdfshellescape
  \ifnum\pdfshellescape=1\relax
    \global\UseMintedtrue
  \fi
\fi
\endgroup

\ifUseMinted
  \usepackage[newfloat]{minted}
\else
  \usepackage{listings}
  \usepackage{xcolor}
  \usepackage{newfloat}
  \usepackage{fancyvrb} % provides \VerbatimEnvironment used by some wrappers

  % Provide a "listing" float compatible with minted's newfloat option
  \makeatletter
  \@ifundefined{c@listing}{%
    \DeclareFloatingEnvironment[name=Listing]{listing}
  }{}
  \makeatother

  % Minimal language definitions for common "minted" lexers / labels used in docs.
  % These are intentionally lightweight; they exist primarily to avoid build failures.
  \lstdefinelanguage{yaml}{
    sensitive=true,
    morecomment=[l]{\#},
    morestring=[b]",
    morestring=[b]',
  }
  \lstdefinelanguage{json}{
    sensitive=true,
    morestring=[b]",
    showstringspaces=false,
  }
  \lstdefinelanguage{ini}{
    sensitive=true,
    morecomment=[l]{;},
    morecomment=[l]{\#},
    morestring=[b]",
    morestring=[b]',
  }
  \lstdefinelanguage{cmake}{
    sensitive=true,
    morecomment=[l]{\#},
    morestring=[b]",
    morestring=[b]',
  }
  \lstdefinelanguage{powershell}{
    sensitive=true,
    morecomment=[l]{\#},
    morestring=[b]",
    morestring=[b]',
    morekeywords={param,begin,process,end,function,filter,return,if,elseif,else,foreach,for,while,do,until,break,continue,try,catch,finally,throw,switch},
  }
  \lstdefinelanguage{bash}{
    sensitive=true,
    morecomment=[l]{\#},
    morestring=[b]",
    morestring=[b]',
    morekeywords={if,then,else,elif,fi,for,do,done,while,in,case,esac,function,local,return,export,unset,echo,printf,read,cd,exit},
  }
  \lstdefinelanguage{sh}{sensitive=true, morecomment=[l]{\#}, morestring=[b]", morestring=[b]'}
  \lstdefinelanguage{shell}{sensitive=true, morecomment=[l]{\#}, morestring=[b]", morestring=[b]'}
  \lstdefinelanguage{console}{sensitive=false}
  \lstdefinelanguage{terminal}{sensitive=false}
  \lstdefinelanguage{md}{sensitive=false}
  \lstdefinelanguage{markdown}{sensitive=false}
  \lstdefinelanguage{text}{sensitive=false}

  % Reasonable defaults; keep this conservative to avoid surprises.
  \lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    upquote=true,
    frame=single,
    framerule=0.2pt,
    aboveskip=0.75\baselineskip,
    belowskip=0.75\baselineskip,
    % Common Unicode glyphs seen in snippets
    literate=
      {•}{{\textbullet}}1
      {—}{{---}}1
      {–}{{--}}1
      {→}{{$\rightarrow$}}1
      {←}{{$\leftarrow$}}1
      {≥}{{$\ge$}}1
      {≤}{{$\le$}}1
  }

  % Minted command shims (ignore style/options in fallback)
  \providecommand{\usemintedstyle}[1]{}
  \providecommand{\setminted}[1]{}
  \providecommand{\setmintedinline}[1]{}

  % NOTE: minted's optional key-value options are not 1:1 with listings'
  % key-value options. To avoid hard failures, we intentionally ignore the
  % optional options argument in the fallback path.

  % minted: \begin{minted}[<opts>]{<lang>} ... \end{minted}
  \lstnewenvironment{minted}[2][]%
    {\lstset{language=#2}}%
    {}

  % minted: \inputminted[<opts>]{<lang>}{<file>}
  \newcommand{\inputminted}[3][]{\lstinputlisting[language=#2]{#3}}

  % minted: \mintinline{<lang>}{<code>}
  \newcommand{\mintinline}[2]{\texttt{#2}}

  % minted: \newminted[<envname>]{<lang>}{<opts>}
  \newcommand{\newminted}[3][]{%
    \def\MintedEnvName{#1}%
    \if\relax\detokenize{#1}\relax
      \edef\MintedEnvName{#2code}%
    \fi
    \expandafter\lstnewenvironment\expandafter{\MintedEnvName}[1][]%
      {\lstset{language=#2}}%
      {}%
  }

  % minted: \newmintedfile{<lang>}{<opts>} -> \input<lang>{file}
  \newcommand{\newmintedfile}[2]{%
    \expandafter\newcommand\csname input#1\endcsname[2][]{\lstinputlisting[language=#1]{##2}}%
  }

  % minted exposes \listoflistings; keep it defined for compatibility
  \providecommand{\listoflistings}{\listof{listing}{List of Listings}}
\fi
% ---------- End minted compatibility layer ----------
\setminted{cache=false,
  fontsize=\small,
  breaklines=true,
  autogobble=true,
  tabsize=2
}
\newmintedfile{yaml}{}
\newminted{yaml}{}
\newminted{bash}{}
\newminted{powershell}{}
\newminted{text}{}

% ---------- Lists ----------
\usepackage{enumitem}
\setlist[itemize]{topsep=4pt,itemsep=2pt,parsep=0pt}
\setlist[enumerate]{topsep=4pt,itemsep=2pt,parsep=0pt}

% ---------- Title ----------
\usepackage{titling}
\pretitle{\vspace*{-1em}\begin{center}\LARGE\bfseries\color{ink}}
\posttitle{\par\end{center}\vspace{0.5em}}
\preauthor{\begin{center}\large}
\postauthor{\par\end{center}\vspace{1em}}
\title{Workflows in GitHub Actions\\\large Hands-on Cheat Sheet}
\author{Practical notes distilled into runnable examples}
\date{\today}

\begin{document}
\maketitle

\section*{How to use this sheet}
This document focuses on the essentials for writing, understanding, and running GitHub Actions \emph{workflows}: YAML structure, triggers, jobs/steps, and runners. Examples are drop-in and minimal. Compile this \LaTeX{} with \verb|pdflatex -shell-escape| (or \verb|xelatex -shell-escape|) to enable \texttt{minted}.

\section{YAML in 90 seconds}
YAML is indentation-sensitive and built from \textbf{scalars} (numbers, strings, booleans, null) and \textbf{collections} (lists with \verb|-| and maps/dictionaries as key: value).

\begin{yamlcode}
number: 42
pi: 3.14159
title: "Hello, YAML"
flag: true
nothing: null   # or ~
list:
  - build
  - test
  - deploy
map:
  name: "Mirana"
  traits:
    color: black
    friendly: true
  skills: [jump, play, nap]
\end{yamlcode}
\clearpage

\section{Workflow anatomy}
Workflow files live under \verb|.github/workflows/*.yml| and are made of:
\begin{itemize}
  \item \texttt{name}: a human-friendly title.
  \item \texttt{on}: \emph{triggers} that launch runs.
  \item \texttt{jobs}: one or more jobs (parallel by default).
  \item Within each job: \texttt{runs-on} (runner label) and \texttt{steps} (commands or actions).
\end{itemize}

\begin{yamlcode}
name: "Workflow Overview"
on: push
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build
        run: echo "Building..."

  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy
        run: echo "Deploying..."
\end{yamlcode}

\section{Triggers (\texttt{on})}
You can launch workflows manually, on a schedule, or when repository events occur.
\subsection*{Manual}
\begin{yamlcode}
on:
  workflow_dispatch: {}
\end{yamlcode}

\subsection*{Schedule (CRON)}
\begin{yamlcode}
on:
  schedule:
    - cron: "0 9 * * 1-5"  # Weekdays at 09:00 UTC
\end{yamlcode}

\subsection*{Repository activity}
\begin{yamlcode}
on:
  push:
    branches: [main]
  issues:
    types: [opened, labeled]
\end{yamlcode}

\section{Jobs and steps}
Jobs define the runner and contain \emph{steps}. Steps either \verb|run| shell commands or \verb|uses| a prebuilt action.
\begin{yamlcode}
jobs:
  my_job:
    name: "Build and Test"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Unit tests
        run: npm test

      - name: Python step (explicit shell)
        shell: python
        run: |
          print("Hello from Python shell")
\end{yamlcode}
\clearpage

\section{A complete minimal workflow}
\begin{yamlcode}
name: "Workflow Overview"
on:
  workflow_dispatch:
  push: { branches: [main] }

jobs:
  a_simple_job:
    name: "My First Job"
    runs-on: ubuntu-latest
    steps:
      - name: Echo from bash
        id: stepId
        run: echo "This is the first step from the first job"

      - name: Print from Python shell
        shell: python
        run: |
          print("Hello from Python")

  # Example of a second job that could run in parallel
  another_job:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Another job running in parallel"
\end{yamlcode}
\clearpage

\section{Runners: GitHub-hosted vs Self-hosted}
\textbf{GitHub-hosted} runners are ephemeral VMs (Ubuntu, Windows, macOS) provided by GitHub and preloaded with common tooling. \textbf{Self-hosted} runners are machines you manage (on-prem, VM, or personal) where you install and register the runner. Select a runner with \verb|runs-on|:
\begin{yamlcode}
runs-on: ubuntu-latest     # GitHub-hosted
# runs-on: self-hosted     # Your machine/VM
\end{yamlcode}

\subsection*{Setup a self-hosted runner (Windows example)}
Run these in an elevated PowerShell:
\begin{powershellcode}
mkdir C:\actions-runner; cd C:\actions-runner
# Download the runner package (URL provided by GitHub UI)
Invoke-WebRequest -Uri "<runner-zip-url>" -OutFile actions-runner.zip

# (Optional) Validate integrity (command shown in UI)
# Expand the archive
Add-Type -AssemblyName System.IO.Compression.FileSystem
[IO.Compression.ZipFile]::ExtractToDirectory("actions-runner.zip", ".")

# Configure the runner (token/URL provided by GitHub UI)
.\config.cmd --url https://github.com/<owner>/<repo> --token <TOKEN>

# Install as a service (optional)
.\svc install
.\svc start
\end{powershellcode}

If you prefer a plain CMD step in a job on Windows, set \verb|shell: cmd| to avoid PowerShell execution policy issues:
\begin{textcode}
shell: cmd
run: |
  echo This is a multiline command
  echo Executed on a self-hosted runner
\end{textcode}

\section{Helpful tips}
\begin{itemize}
  \item Keep each workflow focused (build, test, release) for clarity.
  \item Use explicit \verb|name| for workflows, jobs, and steps for nicer logs.
  \item Pin actions to major versions (e.g., \verb|actions/checkout@v4|).
  \item When using Windows self-hosted, \verb|shell: cmd| is a simple default.
  \item Combine multiple triggers when useful (e.g., \verb|push| and \verb|workflow_dispatch|).
\end{itemize}

\bigskip
\noindent\textit{These notes summarize core ideas from lesson material on workflows, YAML, triggers, jobs/steps, and runners, plus pragmatic tips and examples.}

\end{document}