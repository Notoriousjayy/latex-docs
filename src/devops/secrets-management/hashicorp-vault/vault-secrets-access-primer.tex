% vault-secrets-access-primer.tex
% CI-safe: No minted, no Pygments, no shell-escape required
\documentclass[11pt]{article}

% === Encoding & Fonts ===
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{microtype}

% === Page Layout ===
\usepackage[margin=1in]{geometry}
\usepackage{parskip}
\usepackage{setspace}

% === Tables ===
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{array}

% === Lists ===
\usepackage{enumitem}
\setlist{itemsep=2pt, topsep=4pt, leftmargin=1.2em}

% === Colors ===
\usepackage{xcolor}
\definecolor{CodeBg}{HTML}{F3F4F6}
\definecolor{LinkBlue}{HTML}{1E40AF}

% === Hyperlinks ===
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=LinkBlue, urlcolor=LinkBlue, citecolor=LinkBlue}

% === Code Blocks (listings only) ===
\usepackage{listings}
\usepackage{upquote}

\lstset{
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{CodeBg},
  breaklines=true,
  columns=fullflexible,
  keepspaces=true,
  showstringspaces=false,
  frame=single,
  framerule=0.4pt,
  tabsize=2,
  aboveskip=8pt,
  belowskip=8pt
}

\lstnewenvironment{bashcode}{\lstset{language=bash}}{}
\lstnewenvironment{yamlcode}{\lstset{}}{}
\lstnewenvironment{textcode}{\lstset{}}{}

% === Silence missing .toc on first run ===
\makeatletter
\let\orig@starttoc\@starttoc
\def\@starttoc#1{\IfFileExists{\jobname.#1}{\orig@starttoc{#1}}{}}
\makeatother

% === Document ===
\title{Vault Secrets Access Primer\\\large A Detailed, Practical Guide}
\author{Compiled Notes}
\date{\today}

\begin{document}
\maketitle
\setstretch{1.1}

\begin{abstract}
This document provides a practical overview of HashiCorp Vault for secrets management. It covers architecture, security model, authentication and authorization, token lifecycle, policies, secrets engines, leases and revocation, auditing, high availability, operations runbooks, observability, and common troubleshooting.
\end{abstract}

\section{Executive Summary}

Vault is a platform for securely storing, generating, and brokering access to sensitive data such as API keys, database credentials, certificates, and encryption keys. It encrypts data, enforces least-privilege access via policies, issues short-lived credentials, and records access for auditability.

\section{Quick Start (Developer Flow)}

\subsection{Authenticate to get a client token}

\begin{bashcode}
# Example: AppRole login (role_id + secret_id -> client token)
curl -sS --request POST \
  --data '{"role_id":"ROLE_ID","secret_id":"SECRET_ID"}' \
  https://vault.example.com/v1/auth/approle/login
# Response contains .auth.client_token. Export it as VAULT_TOKEN.
\end{bashcode}

\subsection{Read or write a secret on KV v2}

\begin{bashcode}
# Read the latest version
curl -sS -H "X-Vault-Token: $VAULT_TOKEN" \
  https://vault.example.com/v1/kv/data/app/backend

# Write a new secret version
curl -sS -X POST -H "X-Vault-Token: $VAULT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"data":{"password":"s3cr3t"}}' \
  https://vault.example.com/v1/kv/data/app/backend
\end{bashcode}

\section{Architecture Overview}

\begin{itemize}
  \item \textbf{Single binary}: The Vault server exposes an HTTP API. The CLI is a thin client that calls the API.
  \item \textbf{Barrier encryption}: Vault never stores plaintext in storage backends. It encrypts data within an internal barrier.
  \item \textbf{Storage backends}: Integrated storage (Raft) or external systems (Consul, cloud stores).
  \item \textbf{Pluggable engines}: Auth methods and secrets engines are modular and enabled at paths.
\end{itemize}

\section{Security Model}

\subsection{Transport and at-rest protection}

\begin{itemize}
  \item \textbf{In transit}: TLS everywhere. Pin a trusted CA, enforce strong ciphers.
  \item \textbf{At rest}: AES-256-GCM for barrier encryption. Storage backends cannot decrypt data.
\end{itemize}

\subsection{Initialization, seal, and unseal}

\begin{itemize}
  \item \textbf{Initialization}: Creates a master key; splits it into shares using Shamir's Secret Sharing.
  \item \textbf{Sealed by default}: Vault starts sealed; administrators unseal by presenting a quorum of key shares.
  \item \textbf{Auto-unseal}: Optionally delegate unseal to a cloud KMS or HSM.
\end{itemize}

\section{Authentication and Authorization}

\subsection{Auth methods}

Common methods include: AppRole, LDAP/AD, GitHub, JWT/OIDC, Kubernetes ServiceAccount, cloud provider IAM. Each method issues a token after validating identity.

\subsection{Tokens}

\begin{itemize}
  \item \textbf{Properties}: Tokens carry policies, a TTL, and possibly usage limits.
  \item \textbf{Types}: Service tokens (renewable), batch tokens (lightweight), periodic tokens.
  \item \textbf{Response wrapping}: Server returns a short-lived single-use wrapper token.
\end{itemize}

\subsection{Policies (RBAC)}

Policies define capabilities over paths (read, list, create, update, delete, sudo).

\begin{textcode}
# Allow reading a single KV v2 path and listing its parent
path "kv/data/app/backend" {
  capabilities = ["read"]
}
path "kv/metadata/app" {
  capabilities = ["list"]
}
\end{textcode}

\section{Secrets Engines}

\subsection{KV engine (v1 vs v2)}

\begin{itemize}
  \item \textbf{KV v2}: Versioned key-value store with metadata and soft deletes.
  \item \textbf{KV v1}: Simpler, no versioning. Prefer v2 for most cases.
\end{itemize}

\subsection{Dynamic credentials}

On read, Vault generates short-lived credentials. When the lease expires, credentials are disabled automatically.

\subsection{Transit engine}

The transit engine provides crypto operations without revealing keys to clients.

\subsection{PKI engine}

The PKI engine mints X.509 certificates for internal CA usage.

\section{Leases, Renewal, and Revocation}

\begin{itemize}
  \item \textbf{Leases}: Apply to tokens and dynamic secrets with TTL and max TTL.
  \item \textbf{Renewal}: Clients can renew before expiry if allowed.
  \item \textbf{Revocation}: On expiry or admin action, Vault revokes secrets.
\end{itemize}

\begin{bashcode}
# Renew a token or lease
vault token renew
vault lease renew <lease_id>

# Explicit revoke
vault token revoke <token>
vault lease revoke <lease_id>
\end{bashcode}

\section{Auditing}

\begin{itemize}
  \item \textbf{Fail closed}: If Vault cannot write to any active audit device, requests are denied.
  \item \textbf{Devices}: File, syslog, socket. Ship to a centralized SIEM.
  \item \textbf{Coverage}: Authentication attempts, secret access, policy changes, admin operations.
\end{itemize}

\section{Security Best Practices}

\begin{tabularx}{\textwidth}{@{} p{2.5cm} X @{}}
\toprule
\textbf{Area} & \textbf{Recommended Practices} \\
\midrule
TLS & Enforce TLS with modern ciphers; pin CA; rotate server certs regularly. \\
Unseal & Use auto-unseal with a cloud KMS or HSM. \\
Auth & Prefer workload identity over long-lived static creds. \\
Policies & Default deny; minimal scopes; review regularly. \\
TTLs & Use short TTLs; prefer dynamic credentials. \\
Audit & Enable at least two audit devices; alert on write failures. \\
Backups & Automate snapshots; encrypt at rest; test restore. \\
\bottomrule
\end{tabularx}

\section{Common Troubleshooting}

\begin{itemize}
  \item \textbf{Permission denied}: Check token policies; confirm capabilities match path format.
  \item \textbf{Cannot connect}: Verify \texttt{VAULT\_ADDR} and TLS trust chain.
  \item \textbf{Sealed after restart}: Provide unseal shares or verify KMS connectivity.
\end{itemize}

\section{Handy Endpoints}

\begin{tabularx}{\textwidth}{@{} p{5cm} X @{}}
\toprule
\textbf{Endpoint} & \textbf{Purpose} \\
\midrule
\texttt{/v1/sys/health} & Health and seal status \\
\texttt{/v1/auth/approle/login} & Exchange role\_id and secret\_id for token \\
\texttt{/v1/kv/data/...} & KV v2 read/write data \\
\texttt{/v1/transit/encrypt/...} & Encrypt plaintext \\
\texttt{/v1/pki/issue/...} & Issue certificates \\
\bottomrule
\end{tabularx}

\end{document}
