%========================================================
% File: vault-primer-detailed.tex
% Build: xelatex -shell-escape vault-primer-detailed.tex
%        (or lualatex -shell-escape)
%========================================================
\documentclass[11pt]{article}

% ----- Encoding & layout -----
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{parskip}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{array}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=blue!60!black, urlcolor=blue!60!black, citecolor=blue!60!black}

% ----- Minted (syntax highlighting) -----

\definecolor{soft}{HTML}{F3F4F6}
% ---------- Code blocks (listings only - CI safe) ----------
\usepackage{listings}
\usepackage{upquote}

\lstdefinelanguage{yaml}{
  keywords={true,false,null},
  sensitive=false,
  comment=[l]{\#},
  morestring=[b]',
  morestring=[b]"
}

\lstset{
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{soft},
  breaklines=true,
  breakatwhitespace=false,
  columns=fullflexible,
  keepspaces=true,
  showstringspaces=false,
  frame=single,
  framerule=0.4pt,
  tabsize=2,
  aboveskip=6pt,
  belowskip=6pt,
  literate=
    {—}{{---}}1
    {–}{{--}}1
    {→}{{$\rightarrow$}}1
}
\newcommand{\mintinline}[3][]{\texttt{#3}}
\lstnewenvironment{bashcode}{\lstset{language=bash}}{}
\lstnewenvironment{yamlcode}{\lstset{language=yaml}}{}
\lstnewenvironment{jsoncode}{\lstset{}}{}
\lstnewenvironment{cmakecode}{\lstset{}}{}
\lstnewenvironment{textcode}{\lstset{}}{}
\lstnewenvironment{cppcode}{\lstset{language=C++}}{}
\lstnewenvironment{ccode}{\lstset{language=C}}{}
\lstnewenvironment{inicode}{\lstset{}}{}
\lstnewenvironment{pythoncode}{\lstset{language=Python}}{}

\title{Vault Secrets Access Primer\\\large A Detailed, Practical Guide}
\author{Compiled Notes}
\date{\today}

\begin{document}
\maketitle
\setstretch{1.12}

\begin{abstract}
This document provides a practical and detailed overview of HashiCorp Vault for secrets management. It covers architecture, security model, authentication and authorization, token lifecycle, policies, secrets engines, leases and revocation, auditing, high availability, operations runbooks, observability, and common troubleshooting. It includes hands-on examples using cURL and policy snippets. Graphical diagrams are intentionally omitted.
\end{abstract}

%========================================================
\section{Executive Summary}
Vault is a platform for securely storing, generating, and brokering access to sensitive data such as API keys, database credentials, certificates, and encryption keys. It encrypts data, enforces least-privilege access via policies, issues short-lived credentials, and records access for auditability. Production-grade deployments focus on strong transport security, careful unseal and key management, a minimal policy surface, short time-to-live (TTL) leases, and robust audit logging.

%========================================================
\section{Quick Start (Developer Flow)}
This section shows a minimal developer journey. Do not reuse dev settings for production.

\subsection{Authenticate to get a client token}
\begin{bashcode}
# Example: AppRole login (role_id + secret_id -> client token)
curl -sS --request POST \
  --data '{"role_id":"ROLE_ID","secret_id":"SECRET_ID"}' \
  https://vault.example.com/v1/auth/approle/login
# Response contains .auth.client_token. Export it as VAULT_TOKEN.
\end{bashcode}

\subsection{Read or write a secret on KV v2}
\begin{bashcode}
# Read the latest version
curl -sS -H "X-Vault-Token: $VAULT_TOKEN" \
  https://vault.example.com/v1/kv/data/app/backend

# Write a new secret version
curl -sS -X POST -H "X-Vault-Token: $VAULT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"data":{"password":"s3cr3t"}}' \
  https://vault.example.com/v1/kv/data/app/backend
\end{bashcode}

%========================================================
\section{Architecture Overview}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{Single binary}: The Vault server exposes an HTTP API. The CLI is a thin client that calls the API.
  \item \textbf{Barrier encryption}: Vault never stores plaintext in storage backends. It encrypts data within an internal barrier; the backend only sees ciphertext.
  \item \textbf{Storage backends}: Integrated storage (Raft) or external systems (for example, Consul, cloud stores). Backends store both secret data and operational metadata (tokens, policies, mounts).
  \item \textbf{Pluggable engines}: Auth methods (how clients prove identity) and secrets engines (how data is generated or stored) are modular and enabled at paths.
\end{itemize}

\subsection{Production topologies}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{HA cluster}: Multiple nodes behind a load balancer. One active node serves writes; standbys forward reads and promote on failover.
  \item \textbf{Integrated storage (Raft)}: Simple to operate; supports snapshots for backup and restore.
  \item \textbf{Consul-based}: External KV store provides HA and distribution; operational practices shift to the Consul layer.
\end{itemize}

%========================================================
\section{Security Model}
\subsection{Transport and at-rest protection}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{In transit}: TLS everywhere. Pin a trusted CA, enforce strong ciphers.
  \item \textbf{At rest}: AES-256-GCM (or comparable) for barrier encryption. Storage backends cannot decrypt data.
\end{itemize}

\subsection{Initialization, seal, and unseal}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{Initialization}: Creates a master key; splits it into shares using Shamir's Secret Sharing.
  \item \textbf{Sealed by default}: Vault starts sealed; administrators unseal by presenting a quorum of key shares.
  \item \textbf{Auto-unseal}: Optionally delegate unseal to a cloud KMS or HSM for hands-off restarts while maintaining hardware security guarantees.
\end{itemize}

\subsection{Namespacing and multi-tenancy}
If using a multi-tenant model, isolate teams with separate mounts and policies. Enterprise features can further segment namespaces.

%========================================================
\section{Authentication and Authorization}
\subsection{Auth methods (identity providers)}
Common methods include: AppRole, LDAP/AD, GitHub, JWT/OIDC (workload identity), Kubernetes ServiceAccount, cloud provider IAM. Each method issues a token after validating identity.
\clearpage

\subsection{Tokens}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{Properties}: Tokens carry policies, a TTL, and possibly usage limits.
  \item \textbf{Types}: Service tokens (renewable), batch tokens (lightweight, not renewable), periodic tokens (fixed renew cadence).
  \item \textbf{Response wrapping}: Server returns a short-lived single-use wrapper token; unwrap at the consumer to reduce secret exposure. Wrapper contents live in the caller's cubbyhole until unwrapped or expired.
  \item \textbf{Orphan tokens}: Tokens without parents that will not be revoked through a parent chain; useful for automation with care.
\end{itemize}

\subsection{Policies (RBAC)}
Policies define capabilities over paths (read, list, create, update, delete, sudo). Keep policies small and composable.

\paragraph{Minimal example (HCL shown as text).}
\begin{textcode}
# Allow reading a single KV v2 path and listing its parent
path "kv/data/app/backend" {
  capabilities = ["read"]
}
path "kv/metadata/app" {
  capabilities = ["list"]
}
\end{textcode}

\paragraph{Attach policies to identities.}
\begin{bashcode}
# Create a named policy from an HCL file
vault policy write app-backend ./policy.hcl

# Associate that policy with an AppRole, group, or auth method role as appropriate
\end{bashcode}

%========================================================
\section{Secrets Engines}
Secrets engines run behind mount paths and define how secrets are stored or generated.

\subsection{KV engine (v1 vs v2)}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{KV v2}: Versioned key-value store with metadata and soft deletes.
  \item \textbf{KV v1}: Simpler, no versioning. Prefer v2 for most cases.
\end{itemize}

\subsection{Dynamic credentials}
On read, Vault generates short-lived credentials (for example, database logins). When the lease expires or is revoked, credentials are disabled automatically.

\subsection{Transit engine (encryption as a service)}
The transit engine provides crypto operations without revealing keys to clients. Applications send plaintext and receive ciphertext, or vice versa.

\subsection{PKI engine (certificates)}
The PKI engine mints X.509 certificates. You can create an internal CA, issue leaf certificates with short TTLs, and revoke as needed.

\paragraph{Examples.}
\begin{bashcode}
# Enable KV v2 at path "kv"
vault secrets enable -path=kv kv-v2

# Enable Transit and create a key
vault secrets enable transit
vault write -f transit/keys/app-crypto

# Encrypt and decrypt with Transit
echo -n 'payload' | base64 > b64.txt
vault write transit/encrypt/app-crypto plaintext=$(cat b64.txt)
# => returns ciphertext "vault:v1:..."
vault write transit/decrypt/app-crypto ciphertext="vault:v1:..."

# Enable PKI and set a short default TTL
vault secrets enable pki
vault write pki/config/urls issuing_certificates="https://vault/pki/ca" crl_distribution_points="https://vault/pki/crl"
vault write pki/roles/app-dot-internal allowed_domains="app.internal" allow_subdomains=true max_ttl="24h"
vault write pki/issue/app-dot-internal common_name="api.app.internal" ttl="12h"
\end{bashcode}
\clearpage

%========================================================
\section{Leases, Renewal, and Revocation}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{Leases}: Apply to tokens and dynamic secrets. Each has a TTL and possibly a maximum TTL.
  \item \textbf{Renewal}: Clients can renew before expiry if allowed by policy and max TTL.
  \item \textbf{Revocation}: On expiry or admin action, Vault revokes secrets and, for dynamic credentials, disables them at the source system.
\end{itemize}

\paragraph{Working with leases.}
\begin{bashcode}
# Renew a token or lease
vault token renew            # for current token
vault lease renew <lease_id> # for specific lease

# Explicit revoke
vault token revoke <token>
vault lease revoke <lease_id>
\end{bashcode}

%========================================================
\section{Auditing}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{Fail closed}: If Vault cannot write to any active audit device, requests are denied.
  \item \textbf{Devices}: File, syslog, socket, and others. Use structured logging and ship to a centralized SIEM.
  \item \textbf{Coverage}: Authentication attempts, secret access, policy changes, and admin operations.
\end{itemize}

\paragraph{Examples.}
\begin{bashcode}
# Enable a file-based audit device
vault audit enable file file_path=/var/log/vault_audit.log

# Disable an audit device
vault audit disable file
\end{bashcode}

%========================================================
\section{High Availability and Performance}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{Active/standby}: One active handles writes; standbys forward and can promote on failure.
  \item \textbf{Request forwarding}: Standbys forward requests to the active when appropriate.
  \item \textbf{Performance standbys}: Offload read-heavy traffic and cryptographic offload in larger clusters.
  \item \textbf{Load balancing}: Health-check for \texttt{/v1/sys/health}. Favor sticky sessions for write-heavy clients if needed.
\end{itemize}

%========================================================
\section{Operations Runbooks}
\subsection{Backups and restore}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{Integrated storage}: Use snapshots. Secure, test restore regularly.
  \item \textbf{External backends}: Follow backend-native snapshot procedures plus encrypt backups and protect keys.
\end{itemize}

\subsection{Key rotation}
Rotate transit keys and PKI CAs at planned intervals. For transit, use key versioning and rewrap; for PKI, create new intermediates and roll out leaf cert issuance to the new chain.

\subsection{Upgrade procedure}
\begin{enumerate}[leftmargin=1.2em]
  \item Read release notes and verify compatibility.
  \item Snapshot storage or take a backend backup.
  \item Upgrade standbys first, then failover, then former active.
  \item Validate audit, auth mounts, and secrets engine mounts.
\end{enumerate}

\subsection{Disaster recovery}
Document \textbf{RTO} and \textbf{RPO}. Practice controlled failovers, unseal workflows, and token reissuance. Verify that audit and monitoring continue after failover.

%========================================================
\section{Observability}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{Metrics}: Export to Prometheus or your APM. Track request rates, latency, error codes, seal status, leader elections, and mount health.
  \item \textbf{Logs}: Separate audit logs from operational logs. Protect integrity and retention.
  \item \textbf{Alerts}: On seal events, leader changes, audit write failures, storage lag, auth failures, error spikes, and low TTL or renewal failures.
\end{itemize}

%========================================================
\section{Security Best Practices (Checklist)}
\begin{tabularx}{\textwidth}{@{} p{3.2cm} X @{}}
\toprule
\textbf{Area} & \textbf{Recommended Practices} \\
\midrule
TLS & Enforce TLS with modern ciphers; pin CA; rotate server certs regularly. \\
Unseal & Use auto-unseal with a cloud KMS or HSM; protect and rotate key material. \\
Auth & Prefer workload identity (Kubernetes, IAM, OIDC) over long-lived static creds. \\
Policies & Default deny; minimal scopes; split read from write; review regularly. \\
TTLs & Use short TTLs and max TTLs; prefer dynamic credentials. \\
Transit & Use Transit for application crypto instead of embedding keys in apps. \\
Audit & Enable at least two audit devices; ship logs to SIEM; alert on write failures. \\
Backups & Automate snapshots; encrypt at rest; test restore; document RTO and RPO. \\
Upgrades & Stage in lower environments; snapshot before change; roll forward with validation. \\
Secrets Hygiene & Tag owners; set rotation cadence; remove unused mounts and policies. \\
\bottomrule
\end{tabularx}

%========================================================
\section{Common Troubleshooting}
\subsection{Permission denied on a path}
\begin{itemize}[leftmargin=1.2em]
  \item Check token policies; confirm capabilities match engine path format.
  \item For KV v2, data paths are \texttt{kv/data/...} for data and \texttt{kv/metadata/...} for listing.
\end{itemize}

\subsection{Client cannot connect}
\begin{itemize}[leftmargin=1.2em]
  \item Verify \texttt{VAULT\_ADDR} and TLS trust chain.
  \item Check load balancer forwarding and health checks.
\end{itemize}

\subsection{Sealed state after restart}
\begin{itemize}[leftmargin=1.2em]
  \item Provide the required unseal shares or verify KMS/HSM connectivity for auto-unseal.
\end{itemize}

\subsection{Dynamic creds not revoked}
\begin{itemize}[leftmargin=1.2em]
  \item Confirm lease TTLs and revocation settings on the engine.
  \item Check backend permissions for revocation actions (for example, DB role).
\end{itemize}
\clearpage

%========================================================
\section{API and CLI Recipes}
\subsection{Enable and configure engines}
\begin{bashcode}
# Enable a versioned KV engine at path "kv"
vault secrets enable -path=kv kv-v2

# Tune default and max TTLs for KV metadata
vault secrets tune -default-lease-ttl=1h -max-lease-ttl=24h kv/
\end{bashcode}

\subsection{Issue and revoke tokens}
\begin{bashcode}
# Create a child token with restricted policy and TTL
vault token create -policy="app-backend" -ttl=30m -renewable=true

# Revoke a specific token
vault token revoke hvs.xxxxx
\end{bashcode}

\subsection{Use response wrapping}
\begin{bashcode}
# Wrap a secret for out-of-band delivery (TTL 2 minutes)
vault kv get -wrap-ttl=2m kv/app/backend
# Receiver unwraps:
vault unwrap <wrapping_token>
\end{bashcode}

\subsection{Kubernetes auth (conceptual)}
\begin{bashcode}
# Configure the Kubernetes auth method (service account JWT, CA cert, host)
vault auth enable kubernetes
vault write auth/kubernetes/config \
  kubernetes_host="https://$K8S_HOST" \
  kubernetes_ca_cert="@/path/ca.crt" \
  token_reviewer_jwt="@/var/run/secrets/kubernetes.io/serviceaccount/token"

# Map a service account to a policy
vault write auth/kubernetes/role/app \
  bound_service_account_names=api \
  bound_service_account_namespaces=default \
  policies=app-backend \
  ttl=30m
\end{bashcode}
\clearpage

%========================================================
\section{Operational Policies and Review Cadence}
\begin{itemize}[leftmargin=1.2em]
  \item \textbf{Quarterly}: Rotate Transit keys; review policies and mounts; verify backups and restores.
  \item \textbf{Monthly}: Sample audit trails; confirm access ownership; rotate long-lived app credentials if any remain.
  \item \textbf{Per release}: Read release notes; stage and validate upgrades; check health and audit after deployment.
\end{itemize}

%========================================================
\section{Appendix A: Minimal Dev Compose (Optional)}
This is a quick-start \texttt{docker-compose.yml} to experiment locally. Do not use for production.

\begin{yamlcode}
version: "3.8"
services:
  vault:
    image: hashicorp/vault:latest
    environment:
      - VAULT_DEV_ROOT_TOKEN_ID=root
      - VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200
    ports:
      - "8200:8200"
    cap_add:
      - IPC_LOCK
    command: "server -dev"
\end{yamlcode}

%========================================================
\section{Appendix B: Handy Endpoints (Cheat Sheet)}
\begin{tabularx}{\textwidth}{@{} p{5cm} X @{}}
\toprule
\textbf{Endpoint} & \textbf{Purpose} \\
\midrule
\texttt{/v1/sys/health} & Health and seal status. \\
\texttt{/v1/auth/approle/login} & Exchange role\_id and secret\_id for a client token. \\
\texttt{/v1/kv/data/...} & KV v2 read/write data. \\
\texttt{/v1/transit/encrypt/...} & Encrypt plaintext; returns ciphertext. \\
\texttt{/v1/transit/decrypt/...} & Decrypt ciphertext; returns plaintext. \\
\texttt{/v1/pki/issue/...} & Issue certificates from a PKI role. \\
\texttt{/v1/sys/audit} & Configure audit devices. \\
\texttt{/v1/auth/token/revoke} & Revoke a token. \\
\bottomrule
\end{tabularx}

\end{document}
